Part IV
Applying Java
This page intentionally left blank.
Chapter 29
The DynamicBillboard
Applet
1011
Robert Temple is a software engineer who has designed several highly used applets.His work includes the ESPNET SportsZone “HitCharts” and “Batter vs. Pitcher”applets. One of his most impressive applets is DynamicBillboard, which he wrote
while he was at Embry-Riddle Aeronautical University in Florida.
The DynamicBillboard applet displays a sequence of images by repeatedly
changing the image on the screen to another after a period of time. The transition
between one image and the next is done with one of a variety of special effects. One
example of a transition is the SmashTransition, where the new image drops down
from above the old image and appears to smash the old image out of place. The applet
links to other pages through a URL associated with each image. When the user presses
the mouse button with the cursor over the applet, the browser will go to the new page
associated with the current image. The DynamicBillboard applet provides web sites
with an elegant way to rotate ads, banners, or billboards on a single static page.
Robert has included many interesting optimizations. This applet would not be
functional without the careful changes that he crafted. There are enough tips and tricks
in this source code to help you make your applets really fly.
The APPLET Tag
The APPLET tag for DynamicBillboard is fairly easy to configure. You name the main
class in the code parameter and specify the width and height, as with most applets:
<applet code=DynamicBillboard width=392 height=72>
There are several parameters that must be specified for the applet to function
properly. Without them the applet does nothing. Also, you will notice that if you make
any mistakes naming files and such, the behavior is a little unfriendly: either nothing
happens or some of your billboards will be blank. The following parameters are
specified as:
<param name=parameter_name value="your value here">
■ bgcolor This parameter is used to set the background color of the applet
before the first image loads. You can use this to get rid of the gray applet
square quickly.
■ delay This parameter specifies the number of milliseconds between
each billboard. Typically, it’s a number like 5000 or 10000, meaning five or
ten seconds.
1012 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
■ billboards This parameter specifies the number of billboards you wish to
cycle through.
■ bill# This is shorthand for bill0, bill1, bill2, and so on, up to one less than the
number of billboards you’ve specified. (Robert is a typical programmer who
starts counting at 0.) You will have as many of these as you specified in the
billboards parameter. The value of each of these bill#s will be a pair of strings
separated by a comma. The first one is the image name to display for this
billboard. The second is the URL of where to go when the user clicks on this
billboard. Here is an example:
<param name="bill0" value="sample.jpg,http://www.example.com/">
■ transitions This is a list beginning with the number of items in the list as an
integer, followed by the list of Transition subclass names. Here is an example:
<param name="transitions" value="2,TearTransition,SmashTransition">
Here is an example of a complete APPLET tag with all of the transitions discussed
in this chapter:
<applet code=DynamicBillboard width=392 height=72>
<param name="bgcolor" value="#ffffff">
<param name="delay" value="5000">
<param name="billboards" value="5">
<param name="bill0"
value="board1.jpg,http://www.someURL">
<param name="bill1"
value="board2.jpg,http://www.someURL">
<param name="bill2"
value="board3.jpg,http://www.someURL">
<param name="bill3"
value="board4.jpg,http://www.someURL">
<param name="bill4"
value="board5.jpg,http://www.someURL">
<param name="transitions"
value="5,ColumnTransition,FadeTransition,TearTransition,
SmashTransition,UnrollTransition">
</applet>
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1013
A
P
P
LY
IN
G
JA
V
A
Source Code Overview
Robert designed the applet with a fast load time in mind. He tries to keep the size of
the applet to a minimum so that there is less code to send across the network. He also
attempts to delay some of the loading and initializing of the applet until after the first
image is displayed. As far as the user is concerned, the applet is running after the first
image is fully displayed, even though there is a lot more work to be done.
The applet consists of three main classes and any number of transition classes.
The three main classes are DynamicBillboard, BillData, and BillTransition. The
DynamicBillboard class is a top-level Applet subclass that uses all of the other classes.
The BillData class encapsulates a number of billboard attributes, including the image
and the URL associated with the image. The BillTransition class is an abstract class
that contains methods and attributes common to all transitions. The three main classes
are described next, along with five popular transitions.
DynamicBillboard.java
This is the main applet class. It implements Runnable to include a thread that
controls the continuous process of creation and animation of the transitions.
The transition_classes array stores the names of the transition classes as strings.
It uses strings because it loads these classes dynamically using the method
java.lang.Class.forName(String). This allows the applet to put off the loading of
these classes until they are first instantiated.
init( )
The init( ) method is called automatically when the applet is first loaded. Most applets
use this method to perform all of their necessary initialization. Robert, however,
decided to separate his initialization into two methods: init( ) and finishInit( ). The
idea behind splitting up the initialization is to try to display the first image within the
applet in the least amount of time, minimizing the time that the applet is showing a
blank rectangle while it is loading and initializing. The only processing that is done
in this init( ) method is that which is absolutely necessary to get initial content to the
screen, because the browser will not call paint( ) until after init( ) returns.
The first thing that Robert does with init( ) is to change the background color of the
applet and the parent frame in which the applet is embedded. In the past, the space
that an applet uses on the screen was shown as a solid gray box while the applet was
loading and initializing. This box would tend to stand out on pages that use a background
color other than gray, which is just about every page created since 1994. Robert discovered
a way around this problem. He found that applets always have a parent container in
which they are embedded. Under both Netscape Navigator and Internet Explorer, this
container is derived from the core Java class: java.awt.Container. Robert uses the
methods inherited from java.awt.Component—setBackground( ) and repaint( )—to
change the background color to the value of a bgcolor applet parameter. This makes
1014 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
the applet space stand out less than it does when it is gray. All this is done even before
the applet begins to load the first image.
With newer browsers, this frame no longer defaults to gray but rather uses the
background color of the page. Thus, today applets will not benefit from changing the
background color. However, this appoach still illustrates an interesting technique,
which you can adapt for other purposes.
After changing background colors, Robert’s applet reads in a parameter that tells
how many different billboards there will be and then allocates an array of BillData
objects based on this parameter.
With the help of Math.random( ), a random billboard is chosen to start.
parseBillData( ) is called to parse the parameters for this billboard.
parseBillData( )
This method creates and initializes the next billboard (BillData) object that the applet
will use. It only gets called if the billboard object has not been created yet (the element
corresponding to the next billboard object in the billboard array will be null).
Normally, parseBillData( ) calls the BillData method initPixels( ) after creating
the new object to initialize a pixel array within the BillData object. The first time this
method is called, however, the applet is still concentrating on getting the first image to
the screen as fast as possible. It knows this because the reference to the image that is
used to paint the applet is still null. So instead it sets the image variable and waits to
call the processor-intensive initPixel( ) method until after the first image is loaded.
finishInit( )
After the first image is displayed on the screen, the applet can finish the rest of its
initialization. This includes initializing the names of all the transition classes and
initializing the pixels array for the first billboard and reading the target parameter.
finishInit( ) is called from the run( ) method of the applet. The run( ) method
restarts from the top each time the user leaves and comes back to the page. When this
happens, finishInit( ) will be called again. Since the applet has already finished its
initialization, Robert does not want it to reinitialize everything. This is why the applet
checks to see if the delay variable has already been initialized. If it has, then the applet
can skip the rest of the initialization.
start( ) and stop( )
The start( ) and stop( ) methods respectively are called when the user comes to or
leaves the page. They ensure that the applet thread that runs the transitions is on or off.
If stop( ) is called while the applet is in the middle of running a transition, some
data might be left in an improper state. Some variables are reset in start( ) to make sure
the applet restarts with a new transition.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1015
A
P
P
LY
IN
G
JA
V
A
In start( ), the mouse cursor is changed to a hand so that when the mouse cursor is
over the applet, it will appear to be a link.
run( )
The run( ) method starts with a loop that waits for the first image to be fully loaded
before proceeding. It then finishes the initialization of the applet by calling
finishInit( ). From there, it enters the main loop of the program.
This main loop drives the transitions between billboards. Using the delay
parameter passed in from the HTML to the applet, the applet calculates when the next
transition is supposed to be run. While it is waiting, it prepares for the transition. It
starts the preparation by determining which billboard is to be displayed next, parsing
the billboard data from HTML parameters if this has not been done yet for this
billboard. Then it randomly chooses which transition to run next, being careful not to
let the applet run the same transition consecutively.
Once the applet has determined what transition will be run next, it creates a new
instance of this transition class by dynamically loading the class using the String name
and then creating a new instance of the class. The dynamic loading of the transition
classes has a big impact on the loading time of the applet as a whole. Instead of every
single class having to be downloaded before the applet starts, only three classes are
sent initially: DynamicBillboard, BillData, and BillTransition. The other transition
classes are only downloaded by the applet the first time they are needed. This reduces
the initial download of the applet significantly. Some class files might not even need to
be sent if the user leaves the page quickly.
Finally, the applet calls the init( ) method on the transition object, passing the
applet and image pixels for the current and next billboard as parameters. This creates
all the cell frames that are used to animate a transition. With the transition ready to go,
the applet only need wait for the proper time to start the transition.
The applet performs the transition by using simple frame animation—drawing each
cell in order onto the screen, with a short delay between each frame. The applet calls
the toolkit method sync( ) just to be sure that the drawing of one cell does not take
place before the previous cell has been shown on the screen. After the last cell is
displayed, the applet draws the image from the next billboard onto the screen to
complete the transition.
Following this, the mouse_over_applet flag is checked to see if the mouse cursor
is currently over the applet. If so, the URL of the previous billboard is showing on the
status bar and must be updated to reflect the URL of the new billboard. This is done
with a call to the applet method showStatus( ). The applet has completed this
transition and is now ready to begin the next one.
mouseMoved( ) and mouseExited( )
mouseMoved( ) and mouseExited( ) are used to change the text that appears on the
status bar. When the mouse cursor is over the applet, the status bar is supposed to
show the URL that the current billboard links to. So when mouseMoved( ) gets called,
1016 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
the applet shows the URL on the status bar. When mouseExited( ) is called, the URL
text is removed from the status bar. Both methods also set the Boolean mouse_inside_
applet to the appropriate value. This variable is used in the run( ) method after a
transition is run. If the mouse is positioned over the applet when the transition
completes, then the applet knows to show the URL of the new billboard on the
status bar.
mouseReleased( )
When the mouse button is pressed with the cursor over the applet and then released,
the mouseReleased( ) method is called. The applet uses getAppletContext( ).show-
Document( ) to send the browser to the URL that the current billboard points to. As
Robert found out, sometimes browsers take a long time to display this new page. To
keep the applet from running more transitions while the new page is waiting to load,
stop( ) is called to force the main thread to quit. To let users know that the applet is
loading the new page, the applet changes the mouse cursor to the wait cursor.
It is important to remember that users can come back to this page after going to a
new page. The wait cursor will still be present on the applet when users come back.
The start( ) method is always called when the user comes back to a page with an
applet, so the applet resets the cursor to the hand cursor there.
The Code
Here is the source code for the DynamicBillboard class:
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.awt.*;
import java.awt.image.*;
public class DynamicBillboard
extends java.applet.Applet
implements Runnable {
BillData[] billboards;
int current_billboard;
int next_billboard;
String[] transition_classes;
Thread thread = null;
Image image = null;
long delay = -1;
boolean mouse_inside_applet;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1017
A
P
P
LY
IN
G
JA
V
A
String link_target_frame;
boolean stopFlag;
public void init() {
String s = getParameter("bgcolor");
if(s != null) {
Color color = new Color(Integer.parseInt(s.substring(1), 16));
setBackground(color);
getParent().setBackground(color);
getParent().repaint();
}
billboards = new
BillData[Integer.parseInt(getParameter("billboards"))];
current_billboard = next_billboard
= (int)(Math.random() *billboards.length);
parseBillData();
}
void parseBillData() {
String s = getParameter("bill" + next_billboard);
int field_end = s.indexOf(",");
Image new_image = getImage(getDocumentBase(),
s.substring(0, field_end));
URL link;
try {
link = new URL(getDocumentBase(),
s.substring(field_end + 1));
}
catch (java.net.MalformedURLException e) {
e.printStackTrace();
link = getDocumentBase();
}
billboards[next_billboard] = new BillData(link, new_image);
if(image == null) {
image = new_image;
}
else {
prepareImage(new_image, this);
billboards[next_billboard].initPixels(getSize().width,
getSize().height);
}
1018 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}void finishInit() {
if(delay != -1) {
return;
}
delay = Long.parseLong(getParameter("delay"));
link_target_frame = getParameter("target");
if(link_target_frame == null) {
link_target_frame = "_top";
}
String s = getParameter("transitions");
int field_end = s.indexOf(",");
int trans_count = Integer.parseInt(s.substring(0, field_end));
transition_classes = new String[trans_count];
for(--trans_count; trans_count > 0; --trans_count) {
s = s.substring(field_end + 1);
field_end = s.indexOf(",");
transition_classes[trans_count] = s.substring(0, field_end);
}
transition_classes[0] = s.substring(field_end + 1);
billboards[next_billboard].initPixels(getSize().width,
getSize().height);
mouse_inside_applet = false;
}
public void paint(Graphics g) {
g.drawImage(image, 0, 0, this);
}
public void update(Graphics g) {
paint(g);
}
public void start() {
next_billboard = current_billboard;
image = billboards[current_billboard].image;
setCursor(new Cursor(Cursor.HAND_CURSOR));
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1019
A
P
P
LY
IN
G
JA
V
A
if(thread == null) {
thread = new Thread(this);
thread.start();
}
}
public void stop() {
if(thread != null) {
stopFlag = true;
}
}
public void run() {
while((checkImage(image, this) & ImageObserver.ALLBITS) == 0) {
try { Thread.sleep(600); } catch (InterruptedException e) {}
}
finishInit();
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
int last_transition_type = -1;
BillTransition transition;
long next_billboard_time;
while(true) {
if(stopFlag)
return;
next_billboard_time = System.currentTimeMillis() + delay;
current_billboard = next_billboard;
if(++next_billboard >= billboards.length) {
next_billboard = 0;
}
if(billboards[next_billboard] == null) {
parseBillData();
try { Thread.sleep(120); } catch (InterruptedException e) {}
}
int transition_type = (int)(Math.random() *
(transition_classes.length - 1));
if(transition_type >= last_transition_type) {
++transition_type;
1020 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}last_transition_type = transition_type;
try {
String trans = transition_classes[last_transition_type];
transition = (BillTransition)Class.forName(trans)
.newInstance();
}
catch(Exception e) {
e.printStackTrace();
continue;
}
transition.init(this,billboards[current_billboard].image_pixels,
billboards[next_billboard].image_pixels);
if(System.currentTimeMillis() < next_billboard_time) {
try {
Thread.sleep(next_billboard_time -
System.currentTimeMillis());
} catch (InterruptedException e) { };
}
Graphics g = getGraphics();
for(int c = 0; c < transition.cells.length; ++c) {
image = transition.cells[c];
g.drawImage(image, 0, 0, null);
getToolkit().sync();
try { Thread.sleep(transition.delay); }
catch(InterruptedException e) { };
}
image = billboards[next_billboard].image;
g.drawImage(image, 0, 0, null);
getToolkit().sync();
g.dispose();
if(mouse_inside_applet == true) {
showStatus(billboards[next_billboard].link.toExternalForm());
}
transition = null;
try { Thread.sleep(120); } catch (InterruptedException e) {}
}
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1021
A
P
P
LY
IN
G
JA
V
A
public class MyMouseAdapter extends MouseAdapter {
public void mouseExited(MouseEvent me) {
mouse_inside_applet = false;
showStatus("");
}
public void mouseReleased(MouseEvent me) {
stop();
setCursor(new Cursor(Cursor.WAIT_CURSOR));
getAppletContext().showDocument(billboards[current_billboard].link,
link_target_frame);
}
}
public class MyMouseMotionAdapter extends MouseMotionAdapter {
public void mouseMoved(MouseEvent me) {
mouse_inside_applet = true;
showStatus(billboards[current_billboard].link.toExternalForm());
}
}
}
BillData.java
The BillData class is mostly just a data structure for encapsulating attributes associated
with individual billboards. It contains three variables. The first variable stores the
URL to which the billboard is a link. The second variable has an Image that the applet
uses to draw on the screen. The third variable includes a pixel array of the image in
RGB format.
The pixel array is used by transitions in combination with another BillData pixel
array to create the cells for transition animation. The array is only one-dimensional.
The pixels in it are arranged in such a way that the first element in this array is the
top-left corner of the image. The second element is the pixel just to the right of this
corner. Elements that follow are the pixels to the right of this one, and so on, until the
rightmost pixel is reached. Then the leftmost pixel on the next line of the image is used.
This continues until the last index in the array, which corresponds to the pixel on the
bottom-right corner of the image.
You might notice that Robert has made all of the variables in this class public.
Normally, it is good programming practice to hide the data members that should be
read only by other classes. This is done by making them protected or private and then
creating functions to return references to the variables. Unfortunately, in Java this
increases the size of the compiled bytecode even when the one line function is made
1022 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
final and the code is compiled with optimizations. So to make the applet smaller and
hence faster to download, Robert made the data members public.
The Constructor
The constructor for a BillData object simply initializes the URL and Image variables
with the two parameters passed in. Initializing the pixel array is done in a separate
method, because it is very processor-intensive. This gives the applet a chance to initialize
the pixel array only when it needs it.
initPixels( )
The initPixels( ) method creates the pixel array from the image using the Java core
class: java.awt.image.PixelGrabber.
The Code
Here is the source code for the BillData class:
import java.net.*;
import java.awt.*;
import java.awt.image.*;
public class BillData {
public URL link;
public Image image;
public int[] image_pixels;
public BillData(URL link, Image image) {
this.link = link;
this.image = image;
}
public void initPixels(int image_width, int image_height) {
image_pixels = new int[image_width * image_height];
PixelGrabber pixel_grabber = new
PixelGrabber(image.getSource(), 0, 0,
image_width, image_height, image_pixels, 0, image_width);
try {
pixel_grabber.grabPixels();
}
catch (InterruptedException e) {
image_pixels = null;
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1023
A
P
P
LY
IN
G
JA
V
A
}}
BillTransition.java
The BillTransition class is used as a base class for other transition classes. These other
classes create transition cells between two individual billboard images. This abstract
class contains variables and methods that are common to all transitions.
There are no constructors provided in the BillTransition class. This is because the
applet does not use “new” to create new instances and instead uses the factory method,
java.lang.Class.newInstance( ). Objects created in this way have no way to directly
initialize themselves using parameters in constructors. This factory method indirectly
creates objects using a default constructor, one without any parameters. The
BillTransition class provides a number of overloaded init( ) methods to initialize
instances with parameters.
In previous versions of DynamicBillboard, Robert used static variables within
different transition classes to store data that only needed to be initialized once. It was
discovered, however, that when more than one instance of the applet ran from a web
server, the applets would share the static variables. This led to some problems if one
applet needed a different static value than the other when the applets were different
sizes. An example is the FadeTransition class used to create an array whose size
depended on the dimensions of the applet. When another DynamicBillboard was
created with dimensions that were smaller than the previous applet, it would
overwrite this array with an array too small for the first applet. This would cause the
first applet to crash.
Robert introduced the static hash table called object_table in this version of the
applet to work around this problem. Now transition classes can store data inside this
hash table using the transition name in conjunction with the applet size as a key. When
this data needs to be used, the applet can look to see if it exists for the applet’s size
within the hash table. If it does not, then it can create the data and store it in the hash
table for later use. Now if there is more than one applet on a web server and both are
the same size, then only one has to initialize the data.
init( )
The init( ) method is overloaded three times. The first method, which has three
parameters, is abstract and must be overridden by classes derived from this class. The
other two methods initialize data members within this class. Robert’s intention was to
have the init( ) method of classes that are derived from this class call one of these two
methods to initialize data members of BillTransition.
1024 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
createCellFromWorkPixels( )
The createCellFromWorkPixels( ) method is used to perform the common task of
converting the work_pixels array into an Image object. Notice that it uses the owner
variable to complete this task. This is the only reason the owner variable is needed by
transition classes. When a transition has completed assembly of a new cell in the
work_pixels array, it should call this method.
The Code
Here is the source code for the BillTransition class:
import java.util.*;
import java.awt.*;
import java.awt.image.*;
public abstract class BillTransition {
static Hashtable object_table = new Hashtable(20);
public Image[] cells;
public int delay;
Component owner;
int cell_w;
int cell_h;
int pixels_per_cell;
int[] current_pixels;
int[] next_pixels;
int[] work_pixels;
public abstract void
init(Component owner, int[] current_pixels, int[] next_pixels);
final protected void
init(Component owner, int[] current_pixels, int[] next_pixels,
int number_of_cells, int delay) {
this.delay = delay;
this.next_pixels = next_pixels;
this.current_pixels = current_pixels;
this.owner = owner;
cells = new Image[number_of_cells];
cell_w = owner.getSize().width;
cell_h = owner.getSize().height;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1025
A
P
P
LY
IN
G
JA
V
A
pixels_per_cell = cell_w * cell_h;
work_pixels = new int[pixels_per_cell];
}
final protected void
init(Component owner, int[] current_pixels, int[] next_pixels,
int number_of_cells) {
init(owner, current_pixels, next_pixels, number_of_cells, 120);
}
final void createCellFromWorkPixels(int cell) {
cells[cell] = owner.createImage(
new MemoryImageSource(cell_w, cell_h,
work_pixels, 0, cell_w));
owner.prepareImage(cells[cell], null);
}
}
ColumnTransition.java
The ColumnTransition class changes one image into another by drawing increasingly
large columns of the new image onto the old image. The column sizes increase to the
left, and the same pixels are always drawn on the left side of each column. This makes
the billboard appear to be sliding in from behind the old billboard through vertical
slots in the current billboard.
To create the cells for this transition, the billboard space is split up into a number of
columns, each column 24 pixels wide. Each of the seven image cells the transition will
create will have pixels on the left side of each column from the old image and pixels
on the right side from the new image. The first cell that is created starts out with only
the three right pixels in each column taken from the new image. With each successive
cell, three more pixels are filled in from the new image. The last cell has only the three
left pixels in each column from the old image.
Because the width of the image space is most likely not perfectly divisible by 24,
there will be some remaining pixels remaining on the right side of the image. These
pixels are accounted for in each cell with the rightmost_columns_max_width and
rightmost_columns_x_start variables.
init( )
The init( ) function starts by calling the base class’ init( ) method to initialize the variables
contained within this base class. It goes on to initialize the variables associated with the
rightmost column and then copies all of the pixels from the current billboard into the
work pixels. The loop that follows creates all of the cell frames.
1026 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The nextCell( ) method changes work_pixels, and the method inherited from the
BillTransition class, createCellFromWorkPixels( ), is used to convert these pixels into
an image. Because the process of creating the cells can be very demanding on the CPU,
Robert tells the thread to sleep occasionally to allow other threads to run.
nextCell( )
The nextCell( ) method modifies the work_pixels array for the next cell. It loops
through each line of the image starting from the bottom line and fills part of each
column by copying pixels from the next billboard onto the work_pixels array. It does
not ever need to copy pixels from the old billboard, because these were already copied
to the array in the init( ) method.
It’s worth repeating that the pixel arrays used to form the images are only
one-dimensional. Every width pixel represents one horizontal line of the image.
The Code
Here is the source code for the ColumnTransition class:
import java.awt.*;
import java.awt.image.*;
public class ColumnTransition extends BillTransition {
final static int CELLS = 7;
final static int WIDTH_INCREMENT = 3;
final static int MAX_COLUMN_WIDTH = 24;
int rightmost_columns_max_width;
int rightmost_columns_x_start;
int column_width = WIDTH_INCREMENT;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 200);
rightmost_columns_max_width = cell_w % MAX_COLUMN_WIDTH;
rightmost_columns_x_start = cell_w - rightmost_columns_max_ width;
System.arraycopy(current_pixels, 0,
work_pixels, 0, pixels_per_cell);
for(int c = 0; c < CELLS; ++c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
NextCell();
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1027
A
P
P
LY
IN
G
JA
V
A
try { Thread.sleep(100); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
column_width += WIDTH_INCREMENT;
}
work_pixels = null;
}
void NextCell() {
int old_column_width = MAX_COLUMN_WIDTH - column_width;
for(int p = pixels_per_cell - cell_w; p >= 0; p -= cell_w) {
for (int x = 0; x < rightmost_columns_x_start; x +=
MAX_COLUMN_WIDTH) {
System.arraycopy(next_pixels, x + p, work_pixels,
old_column_width + x + p, column_width);
}
if(old_column_width <= rightmost_columns_max_width) {
System.arraycopy(next_pixels, rightmost_columns_x_start + p,
work_pixels, rightmost_columns_x_start +
old_column_width + p - 1,
rightmost_columns_max_width -
old_column_width + 1);
}
}
}
}
Here is what the column transition looks like before, during, and after:
1028 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
FadeTransition.java
The FadeTransition class changes one image into another by randomly including a
number of new pixels from the next billboard in each successive cell frame. This makes
the next billboard appear to fade in over the old billboard.
The heart of this transition is a two-dimensional array of short integers called
random. This array holds an index for every element in the next billboard’s image pixel
array. These indexes are randomly distributed in the two-dimensional array. The eight
elements in the first dimension of this array will be used when cells are created, one for
each new cell. The last element is never actually used, because there are only seven
cells. It is included when the random array is created to ensure that the indexes are
randomly distributed correctly.
The FadeTransition uses this array to pick pixels from the next billboard to
overwrite pixels of the old billboard. For the first cell, the work_pixels array contains
nothing but pixels from the old billboard. One-eighth of these pixels get changed to
the next billboard’s pixels. For the following cell, the same work_pixels array is used,
and one-eighth more pixels are filled in from the next billboard. For this cell the
result has one-fourth of the pixels from the next billboard, while the remainder are
from the old billboard. This continues until the last cell, cell number seven, which has
seven-eighths of its pixels from the new billboard. Remember, the DynamicBillboard
applet simply uses the whole image from the next billboard after the last cell to
complete the transition.
Because the size of this two-dimensional array is dependent on the size of the
applet, it must be unique to each applet. Using a static variable to store this array is
unacceptable, because applets of different sizes would share this array. Since it is fairly
time-consuming to create this array, it does not make sense to re-create it every time
this transition is to be used.
This is where the superclass’ static variable, object_table, first comes into play.
Once this array is created, it can be stored in this hash table with a key that includes the
size of the applet. When the array needs to be used, the applet can get the appropriate
one out of the hash table. If it does not exist in the hash table, the applet can then create
the array and store it in the hash table for future use. New applets of the same size as
the current applet will benefit from a usable array already being there. This seems like
a lot of effort, but in practice, web sites tend to use this applet on a large number of
pages with a standard layout size for each banner advertisement. So, it saves an
enormous amount of memory and CPU time to cache these tables.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1029
A
P
P
LY
IN
G
JA
V
A
createRandomArray( )
The createRandomArray( ) static method creates the two-dimensional random array.
It takes two parameters that describe the size of the applet. It is highly optimized,
because originally it was too slow. It includes its own random-number generator that is
very fast, but with a short cycle. Because of this, it is fairly complicated and beyond the
scope of this book. The basic idea is that Java’s built-in random-number generator is
better at generating truly random distribution, but it is too slow for this application.
Plus, the user will not notice exactly how random this transition is, so Robert’s
home-grown random-number generator is sufficient.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. Then, like some other transitions, it copies all of the old
billboard’s pixels into the work_pixels array.
The two-dimensional random array is pulled out of the object_table for an applet
of this size. If it does not exist yet, it is created and stored in the object_table. With the
random array in hand, the method just loops through each cell and each index in the
random array, copying pixels from the next billboard into the work pixels.
The Code
Here is the source code for the FadeTransition class:
import java.awt.*;
import java.awt.image.*;
public class FadeTransition extends BillTransition {
private static final int CELLS = 7;
private static final int MULTIPLIER = 0x5D1E2F;
private static short[][] createRandomArray(int number_pixels,
int cell_h) {
int total_cells = CELLS + 1;
int new_pixels_per_cell = number_pixels / total_cells;
short[][] random = new short[total_cells][new_pixels_per_cell];
int random_count[] = new int[total_cells];
for(int s = 0; s < total_cells; ++s) {
random_count[s] = 0;
}
int cell;
int rounded_new_pixels_per_cell =
new_pixels_per_cell * total_cells;
1030 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
int seed = (int)System.currentTimeMillis();
int denominator = 10;
while((new_pixels_per_cell % denominator > 0 ||
cell_h % denominator == 0) && denominator > 1) {
--denominator;
}
int new_randoms_per_cell = new_pixels_per_cell / denominator;
int new_randoms = rounded_new_pixels_per_cell / denominator;
for(int p = 0; p < new_randoms_per_cell; ++p) {
seed *= MULTIPLIER;
cell = (seed >>> 29);
random[cell][random_count[cell]++] = (short)p;
}
seed += 0x5050;
try { Thread.sleep(150); } catch (InterruptedException e) {}
for(int p = new_randoms_per_cell; p < new_randoms; ++p) {
seed *= MULTIPLIER;
cell = (seed >>> 29);
while(random_count[cell] >= new_randoms_per_cell) {
if(++cell >= total_cells) {
cell = 0;
}
}
random[cell][random_count[cell]++] = (short)p;
}
for(int s = 0; s < CELLS; ++s) {
for(int ps = new_randoms_per_cell; ps < new_pixels_per_cell;
ps += new_randoms_per_cell) {
int offset = ps * total_cells;
for(int p = 0; p < new_randoms_per_cell; ++p) {
random[s][ps + p] = (short)(random[s][p] + offset);
}
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1031
A
P
P
LY
IN
G
JA
V
A
try { Thread.sleep(50); } catch (InterruptedException e) {}
}
random[CELLS] = null;
return random;
}
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS);
System.arraycopy(current_pixels, 0, work_pixels,
0, pixels_per_cell);
short random[][] = (short[][])object_table.get(
getClass().getName() + pixels_per_cell);
if(random == null) {
random = createRandomArray(pixels_per_cell, cell_h);
object_table.put(getClass().getName() + pixels_per_cell,
random);
}
for(int c = 0; c < CELLS; ++c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
int limit = random[c].length;
for(int p = 0; p < limit; ++p) {
int pixel_index = random[c][p];
work_pixels[pixel_index] = next_pixels[pixel_index];
}
try { Thread.sleep(50); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
}
work_pixels = null;
}
}
Here is what the fade transition looks like before, during, and after:
1032 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
SmashTransition.java
The SmashTransition class changes one image into another by dropping the new
image onto the old one. The old image appears to crumble under the weight of
the new image.
Two instance variables, drop_amount and location, are used to create the frames.
The location variable keeps track of the pixel that the smashed image starts on. The
drop_amount variable stores the number of pixels of the new image to drop onto the
smashed image every frame. In other words, it is the number to add to the location
variable each frame. A static array called fill_pixels is used to color a whole line of the
work_pixels array white.
The smash effect is done by drawing the old image in an accordion-like fashion.
It starts out by drawing the first lines of the old image offset to the right. Each
progressive line is offset a little bit more to the right. This continues until some
maximum left offset is reached. At this point, the offset is reduced every line until
an offset of zero is reached. This continues until all of the lines of the smashed image
are drawn.
It does not draw the lines from the old image in their entirety. It uses a length that
is a bit shorter than the actual length.
The number of lines to draw for the smashed image decreases each frame as the old
billboard becomes more and more compacted. This transition uses lines that are evenly
distributed across the old image. This ensures that the smashed image does not appear
to be falling off the bottom of the applet or sliding under the new image.
setupFillPixels( )
The setupFillPixels( ) static method is used to ensure that the fill_pixels array is
initialized and is at least as long as one whole line for this applet. If this array has not
been initialized yet or is not long enough for this applet, then this method respectively
re-creates or creates and fills in the array. If there is more than one instance of this
applet running, both can share this fill_pixels array, but it must be at least as long as
the widest applet.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1033
A
P
P
LY
IN
G
JA
V
A
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. It follows this with a call to the method described earlier,
setupFillPixels( ). The initial values of the drop_amount and location variables are then
calculated. After this, the init( ) method goes into a loop to create each frame. It actually
does this in reverse, creating the last frame first. It does not have to be done in reverse.
However, running loops in reverse saves one byte of code in the resulting class file. After
each cell is created, the location variable is incremented to the next proper location.
Smash( )
The Smash( ) method modifies the work_pixels array for the next cell. It creates the
smashed image of the old billboard in the work_pixels array and draws in the pixels
for the new image. This method takes one parameter, max_fold, which is used as the
maximum right offset that the lines in the fold will have. It is also used by subtracting
this from the line width to determine the length of the lines to draw for the folds.
The method begins by copying the pixels from the new image onto work_ pixels.
It then initializes a number of variables that it uses to draw the smashed image. The
drawing of this smashed image is done line by line, in a loop. Within the loop, it first
makes the current line totally white. It then copies a portion of the correct line from
the old billboard over this line. To get the accordion effect, it does not start drawing
onto the same pixel location as it did for drawing the white line. It instead offsets
the destination pixels to the right by a few pixels. After drawing in the line, it adds a
number to the offset counter. It follows this with a bounds check to see if the offset has
gone beyond the minimum or maximum offset. If it has, it flips the sign of the number
it adds to the offset counter each line. The effect of this is that the direction of the offset
is reversed.
The Code
Here is the source code for the SmashTransition class:
import java.awt.*;
import java.awt.image.*;
public class SmashTransition extends BillTransition {
final static int CELLS = 8;
final static float FOLDS = 8.0f;
static int[] fill_pixels;
static void setupFillPixels(int width) {
if(fill_pixels != null && fill_pixels.length <= width) {
return;
1034 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}fill_pixels = new int[width];
for(int f = 0; f < width; ++f) {
fill_pixels[f] = 0xFFFFFFFF;
}
}
int drop_amount;
int location;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 160);
setupFillPixels(cell_w);
drop_amount =  (cell_h / CELLS) * cell_w;
location = pixels_per_cell - ((cell_h / CELLS) / 2) * cell_w;
for(int c = CELLS - 1; c >= 0; --c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
Smash(c + 1);
try { Thread.sleep(150); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
location -= drop_amount;
}
work_pixels = null;
}
void Smash(int max_fold) {
System.arraycopy(next_pixels, pixels_per_cell - location,
work_pixels, 0, location);
int height = cell_h - location / cell_w;
float fold_offset_adder = (float)max_fold * FOLDS / (float)height;
float fold_offset = 0.0f;
int fold_width = cell_w - max_fold;
float src_y_adder = (float)cell_h / (float)height;
float src_y_offset = cell_h - src_y_adder / 2;
for(int p = pixels_per_cell - cell_w; p >= location; p -=
cell_w) {
System.arraycopy(fill_pixels, 0, work_pixels, p, cell_w);
System.arraycopy(current_pixels, (int)src_y_offset * cell_w,
work_pixels, p + (int)fold_offset, fold_width);
src_y_offset -= src_y_adder;
fold_offset += fold_offset_adder;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1035
A
P
P
LY
IN
G
JA
V
A
if(fold_offset < 0.0 || fold_offset >= max_fold) {
fold_offset_adder *= -1.0f;
}
}
}
}
Here is what the smash transition looks like before, during, and after:
TearTransition.java
The TearTransition creates the illusion of the current billboard getting torn off the
applet like a piece of paper. It gets ripped upwards and toward the left to reveal the
next billboard image underneath.
There is only one member variable used in this transition, x_cross. It is used as a
multiplier to create the tear effect. The larger the value of this variable, the smaller the
tear effect will appear to be.
The code for this transition has many optimizations. One optimization of
significance is to create the cell frames in reverse order, building the last cell frame first
and the first, last. In their normal order, each subsequent cell frame reveals a little bit
more of the new image underneath. If the frames were to be created in the normal
order, the tear effect would have to be drawn, along with the new image pixels
revealed in the current frame, which had been covered by the tearing effect in the
previous frame. Doing it in reverse only requires redrawing the tearing effect each cell
1036 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
frame. For example, the last frame, created first, starts out with the tearing effect using
only a small portion of the upper-left corner of the image, while the rest of the pixels
are taken from the new billboard image. In the second to the last frame, which is
created second, the new tear effect draws over a little bit more of the upper-left corner
of the image, while the rest of the image remains the same. The cell frames that follow
draw the new tear effect over more and more of the image, but always covering up the
old tear effect from the last frame.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. It then copies all of the new billboard’s pixels into the
work_pixels array and copies the first line of the old billboard’s pixels onto the first
line of the work_pixels array. After the x_cross variable is initialized, the init( ) method
loops through each cell frame in reverse order. Inside the loop, it creates each cell
frame and decreases the value of the x_cross variable.
Tear( )
The Tear( ) method modifies the work_pixels array for the next cell. It draws the tear
effect onto the work pixels. It draws the tear effect line by line. To draw one line, the
method copies pixels from the old image pixels into the work_pixels array. It uses two
counters, one that is an index into the work_pixels array, the destination, and one that
references an index into the array of pixels for the old billboard, the source. Both
counters are started at zero. The destination counter is always incremented by one.
The source counter, however, is incremented by a floating-point number that is always
greater than one. When the loop is run until the destination index is larger than the
width of the line, the result is the source index growing faster than the destination
index. The overall effect is that in the destination, only a number of pixels on the left
side of the image will be copied from the source. The pixels taken from the source will
skip some pixels, resulting in pixels taken from the source being evenly distributed
across the line.
Each line of the cell frame will use a larger value for the floating-point number on
the line above. This makes lines toward the bottom draw on fewer pixels for the tear
effect than lines toward the top.
This method has one big optimization that it uses to get around the slow array
indexing in Java. Whenever a element in an array is used, bounds checking is done
to ensure that the index is within the bounds of the array. There is a performance hit
involved in this bounds checking. The standard Java class, System, provides a method
that allows you to copy sections of arrays from one array to another almost as fast or as
fast as copying one array element into another. This method is used to speed up the
creation lines within the cell frames. It only uses this method when the applet knows
some of the source pixels will be adjacent to one another. If the applet skips at least
every other pixel from the source image, then it will use the standard loop method.
An x_increment value less than 0.5 indicates that less than 1.5 will be added to the
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1037
A
P
P
LY
IN
G
JA
V
A
source index counter each time, and there will be a speed benefit from using the array
copy method for a particular line.
The Code
Here is the source code for the TearTransition class:
import java.awt.*;
import java.awt.image.*;
public class TearTransition extends BillTransition {
static final int CELLS = 7;
static final float INITIAL_X_CROSS = 1.6f;
static final float X_CROSS_DIVISOR = 3.5f;
float x_cross;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS);
System.arraycopy(next_pixels, 0, work_pixels, 0,
pixels_per_cell);
System.arraycopy(current_pixels, 0, work_pixels, 0, cell_w);
x_cross = INITIAL_X_CROSS;
for(int c = CELLS - 1; c >= 0; --c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
Tear();
try { Thread.sleep(150); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
x_cross /= X_CROSS_DIVISOR;
}
work_pixels = null;
}
final void Tear() {
float x_increment;
int p, height_adder;
p = height_adder = cell_w;
for (int y = 1; y < cell_h; ++y) {
x_increment = x_cross * y;
if(x_increment >= 0.50f) {
float fx = 0.0f;
1038 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
x_increment += 1.0f;
int x = 0;
do {
work_pixels[p++] = current_pixels[height_adder + x];
x = (int)(fx += x_increment);
} while(x < cell_w);
}
else {
float overflow = 1.0f / x_increment;
float dst_end = overflow / 2.0f  + 1.49999999f;
int dst_start = 0, src_offset = 0, length = (int)dst_end;
while(dst_start + src_offset + length < cell_w) {
System.arraycopy(current_pixels, p + src_offset,
work_pixels, p, length);
++src_offset;
dst_end += overflow;
p += length;
dst_start += length;
length = (int)dst_end - dst_start;
}
length = cell_w - src_offset - dst_start;
System.arraycopy(current_pixels, p + src_offset,
work_pixels, p, length);
}
p = height_adder += cell_w;
}
}
}
Here is what the tear transition looks like before, during, and after:
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1039
A
P
P
LY
IN
G
JA
V
A
UnrollTransition.java
UnrollTransition makes it appear as if a rolled-up poster is placed on the bottom of the
applet and then unrolled upward, gradually revealing the next image and covering
the old image. To enhance the unroll illusion, the roll gradually decreases in size as it
makes its way upward on the billboard.
Two instance variables are used during the creation of unroll transitions. The
location variable references pixels within the pixel arrays. It stores the current pixel
that the roll first appears on. The unroll_amount array variable tells the class how
many vertical pixels the roll should move upward each frame.
The most difficult part of creating each cell frame is drawing the roll. The only
other task that needs to be completed each frame is to draw the pixels from the new
image onto the space vacated by the roll from the previous frame.
The roll is drawn with scan lines from the new image. The first line of the roll is
drawn with the scan line located at the Y coordinate above the roll’s Y coordinate on
the applet. For example, if the roll is located on line ten for a particular cell frame,
then line nine of the new image will be used to draw the first line of the roll. Each
subsequent line of the roll is drawn using a line from the image located above the
previous line of the new image. So, continuing the example, the second line of the roll
will be drawn using line eight of the new image.
The roll is painted with its 3-D appearance by drawing each line of the roll with a
slight offset to the left. Lines closer to the center of the roll are drawn with a larger
offset than lines close to the top and bottom. The top and bottom lines of the rolls are
then shaded to make it look as if a light were above the applet. This results in the top
line being a bit brighter than the rest of the roll and the bottom line being a bit darker.
createUnrollAmountArray( )
Each consecutive cell frame in this transition unrolls the roll onto the applet a little
bit less than the previous cell frame. The createUnrollAmountArray( ) static method
is used to calculate an array that indicates how much each cell frame should unroll
the roll.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. Then the location variable is initialized to an index past the
last pixel in a pixel array. This is followed by copying all of the old billboard’s pixels
into the work_pixels array.
1040 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
An array that stores the number of pixels to unroll each frame is pulled out of the
object_table for an applet of this height. If it does not exist in the hash table, it is
created and stored in the object_table.
Then the init( ) method loops through each cell, moving the roll upward by
subtracting from the location variable and drawing each cell frame. It makes the
current thread take a break before and after the processor-intensive cell frame
creation, to allow other threads in Java’s multitasking environment to execute.
After the cell frame is created from the work_pixels array with the call to the
createCellFromWorkPixels( ) method, the area the roll was on is drawn over with
pixels from the new image. This prepares the work_pixels array for the next cell frame.
Unroll( )
The Unroll( ) method modifies the work_pixels array for the next cell. It draws the roll
onto the work pixels. This method first calculates the offset that it needs to use for
drawing each line of the roll. It then loops through each line of the roll, copying scan
lines from the new image onto the work_pixels array. The pixels that are exposed due
to the left offset of each line are filled in with pixels from the static fill_pixels array.
Another loop then increments though each pixel on the top and the bottom lines of
the roll, brightening pixels on the top line and darkening pixels on the bottom line.
The Code
Here is the source code for the UnrollTransition class:
import java.awt.*;
import java.awt.image.*;
public class UnrollTransition extends BillTransition {
final static int CELLS = 9;
static int fill_pixels[] = { 0xFFFFFFFF, 0xFF000000,
0xFF000000, 0xFFFFFFFF };
private static int[] createUnrollAmountArray(int cell_h) {
float unroll_increment =
((float)cell_h / (float)(CELLS + 1)) /
((float)(CELLS + 2) / 2.0f);
int total = 0;
int unroll_amount[] = new int[CELLS + 1];
for(int u = 0; u <= CELLS; ++u) {
unroll_amount[u] = (int)(unroll_increment * (CELLS - u + 1));
total += unroll_amount[u];
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1041
A
P
P
LY
IN
G
JA
V
A
if(total < 0) {
unroll_amount[0] -= 1;
}
return unroll_amount;
}
int location;
int[] unroll_amount;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 220);
location = pixels_per_cell;
System.arraycopy(current_pixels, 0,
work_pixels, 0, pixels_per_cell);
unroll_amount = (int[])object_table.get(getClass().getName() +
cell_h);
if(unroll_amount == null) {
unroll_amount = createUnrollAmountArray(cell_h);
object_table.put(getClass().getName() + cell_h, unroll_amount);
}
for(int c = 0; c < CELLS; ++c) {
location -= unroll_amount[c] * cell_w;
try { Thread.sleep(150); } catch (InterruptedException e) {}
Unroll(c);
try { Thread.sleep(100); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
System.arraycopy(next_pixels, location,
work_pixels, location,
unroll_amount[c] * cell_w);
}
work_pixels = null;
}
void Unroll(int c) {
int y_flip = cell_w;
int offset[] = new int[unroll_amount[c]];
for(int o = 0; o < unroll_amount[c]; ++o) {
offset[o] = 4;
}
offset[0] = 2;
1042 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
if(unroll_amount[c] > 1) {
offset[1] = 3;
}
if(unroll_amount[c] > 2) {
offset[unroll_amount[c] - 1] = 2;
}
if(unroll_amount[c] > 3) {
offset[unroll_amount[c] - 2] = 3;
}
int offset_index = 0;
int end_location = location + unroll_amount[c] * cell_w;
for(int p = location; p < end_location; p += cell_w) {
System.arraycopy(next_pixels,
p - y_flip + offset[offset_index],
work_pixels,
p, cell_w - offset[offset_index]);
System.arraycopy(fill_pixels, 0,
work_pixels,
p + cell_w - offset[offset_index],
offset[offset_index]);
++offset_index;
y_flip += cell_w + cell_w;
}
for(int x = location + cell_w - 1; x > location; --x) {
work_pixels[x] |= 0xFFAAAAAA;
work_pixels[x + unroll_amount[c]] &= 0xFF555555;
}
}
}
Here is what the unroll transition looks like before, during, and after:
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1043
A
P
P
LY
IN
G
JA
V
A
Dynamic Code
Robert has shown us how to create interactive high-performance graphics by
working around many of the apparent limitations in Java. He shows how to use
System.arraycopy( ) to effectively shuffle pixel data around. He shows how to properly
use cooperative multithreading to do computation and network transfers in the
background while the user isn’t waiting. Robert proves that high-performance direct
pixel manipulation algorithms can be efficiently written in Java if you are careful.
In addition to containing interesting code, DynamicBillboard is a very compelling
applet for nonprogrammers and users alike. It is easily configured by HTML editors,
extensible by Java programmers, and entertaining to web users. In this age of
advertising rates being driven by “click-through,” where advertisers only want to pay
for transfers from a content site to their site, Robert’s applet can be used to increase
traffic and ultimately increase revenue.
1044 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1045
A
P
P
LY
IN
G
JA
V
A
1046 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Chapter 30
ImageMenu: An
Image-Based Web Menu
1047
The ImageMenu applet is a simple program that presents an image-based menuwith an arbitrary number of choices in a vertical list. When the user moves themouse cursor over these choices, the one under the cursor changes appearance,
indicating that it can be clicked on. When the user clicks on a choice, the web browser
changes to a new document specified for that choice. ImageMenu was created by
David LaVallée, the creator of several interesting applets. Figure 30-1 shows an
instance of ImageMenu.
ImageMenu uses the showDocument( ) function in AppletContext to make the
hypertext leap to the new pages. The novelty of ImageMenu is that it uses different
portions of a single source image to draw the menu on the screen. Basing a menu on
an image rather than on text frees you to design menus that use any font or image you
desire. You can also provide various types of selection feedback. You no longer need to
rely on the AWT’s limited rendering functions.
1048 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 30-1. An example of ImageMenu
The ImageMenu applet was inspired by an applet called Navigation, created by
top-notch Java programmer Sean Welch. The difference between Navigation and
ImageMenu is efficiency in bandwidth and applet tag specification. The Navigation
applet uses a source image that is the applet’s width times the number of possible
selections wide to display all of its states. Both applets download a single image, which
is much more efficient over the Internet than loading multiple files. A menu of seven
choices for the Navigation applet (100×140 pixels) would require a source image of
700×140. The applet described here, ImageMenu, uses a source image that is two times
the applet width, or 200×140. Most web designers hate typing when they don’t have to,
which leads to the second significant difference between Navigation and ImageMenu:
abbreviated applet parameters.
While ImageMenu is many times more efficient, using a smaller source image and
fewer bytes of parameters, Welch’s Navigation has one inimitable trait—it can display
individually selected “states” that bleed over into the space of the next menu item. The
ImageMenu applet requires that each menu item be self-contained in a rectangular area
that cannot overlap with adjacent items. This would prohibit, for example, ascending
letters (like h) from overlapping descending letters (such as j) in the line above.
The Source Image
While you won’t see the code for Navigation here, looking at its GIF image shows clearly
what it does. The source image for Navigation in Figure 30-2 shows seven columns,
each of which provides a visual representation of a possible selection. However, each
selectable item only has two states, so each row has five redundant copies of the
unselected state.
The source image for ImageMenu is shown in Figure 30-3. Given this image, it is
simple to render any of the seven possible states of a six-choice menu. First, drawImage( )
displays the left half of the source image. This is the state where no items are selected.
If any of the items is selected, then the clipping rectangle is simply set to the bounds of
the selected item, and drawImage( ) is used to display the right-hand side. This will
paint just the selected cell through the clipping rectangle.
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1049
A
P
P
LY
IN
G
JA
V
A
Figure 30-2. The source image for the Navigation applet
The APPLET Tag
The APPLET tag for ImageMenu contains many pieces of information. We will
use java.util.StringTokenizer to read the urlList and the frame targetList parameters
whose values are plus sign–delimited lists of values. We’ll also infer the coordinates of
each menu item by dividing the height of the applet by the number of URLs parsed in
urlList. For readability in the APPLET tag, we also allow a prefix and suffix, which will
be concatenated with a URL when it’s time to move to a new page.
<applet code="ImageMenu" width=140 height=180 hspace=0 vspace=0>
<param name="img" value="menu.jpg">
<param name="urlPrefix"
value="http://www.osborne.com/">
<param name="urlList"
value="pressroom/pressroom.shtml+aboutus/aboutus.shtml+
1050 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 30-3. The source image for ImageMenu
downloads/downloads.shtml+errata/errata.shtml">
<param name="targetList"
value="_self+_self+_self+_self+_self+_self">
<param name="urlSuffix" value="">
</applet>
The Methods
This is a small applet—about 100 lines of Java source. We will walk through all eight
methods here and then show all the source together at the end of the chapter.
init( )
When the applet is being initialized, init( ) saves the size in the Dimension variable d
and parses the applet param tags. It then uses a StringTokenizer to parse strings delimited
by the plus sign to create the string arrays url and target. The number of URLs that are
parsed is the number that is used to divide the vertical space into menu cells. From this
calculation, init( ) saves the number and height of the cells in cells and cellH, respectively.
update( )
We nullify the update( ) method of Applet to avoid flashing. As mentioned in Chapter 23,
the update( ) method in the Applet superclass fills a rectangle with the background color
before calling paint( ). Since we’re not going to use repaint( ), we can just eliminate
update completely.
lateInit( )
The lateInit( ) private method creates the offscreen Image object that will be used for
double buffering the display of the menu. This method also employs a MediaTracker
object to synchronously get the source image.
paint( )
The paint( ) method is quite simple. First, it checks to see if the offscreen buffer has been
created yet. If it hasn’t, lateInit( ) is called to create the buffer and load the menu image.
After that, it draws the left half of the image on the offscreen buffer. This requires,
of course, that the menu image be twice the width of the applet. That way, the applet
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1051
A
P
P
LY
IN
G
JA
V
A
will simply clip away the right half of the menu image when drawImage(img, 0, 0,
null) is called. Then, if any cell is selected (selectedCell >= 0), it sets the clip rectangle
to the bounds of that menu item. You’ll notice that paint( ) gets the graphics context of
the offscreen image every time. This has the effect of resetting the clipping rectangle to
the bounds of the image. AWT’s lack of a resetClip( ) method requires some strange
coding style.
Next, the entire image is painted again, but this time, it is offset by the width of the
applet to the left, via drawImage(img, -d.width, 0, null). This has the effect of placing
just the right highlighted menu item in the clip rectangle. Lastly, the offscreen buffer is
copied to the applet window.
The speed of most graphic displays is largely throttled by the speed of the CPU’s
access directly to the screen. Additionally, many modern display cards are optimized for
copying rectangular areas from memory to the display in support of windowing systems.
Therefore, you are much better off doing all your drawing on an offscreen buffer rather
than copying the bits to the screen. On similar PC systems, we have seen between 10
and 400 buffer changes a second, depending on pixel depth and display card architecture.
mouseExited( )
Special handling is needed for mouseExited( ), because it causes all of the menu items
to be unselected. All we have to do is set selectedCell and oldCell to –1, which makes
the subsequent paint( ) call show all the items as unselected. Having oldCell set to –1
means that the next time the mouse enters the applet and causes a mouseMoved( ) call,
the first item will paint properly.
mouseDragged( )
The mouseDragged( ) method is called when the mouse moves with any of its buttons
pressed. In this applet, we want to do the same thing on drag or move, so we just call
mouseMoved( ) directly, passing in the same parameters we received.
mouseMoved( )
Whenever the mouse moves, mouseMoved( ) checks the y coordinate to see which of the
cells was selected. If the selectedCell is different from oldCell, meaning the user moved
from one cell to another, the menu is repainted. This is an optimization that avoids the
constant repainting of identical screen bits every time the mouse moves. You will notice
that repaint( ) is not called here. We are taking a shortcut through the normal applet
protocol by calling paint( ) directly after fetching the Graphics context from
1052 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
getGraphics( ). This makes for a much snappier response. After the menu is painted,
the status line is set to reflect the newly selected item, which is also saved in oldCell.
mouseReleased( )
mouseReleased( ) sends the browser to the URL that corresponds to the currently selected
menu item. The desired URL is then constructed. If the URL was improperly formatted
in the APPLET tag, the exception is displayed on the status line and returned without
attempting to switch documents. The showDocument( ) method puts the document
described in the URL into the frame listed in the target array. As a final feature, the
state of this SHIFT key is checked by calling the isShiftDown( ) method of MouseEvent.
If SHIFT was pressed, the URL is opened into a new blank browser window instead of
the one specified in target.
The Code
The source code for ImageMenu is shown here:
import java.awt.* ;
import java.awt.event.*;
import java.applet.*;
import java.util.*;
import java.net.*;
public class ImageMenu extends Applet {
Dimension d;
Image img, off;
Graphics offg;
int MAXITEMS = 64;
String url[] = new String[MAXITEMS];
String target[] = new String[MAXITEMS];
String urlPrefix, urlSuffix;
int selectedCell = -1;
int oldCell = -1;
int cellH;
int cells;
public void init() {
d = getSize();
urlPrefix = getParameter("urlPrefix");
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1053
A
P
P
LY
IN
G
JA
V
A
urlSuffix = getParameter("urlSuffix");
StringTokenizer st;
st = new StringTokenizer(getParameter("urlList"), "+");
int i=0;
while(st.hasMoreTokens() && i < MAXITEMS)
url[i++] = st.nextToken();
cells = i;
cellH = d.height/cells;
st = new StringTokenizer(getParameter("targetList"), "+");
i=0;
while(st.hasMoreTokens() && i < MAXITEMS)
target[i++] = st.nextToken();
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
private void lateInit() {
off = createImage(d.width, d.height);
try {
img = getImage(getDocumentBase(), getParameter("img"));
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
} catch(Exception e) {
showStatus("error: " + e);
}
}
public void update(Graphics g) {}
public void paint(Graphics g) {
if(off == null)
lateInit();
offg = off.getGraphics();
offg.drawImage(img, 0, 0, this);
if (selectedCell >= 0) {
offg.clipRect(0, selectedCell * cellH, d.width, cellH)
offg.drawImage(img, -d.width, 0, this);
}
1054 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
g.drawImage(off, 0, 0, this);
}
class MyMouseMotionAdapter extends MouseMotionAdapter {
public void mouseDragged(MouseEvent me) {
mouseMoved(me);
}
public void mouseMoved(MouseEvent me) {
int y = me.getY();
selectedCell = (int)(y/(double)d.height*cells);
if (selectedCell != oldCell) {
paint(getGraphics());
showStatus(urlPrefix + url[selectedCell] + urlSuffix);
oldCell = selectedCell;
}
}
}
class MyMouseAdapter extends MouseAdapter {
public void mouseExited(MouseEvent me) {
selectedCell = oldCell = -1;
paint(getGraphics());
showStatus("");
}
public void mouseReleased(MouseEvent me) {
URL u = null;
try {
u = new URL(urlPrefix + url[selectedCell] + urlSuffix);
} catch(Exception e) {
showStatus("error: " + e);
}
if (me.isShiftDown())
getAppletContext().showDocument(u, "_blank");
else
getAppletContext().showDocument(u, target[selectedCell]);
}
}
}
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1055
A
P
P
LY
IN
G
JA
V
A
Summary
In use, the ImageMenu applet can look great and it provides a lot of leverage for a very
small program. Use of the showDocument(URL u, String target) in this applet allows
for a subtle optimization in web page design. If you put an ImageMenu applet in a
frame in an HTML frameset and use it to send documents to a second frame, the applet
never has to be reloaded, which makes the user’s experience better.
1056 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Chapter 31
The Lavatron Applet:
A Sports Arena Display
1057
Lavatron is a sports arena lightbulb display. Normally, an applet doesn’thave much of a history, but this one does. David LaVallée, the author of theImageMenu applet from Chapter 30, wanted to achieve this kind of effect for a
long time. The history of Lavatron begins way back in 1974, when LaVallée was the
stick boy for the California Golden Seals of the NHL. David recalls, “Our scoreboard
just displayed, well, the score. The game was the thing; there wasn’t much to distract
hockey fans other than the dah-dah-dah-dat-dah-dah of the organ player.”
In 1979, LaVallée became fascinated with the idea of a graphical programmable
scoreboard when he was the repair guy for the Digital Equipment Corporation PDP
11/34 that ran the scoreboard at the Canadian National Exhibition Stadium (where
the Toronto Blue Jays used to play). That scoreboard was based on plain old 100-watt
lightbulbs like you use at home. In 1991, Toronto was treated to the Sony Jumbotron
HDTV scoreboard at the Skydome: true color, images, video, and three times the height
of the Hard Rock Cafe. In 1992, LaVallée wrote the first version of Lavatron in Objective-
C and PostScript. Finally, in 1995, Lavatron was written again from scratch to run under
Java, and it has undergone several performance tweaks and iterations since. The version
shown here has been updated for Java 2.
There are many possible enhancements to Lavatron (see Figure 31-1) that you
might want to try, such as drawing the source image dynamically in memory rather
than downloading it, or scrolling an animated sequence. But it’s an interesting
animated display applet that you may find useful as is.
1058 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 31-1. The Lavatron applet in action. The source image contains a bitmap
of the title Java 2: The Complete Reference on a white background.
How Lavatron Works
Lavatron is able to present an interesting image onscreen because of a small trick that it
employs, and its side effect allows the applet to load very quickly. The reason it loads
so quickly is that there isn’t much data transmitted over the Net. The source image is a
JPEG image that is 64 times smaller than the displayed image. Each pixel in the source
image is scaled up to an 8×8-pixel square. Here is the trick that Lavatron uses to
produce the lightbulb effect. An 8×8-pixel image of a transparent circle surrounded by
a black bezel, with a white highlight for a dash of style, is painted over the scaled-up
color pixel. As an optimization, the bulbs are preassembled into an image that can be
painted once for each column. Figure 31-2 shows what the bulb mask looks like blown
up. The two white pixels are the highlight. The black pixels in the corner are opaque.
Finally, all of the gray pixels in the middle are transparent, to allow the lightbulb color
to show through.
Lavatron paints so fast because it doesn’t have to repaint what it has already drawn.
The technique of copying the area of the screen that’s good and painting just the portion
that’s new is used in many common operations involving scrolling. The awt.Graphics
function copyArea( ) takes a portion of an image defined by a rectangle and moves it
by an x,y offset from its starting location. As a graphics speed optimization, copyArea( )
is hard to beat. It consistently outperforms any other technique of image rendering,
such as the use of drawImage( ), or drawImage( ) through a clipRect( ). Building an
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1059
A
P
P
LY
IN
G
JA
V
A
Figure 31-2. A blown-up light bulb image
image much larger than your applet, which has several source images concatenated
into a single image, and then using copyArea to move them into place and clipping the
result onscreen is a very fast Java rendering technique.
The Source Code
Lavatron starts by initializing data, which includes loading the source image and
creating the column of bulb images. The last stage of the initialization is painting the
offscreen (double buffer) image full of dimmed (black) lightbulbs to start the display
with a clean image. Subsequent painting of the offscreen image begins by using
copyArea( ) to move the existing portion of the image to the left by the width of the
column of bulbs about to be added on the right edge. Then the pixel values for the next
column are read and used as the color to fill a column of 8×8 rectangles at the right
edge of the applet. The transparent column of bulbs is painted, and then the whole
backing image is drawn to the screen. Since this applet doesn’t have to do much except
scroll the image, it avoids the normal repaint( ) loop by forking a thread that repeatedly
calls paint( ), pausing only to call yield( ) to allow other threads to run.
The APPLET Tag
The source code starts with the APPLET tag for Lavatron, shown here. This applet
looks best when the width is an even multiple of the bulb size and the height is the
bulb size times the source image height. The only parameter is for the name of the
source image file, named in img.
<applet code=Lavatron.class width=560 height=128>
<param name="img" value="swsm.jpg">
</applet>
Lavatron.java
The main applet is small, about 100 lines of Java source code. However, there is also
a support class that is required, which is described in the next section.
init( )
The init( ) method first determines the size of the applet by using getSize( ), and then
rounds up the size to a multiple of the bulb size, specified by bulbS, and stores it in
offw,offh. It then creates an image that size, called offscreen, for use as a double
buffer for the display. The Graphics object used for drawing on offscreen is saved
in offGraphics. The size of the applet, in bulb units rather than pixels, is stored in
bulbsW,bulbsH.
Next, the image of a column of bulbs is created by calling createBulbs( ), passing in
the size of the image to create. Then the image named in the img applet parameter is
1060 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
loaded. This is done by passing the result of getImage( ) to MediaTracker’s addImage( )
method, and then calling waitForID( ), which waits until the image is fully loaded
before returning.
To draw the blown-up version of this image, init( ) needs to retrieve the color
information for each pixel in the image. First, it obtains the size of the image, using
getWidth( ) and getHeight( ), saving the width in pixscan. It then assigns pixels to a
new array of pixscan * h integers. Then a PixelGrabber is created. When grabPixels( )
is called, the array is filled in with the color values.
The final step of init( ) is to paint black bulbs on the offscreen image, which makes
the effect more dramatic as the image scrolls from the right side revealing lighted bulbs.
createBulbs( )
The createBulbs( ) method is a helper to init( ). It returns an Image of a stack of bulb
images that can be used to mask out a column of colored squares to make them look
like lit lightbulbs. It is a little tricky, but quite elegant.
First, it allocates the right number of ints in an array to store the pixels. Then, it
declares another array, which is a picture of a single bulb, represented by the numbers
0, 1, and 2. The 0s represent black, the 1s transparent pixels, and the 2s represent the
white highlight. Next, a short array is declared—bulbCLUT (bulb Color Look Up Table).
This maps the 0, 1, and 2 just mentioned into full 32-bit pixel values. The 0xff000000 is
opaque black. The high-order byte is alpha, or transparency. The 0x00c0c0c0 is a fully
transparent light gray, and the 0xffffffff is opaque white.
The for loop runs through each pixel, loading the appropriate 0, 1, or 2 from bulbBits
based on the position in the column. This is achieved by use of the mod (%) operator.
This value is then used to look up the color from bulbCLUT. Given this array of pixels,
createBulbs( ) returns the output of createImage( ), passing in a MemoryImageSource
object prepared with the pixels we just constructed.
color( )
The color( ) method returns the color of the pixel at the x,y position in the source image
as a Color object. Since this applet runs continuously, we decided not to simply create
a new Color object each time a single bulb was painted. This would be abusive of the
garbage-collected heap. Instead, unique Color objects are stored in a hash table. The
maximum number of Color objects in the hash table can be as much as the width times
the height of the source image, but in practice, it is usually much less.
update( )
Lavatron overrides update( ) to do nothing, because we don’t want AWT’s implementation
to cause flicker.
paint( )
The paint( ) method is quite simple. The first step calls copyArea( ) to move all of the
columns to the left by one column’s width. Then a for loop is used to fill the rightmost
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1061
A
P
P
LY
IN
G
JA
V
A
column with rectangles in the Color of the appropriate pixel, using color( ). The bulb
image strip is then painted over the new column. Then the current scrolled position,
scrollX, is updated to be one more to the right, modulo the width, pixscan.
start( ), stop( ), and run( )
When the applet starts, it creates and starts a new Thread called t. This thread will call
run( ), which will keep calling paint( ) as fast as possible, while maintaining the courtesy
of calling yield( ) so that other threads can run. When the applet stop( ) method is
called, stopFlag is set to true. This variable is checked by the infinite loop in the run( )
method. Program control breaks from the loop when stopFlag is true.
A useful enhancement would be to introduce a threshold frame rate, say 30 fps (frames
per second), and change the call to the yield( ) into an appropriate call to sleep( ) if the
rendering is too fast.
The Code
Here is the source code for the Lavatron class:
import java.applet.*;
import java.awt.* ;
import java.awt.image.* ;
public class Lavatron extends Applet implements Runnable {
int scrollX;
int bulbsW, bulbsH;
int bulbS = 8;
Dimension d;
Image offscreen, bulb, img;
Graphics offgraphics;
int pixels[];
int pixscan;
IntHash clut = new IntHash();
boolean stopFlag;
public void init() {
d = getSize();
int offw = (int) Math.ceil(d.width/bulbS) * bulbS;
int offh = (int) Math.ceil(d.height/bulbS) * bulbS;
offscreen = createImage(offw, offh);
offgraphics = offscreen.getGraphics();
bulbsW = offw/bulbS;
bulbsH = offh/bulbS;
1062 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
bulb = createBulbs(bulbS, bulbsH*bulbS);
try {
img = getImage(getDocumentBase(), getParameter("img"));
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
pixscan = img.getWidth(null);
int h = img.getHeight(null);
pixels = new int[pixscan * h];
PixelGrabber pg = new PixelGrabber(img, 0, 0, pixscan, h,
pixels, 0, pixscan);
pg.grabPixels();
} catch (InterruptedException e) { };
scrollX = 0;
// paint black bulbs on the offscreen image
offgraphics.setColor(Color.black);
offgraphics.fillRect(0, 0, d.width, d.height);
for (int x=0; x<bulbsW; x++)
offgraphics.drawImage(bulb, x*bulbS, 0, null);
}
Image createBulbs(int w, int h) {
int pixels[] = new int[w*h];
int bulbBits[] = {
0,0,1,1,1,1,0,0,
0,1,2,1,1,1,1,0,
1,2,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
0,1,1,1,1,1,1,0,
0,0,1,1,1,1,0,0
};
int bulbCLUT[] = { 0xff000000, 0x00c0c0c0, 0xffffffff };
for (int i=0; i<w*h; i++)
pixels[i] = bulbCLUT[bulbBits[i%bulbBits.length]];
return createImage(new MemoryImageSource(w, h, pixels, 0, w));
}
public final Color color(int x, int y) {
int p = pixels[y*pixscan+x];
Color c;
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1063
A
P
P
LY
IN
G
JA
V
A
if ((c=(Color)clut.get(p)) == null)
clut.put(p, c = new Color(p));
return c;
}
public void update() {}
public void paint(Graphics g) {
offgraphics.copyArea(bulbS, 0, bulbsW*bulbS-bulbS, d.height,
-bulbS, 0);
for (int y=0; y<bulbsH; y++) {
offgraphics.setColor(color(scrollX, y));
offgraphics.fillRect(d.width-bulbS, y*bulbS, bulbS, bulbS);
}
offgraphics.drawImage(bulb, d.width-bulbS, 0, null);
g.drawImage(offscreen, 0, 0, null);
scrollX = (scrollX + 1) % pixscan;
}
Thread t;
public void run() {
while (true) {
paint(getGraphics());
try{t.yield();} catch(Exception e) { };
if(stopFlag)
break;
}
}
public void start() {
t = new Thread(this);
t.setPriority(Thread.MIN_PRIORITY);
stopFlag = false;
t.start();
}
public void stop() {
stopFlag = true;
}
}
1064 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
IntHash( )
As mentioned in the preceding section, Color objects are stored in a hash table rather
than creating the same ones over and over. As a further optimization, we created our
own version of Java’s Hashtable class, which uses normal ints as keys rather than
requiring an Object handle.
Integer data needs much less room to store in the pixel array than Color objects,
so we use a hash table as a mechanism to look up Color objects from the integer value
of any individual pixel. Creating Color objects on the fly from the integer value of
each pixel is very expensive, because it creates a lot of memory garbage that must be
collected. One possible solution would be to use a Java Hashtable, except that doing so
would create just as much garbage, since only objects can be used as keys in a standard
Java hash table. Thus, to store an int in Java’s hash table, you would have to create a
new Integer object as a key to be matched. In a high duty cycle applet like Lavatron,
garbage Integer objects would be created by the thousands per second. This is not a
good solution.
The proper solution was to build our own hash table, IntHash, which uses the
integer data type values rather than the Integer object for its keys. IntHash is about 60
lines of code. The IntHash class duplicates the interface of the java.util.Hashtable class
with the exception that the type of the argument to put( ) and get( ) is an int data type
rather than an Object. There’s no need to explain how a hash table works in this
chapter, but suffice it to say that put(42, “Hello”) == get(42).
The Code
Here is the source code for the IntHash class:
class IntHash {
private int capacity;
private int size;
private float load = 0.7F;
private int keys[];
private Object vals[];
public IntHash(int n) {
capacity = n;
size = 0;
keys = new int[n];
vals = new Object[n];
}
public IntHash() {
this(101);
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1065
A
P
P
LY
IN
G
JA
V
A
}private void rehash() {
int newcapacity = capacity * 2 + 1;
Object newvals[] = new Object[newcapacity];
int newkeys[] = new int[newcapacity];
for (int i = 0; i < capacity; i++) {
Object o = vals[i];
if (o != null) {
int k = keys[i];
int newi = (k & 0x7fffffff) % newcapacity;
while (newvals[newi] != null)
newi = (newi + 1) % newcapacity;
newkeys[newi] = k;
newvals[newi] = o;
}
}
capacity = newcapacity;
keys = newkeys;
vals = newvals;
}
public void put(int k, Object o) {
int i = (k & 0x7fffffff) % capacity;
while (vals[i] != null && k != keys[i]) // hash collision.
i = (i + 1) % capacity;
if (vals[i] == null)
size++;
keys[i] = k;
vals[i] = o;
if (size > (int)(capacity * load))
rehash();
}
public final Object get(int k) {
int i = (k & 0x7fffffff) % capacity;
while (vals[i] != null && k != keys[i]) // hash miss
i = (i + 1) % capacity;
return vals[i];
}
1066 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public final boolean contains(int k) {
return get(k)!=null;
}
public int size() {
return size;
}
public int capacity() {
return capacity;
}
}
Hot Lava
This applet is another small example of the kind of amazing performance you can
squeeze out of Java if you are careful and diligent. David LaVallée uses many tricks
to avoid excessive memory allocation and unnecessary calls to AWT drawing
functions. Creating the lightbulb mask image from a small array of integers rather
than a loaded GIF image saves download time and increases flexibility. The use of
paint(getGraphics( )) rather than repaint( ) increases frame rate significantly. The
performance gains from using copyArea( ) over rerendering the image or calling
drawImage( ) are profound. Finally, the creation and use of IntHash makes for that
last performance boost by not forcing the system to garbage-collect as often.
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1067
A
P
P
LY
IN
G
JA
V
A
This page intentionally left blank.
Chapter 32
Scrabblet: A Multiplayer
Word Game
1069
Scrabblet is a complete multiplayer, networked, client/server game. It is the mostcomplicated applet in this book, and it handles some of the thorniest issues in Javaprogramming. Scrabblet consists of more than 1,400 lines of code in 11 classes.
Two of these classes are part of the server side of the applet. The other nine are
downloaded to a web browser and act as the simulation of the game. All of the code
elements used in the game have been described in detail in this book. In this chapter,
we will dissect each class and show how easy it is to build a multiplayer game.
Network Security Concerns
Most applets on the Net today don’t do much with the network after they have
been downloaded. One of the reasons is that networking has been made more difficult
in Java out of security concerns. Most Java applet environments, such as Netscape
Navigator and Microsoft Internet Explorer, severely restrict an applet’s use of the
network. This situation is created by TCP/IP’s lack of authentication in its most basic
protocols. This inherent limitation of the Internet is managed carefully by corporations
that want to protect their proprietary data through the use of firewalls. A firewall is a
computer that sits between a private network and the rest of the Internet. All Internet
connections flow through it, and it is able to filter and reject connections and packets,
both incoming and outgoing. This way, if a program on the outside of the firewall
attempts to attach to an internal network port, the firewall can block it. If it weren’t for
the firewall, system administrators would have to audit the security of each machine
on their internal network. In the case of a firewall-protected network, only the firewall
needs to be secure, and every machine inside is considered “friendly” and left
unprotected from every other machine inside.
This is where Java could have posed a security threat. If Java-enabled browsers
allowed applets to connect to arbitrary Internet addresses, then an applet could act as
a proxy to some malicious program on the outside of the firewall. Once an applet had
been downloaded and automatically run by the web browser, it could then connect to
the neighboring computers and servers. These computers would not expect anything
hostile to come from an internal computer, so they would accept the connections. The
applet would then be free to steal sensitive data and transmit it back through the
firewall to the malicious Internet host.
Because of this scenario, applets are only allowed to make network connections
to exactly one host: the one they were loaded from. This restricts the applet from
snooping around the internal network. One of the many well-publicized “Java security
attacks” from researchers at Princeton University was a way of tricking a Java run-time
system into allowing an applet to open network sockets on otherwise forbidden
machines. Thankfully, this problem was very difficult to reproduce and has
subsequently been addressed.
What does security have to do with a multiplayer game? Plenty. The easiest way to
program a multiplayer game would be to have the players communicate directly with
1070 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
each other, in a “peer-to-peer” network. This way, playing the game would not rely on
having any particular server software running. Unfortunately, the applet is only able to
connect back to the server that it was loaded from. This means that two players have to
communicate all of their messages to each other via the server.
In this chapter, you will see the source code to a simple server, which manages a list
of connected clients and passes messages between those clients. For the most part, this
server knows nothing about the game being played. It just passes the messages blithely
from point A to point B. This function is handled by two classes, Server and
ClientConnection. They will be described at the end of this chapter.
The Game
Before users can play a multiplayer game, they must choose somebody to play against.
Rather than forcing a phone call to arrange a game, this applet takes a different approach.
When it is first run, it prompts the user to enter his or her name (see Figure 32-1). This
name is passed to the server, which broadcasts the player’s name to all other potential
competitors. The user then sees a list of all available players (see Figure 32-2), selects
one, and clicks on the Challenge button. Currently, there is no way to confirm or deny
a challenge; they are automatically accepted. Once a challenge is made, both players
see the game board appear, and all other competitors simply see both players’ names
disappear from the available list.
It is quite an easy game to play, but it is very difficult to win against a skilled
opponent. Players are presented with a 15×15 grid of squares and given a set of seven
square tiles with letters of the alphabet engraved on them (see Figure 32-3). These tiles
are selected at random from a bag of 100 tiles. The tiles can be clicked on with the
mouse and dragged to a destination square on the grid. If the spot is already occupied,
the tile is returned to its original position. Tiles may be adjusted on the board during a
turn, but not when the turn is over.
The first player starts by placing several tiles in a line on the board to form a word
in the English language. The first word must cover the center square. Subsequent
words must touch at least one tile already played on the board. The player clicks on the
Done button to end the turn. If a player can’t find a valid word, the player can pass by
clicking on Done twice in a row without having any tiles on the board. The two players
take turns placing words until all of the tiles are used.
The board shown in Figure 32-3 is for smaller displays, and thus the multiplier
squares are marked with simple characters. 2L doubles the value of the letter on that
square. 3L triples the letter’s value. 2W means the whole word gets double the points;
3W means triple the word score. If you make the applet big enough, it will use more
descriptive labels for these squares, as shown in Figure 32-4.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1071
A
P
P
LY
IN
G
JA
V
A
1072 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-1. The user must type in his or her name to begin
Figure 32-2. The list of competitors
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1073
A
P
P
LY
IN
G
JA
V
A
Figure 32-3. Patrick and Herb are ready to play against each other
Figure 32-4. Everything is clearer with a larger applet (650x700)
Scoring
Scores are assessed at the end of each turn. Each tile has a small number engraved on
its face next to the letter. This score may be multiplied by two or three, depending on
the value (color) of the square on which it was placed. The entire sum for a word may
also be multiplied by two or three if any letter in the word covers the appropriate
square. If a word comes in contact with any other tiles to form additional words, they
are counted separately. If a player uses all seven tiles in a single turn, an additional 50
points are awarded. At the end of the game, the player with the highest score wins.
Figure 32-5 shows an example of a board after a few turns have been taken. Patrick
started with SIRE, worth eight points. That came from the four one-point tiles and the
double-word score on the center tile. Next, Herb played HIRE, using the I from SIRE.
This was worth seven points, the sum of the four tiles involved. Notice that Herb got
credit for reusing Patrick’s I but not the double-word score underneath it. At the point
shown in Figure 32-5, Patrick has played GREAT and is about to click the Done button
to complete his turn. Notice that the tiles in play are brighter than those that have
already been played (see Figure 32-6).
At any time during play, the players may converse by typing in the text entry area
at the top of the applet (see Figure 32-7). These messages will appear one at a time in
the other player’s browser’s status line, typically at the bottom of the browser (see
Figure 32-8).
1074 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-5. Scrabblet early in a game
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1075
A
P
P
LY
IN
G
JA
V
A
Figure 32-6. Herb is about to place the D to make HEATED
Figure 32-7. Patrick is complaining about being stuck with the Q without the U
One last word about game play before we get into the source code. The way to win
at this game is to come up with words that score in one direction and also make words
in the other direction. These secondary words tend to be short, two-letter words, but
they add up. In Figure 32-9, Patrick places the Y in DEITY, which will score 21 points
because he gets a face value of 9 doubled to 18, plus he gets to count the word AD,
which runs vertically, for 3 points. Remember that all of the words played with each
turn need to be real words. Eventually, this game will need either an undo for disputed
words or an automatic dictionary checker to resolve conflicts.
The Source Code
Now that you know how to play the game, it is time to examine the source code for the
game. Since several of the classes are quite long, we will sprinkle comments throughout
the code rather than leaving the code till the end.
The APPLET Tag
The APPLET tag for this game is simple. Just name the main class and set the size.
That’s it. There aren’t any <param> tags for Scrabblet. Remember, the bigger you
1076 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-8. Herb replies. Notice Patrick’s last message at the bottom
make the applet, the nicer the board looks. The aspect ratio should be a little taller than
it is wide.
<applet code=Scrabblet.class width=400 height=450>
</applet>
Scrabblet.java
The main applet class is found in Scrabblet.java. At almost 300 lines, this is a fairly
complicated applet class, even though most of the game logic is left to the Board class,
found later in this chapter.
We start with the usual collection of import statements, loading almost every
standard Java package. Then we declare Scrabblet to be a subclass of Applet that
implements ActionListener.
import java.io.*;
import java.net.*;
import java.awt.*;
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1077
A
P
P
LY
IN
G
JA
V
A
Figure 32-9. Patrick scores in two directions!
import java.awt.event.*;
import java.applet.*;
public class Scrabblet extends Applet implements ActionListener {
Next comes the declaration of a large collection of instance variables. The server
is our connection to the web server running our game server. This machine’s name
is stored in serverName. The bag represents the shared bag of letters for our game.
Our opponent has his or her own copy of the bag, which is initialized with the same
random sequence of tiles so the two bags stay in synch. The board is our copy of the
playing board. Our opponent also has a copy of the board, and the game keeps them
in synch after each turn.
If the network server can’t be accessed, the single flag is set, and the applet plays
the game in single-player mode. The boolean ourturn is true whenever it is our turn to
play. If a player can’t find a valid word, the player can pass by clicking on Done twice
in a row without having any tiles on the board. The seen_pass variable is used to mark
if the first Done has been clicked on.
To manage the synchronization of the remote player’s board, we keep a copy of the
tiles selected in theirs. Seeing what the other person has in his or her tray is cheating,
so no hacking this applet to display the contents of theirs! The two strings, name and
others_name, hold our name and our opponent’s name, respectively.
private ServerConnection server;
private String serverName;
private Bag bag;
private Board board;
private boolean single = false;
private boolean ourturn;
private boolean seen_pass = false;
private Letter theirs[] = new Letter[7];
private String name;
private String others_name;
Next, we declare eight variables used to manage the user interface. These are all
AWT components that must be manipulated by the applet in some way. topPanel
holds the prompt and the namefield for getting the user’s name at start-up. The done
button is used to signify that you are done with your turn. The chat TextField is used
to enter chat messages. idList is used to display available opponents. The challenge
button is used to attach us to our opponent. The ican Canvas holds the name and
copyright notice at start-up.
1078 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
private Panel topPanel;
private Label prompt;
private TextField namefield;
private Button done;
private TextField chat;
private List idList;
private Button challenge;
private Canvas ican;
init( )
The init( ) method is called once and simply sets up the BorderLayout, figures out
what Internet host the applet came from, and creates the splash screen canvas.
public void init() {
setLayout(new BorderLayout());
serverName = getCodeBase().getHost();
if (serverName.equals(""))
serverName = "localhost";
ican = new IntroCanvas();
}
start( )
The start( ) method is called whenever the browser redisplays the page in which the
applet is found. The large try block at the beginning is used to catch the case where the
network connection fails. If we succeed in making a new ServerConnection and we’ve
never run start( ) before, we then set up the screen to prompt for the user’s name.
While we are there, we put the splash screen, ican, in the center of the window. In the
case where name is not null, that means the user left the page and has now returned.
We presume we’ve already got the user’s name and jump right to nameEntered( ),
the method that is called when the user types return in the name entry field. The
validate( ) at the end makes sure all of the AWT components are updated properly.
If an exception was thrown, we presume that the net connection failed and go into
single-player mode. The call to start_game( ) gets things rolling.
public void start() {
try {
showStatus("Connecting to " + serverName);
server = new ServerConnection(this, serverName);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1079
A
P
P
LY
IN
G
JA
V
A
server.start();
showStatus("Connected: " + serverName);
if (name == null) {
prompt = new Label("Enter your name here:");
namefield = new TextField(20);
namefield.addActionListener(this);
topPanel = new Panel();
topPanel.setBackground(new Color(255, 255, 200));
topPanel.add(prompt);
topPanel.add(namefield);
add("North", topPanel);
add("Center", ican);
} else {
if (chat != null) {
remove(chat);
remove(board);
remove(done);
}
nameEntered(name);
}
validate();
} catch (Exception e) {
single = true;
start_Game((int)(0x7fffffff * Math.random()));
}
}
stop( )
The stop( ) method is called whenever the user leaves the page with the applet. Here,
we just tell the server that we’ve left. We re-create the network connection in start( ) if
the user returns to the page later.
public void stop() {
if (!single)
server.quit();
}
1080 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
add( )
The add( ) method is called by the ServerConnection whenever a new player enters
the game. We add the player’s name to our List object. Pay special attention to the
formatting of the string in add( ). We use that later to extract certain IDs from the list.
void add(String id, String hostname, String name) {
delete(id); // in case it is already there.
idList.add("(" + id + ")  " + name + "@" + hostname);
showStatus("Choose a player from the list");
}
delete( )
The delete( ) method is called when a player no longer wants to be identified as
available for play. This happens when a player quits or decides to play with someone
else. Here, we hunt down the id string in our list by extracting the values inside
parentheses. If there are no more names on the list (and we aren’t playing the game
already: bag == null), then we display a special message telling the user to hang out
until someone comes to make a challenge.
void delete(String id) {
for (int i = 0; i < idList.getItemCount(); i++) {
String s = idList.getItem(i);
s = s.substring(s.indexOf("(") + 1, s.indexOf(")"));
if (s.equals(id)) {
idList.remove(i);
break;
}
}
if (idList.getItemCount() == 0 && bag == null)
showStatus("Wait for other players to arrive.");
}
getName( )
The getName( ) method is very similar to delete( ), except it simply extracts the name
part of the item and returns it. If the id is not found, then null is returned.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1081
A
P
P
LY
IN
G
JA
V
A
private String getName(String id) {
for (int i = 0; i < idList.getItemCount(); i++) {
String s = idList.getItem(i);
String id1 = s.substring(s.indexOf("(") + 1, s.indexOf(")"));
if (id1.equals(id)) {
return s.substring(s.indexOf(" ") + 3, s.indexOf("@"));
}
}
return null;
}
challenge( )
The challenge( ) method is called by the ServerConnection whenever another player
challenges us to a game. We could have made this method more complicated, so that it
would prompt the user to accept or refuse the challenge, but instead the challenge is
automatically accepted. Notice that the random seed we use to start the game is passed
back to the other player in the accept( ) method. This is used by both sides to initialize
the random state of the tile bag to ensure a synchronous game. We call server.delete( )
to ensure that we are no longer solicited by other players wanting to play against us.
Notice also that we cede the starting turn to the challenger by setting ourturn to false.
// we've been challenged to a game by "id".
void challenge(String id) {
ourturn = false;
int seed = (int)(0x7fffffff * Math.random());
others_name = getName(id);   // who was it?
showStatus("challenged by " + others_name);
// put some confirmation here...
server.accept(id, seed);
server.delete();
start_Game(seed);
}
accept( )
accept( ) is the method called on the remote side in response to the server.accept( )
call just mentioned. Just as the other player deleted himself or herself from the list of
1082 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
available players, so must we call server.delete( ). We take the first turn by setting
ourturn to true.
// our challenge was accepted.
void accept(String id, int seed) {
ourturn = true;
others_name = getName(id);
server.delete();
start_Game(seed);
}
chat( )
The chat( ) method is called by the server whenever the opponent types in his or her
chat window. In this implementation, the method simply shows the chat message in
the browser’s status message. In the future, it might be nice to log these into a
TextArea.
void chat(String id, String s) {
showStatus(others_name + ": " + s);
}
move( )
The move( ) method is called once for each tile your opponent plays. It looks through
the letters saved in theirs to find the one used. If the square is already occupied, the tile
is returned to the player’s tray. Otherwise, the opponent’s letter is moved onto the
board permanently. Next, the tile is replaced in theirs by bag.takeOut( ). If the bag is
empty, a status message appears. The board is repainted to show the new tiles on it.
Note that no scoring is done based on the placement of these tiles. The applet waits
until turn( ) is called to give the score.
// the other guy moved, and placed 'letter' at (x, y).
void move(String letter, int x, int y) {
for (int i = 0; i < 7; i++) {
if (theirs[i] != null && theirs[i].getSymbol().equals(letter)) {
Letter already = board.getLetter(x, y);
if (already != null) {
board.moveLetter(already, 15, 15); // on the tray.
}
board.moveLetter(theirs[i], x, y);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1083
A
P
P
LY
IN
G
JA
V
A
board.commitLetter(theirs[i]);
theirs[i] = bag.takeOut();
if (theirs[i] == null)
showStatus("No more letters");
break;
}
}
board.repaint();
}
turn( )
The turn( ) method is called after all of the opponent’s tiles are moved. The remote
instance of Scrabblet computes the score and sends it to us, so our copy doesn’t have
to redo it. Then the score is reported in the status line, and the setEnabled method
allows us to take a turn. othersTurn( ) tells the board about the score. The board will
reflect the new score at this point.
void turn(int score, String words) {
showStatus(others_name + " played: " + words + " worth " +
score);
done.setEnabled(true);
board.othersTurn(score);
}
quit( )
When the other side quits cleanly, quit( ) is called. It removes the AWT components of
the game and jumps right back into nameEntered( ), described next, to get connected
back into the player list.
void quit(String id) {
showStatus(others_name + " just quit.");
remove(chat);
remove(board);
remove(done);
nameEntered(name);
}
1084 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
nameEntered( )
The nameEntered( ) method is called from actionPerformed( ) whenever ENTER is
pressed in the original prompt for the user’s name. Any AWT components that might
be in the way are removed, and then a new List object, idList, is created to store the
names of the other players. The method also adds a button at the top named challenge,
then notifies the server that we are here by calling setName( ).
private void nameEntered(String s) {
if (s.equals(""))
return;
name = s;
if (ican != null)
remove(ican);
if (idList != null)
remove(idList);
if (challenge != null)
remove(challenge);
idList = new List(10, false);
add("Center", idList);
challenge = new Button("Challenge");
challenge.addActionListener(this);
add("North", challenge);
validate();
server.setName(name);
showStatus("Wait for other players to arrive.");
if (topPanel != null)
remove(topPanel);
}
wepick( ) and theypick( )
The methods wepick( ) and theypick( ) are simply used to start off the game by
picking the seven tiles for each player. It is important that the caller do these in the
right order on each side of the challenge, depending on who goes first. The call to
bag.takeOut( ) gets a single letter permanently out of the shared bag. The call to
board.addLetter( ) places the tile on our tray. For the other side, theypick( ) simply
saves the letters in theirs.
private void wepick() {
for (int i = 0; i < 7; i++) {
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1085
A
P
P
LY
IN
G
JA
V
A
Letter l = bag.takeOut();
board.addLetter(l);
}
}
private void theypick() {
for (int i = 0; i < 7; i++) {
Letter l = bag.takeOut();
theirs[i] = l;
}
}
start_Game( )
In single-player mode, start_Game( ) pops up the splash screen in a Frame window.
It then creates a playing board, passing in no parameters to the constructor, which
indicates single-player mode.
In head-to-head mode, we remove the selection list components and add the chat
window to the applet. We then add the board and Done button to the applet. Next, we
create the bag, and if it is ourturn, wepick( ) is first, then theypick( ). In the case where
we don’t have the first turn, we disable the board and the Done button, and theypick( )
is first. We then force the board to repaint, which initializes it.
private void start_Game(int seed) {
if (single) {
Frame popup = new Frame("Scrabblet");
popup.setSize(400, 300);
popup.add("Center", ican);
popup.setResizable(false);
popup.show();
board = new Board();
showStatus("no server found, playing solo");
ourturn = true;
} else {
remove(idList);
remove(challenge);
board = new Board(name, others_name);
chat = new TextField();
chat.addActionListener(this);
add("North", chat);
1086 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
showStatus("playing against " + others_name);
}
add("Center", board);
done = new Button("Done");
done.addActionListener(this);
add("South", done);
validate();
bag = new Bag(seed);
if (ourturn) {
wepick();
if (!single)
theypick();
} else {
done.setEnabled(false);
theypick();
wepick();
}
board.repaint();
}
challenge_them( )
The challenge_them( ) method is called when the challenge button is clicked. It simply
takes the player you had selected in the idList and sends him or her a challenge( )
message. It removes the list and button to be ready for the game to start.
private void challenge_them() {
String s = idList.getSelectedItem();
if (s == null) {
showStatus("Choose a player from the list then press Challenge");
} else {
remove(challenge);
remove(idList);
String destid = s.substring(s.indexOf('(')+1,
s.indexOf(')'));
showStatus("challenging: " + destid);
server.challenge(destid);  // accept will get called if
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1087
A
P
P
LY
IN
G
JA
V
A
// they accept.
validate();
}
}
our_turn( )
When the Done button is clicked, our_turn( ) is called. First, it checks to see if we’ve
placed tiles in valid locations by calling board.findwords( ) and storing the result in
word. If word is null, then something is amiss with the tiles, and the method shows
that in the status line. If word is ““, then it knows that there were no tiles in play at the
time. In single-player mode, this is ignored. In competition mode, if we click Done
twice in a row without any tiles in play, we will pass our turn to our opponent.
If you have played tiles and they are in legal positions, you have finished your turn,
so ourturn( ) commits the letters to the board. Notice that commit( ) takes the server as
a parameter. It will use this to tell the remote side about the position of each new letter.
Then the method replaces the letters you used. In multiplayer mode, we disable
ourselves and call server.turn( ) to tell the other player it is his or her turn.
private void our_turn() {
String word = board.findwords();
if (word == null) {
showStatus("Illegal letter positions");
} else {
if ("".equals(word)) {
if (single)
return;
if (seen_pass) {
done.setEnabled(false);
server.turn("pass", 0);
showStatus("You passed");
seen_pass = false;
} else {
showStatus("Press done again to pass");
seen_pass = true;
return;
}
} else {
seen_pass = false;
}
showStatus(word);
1088 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
board.commit(server);
for (int i = 0; i < 7; i++) {
if (board.getTray(i) == null) {
Letter l = bag.takeOut();
if (l == null)
showStatus("No more letters");
else
board.addLetter(l);
}
}
if (!single) {
done.setEnabled(false);
server.turn(word, board.getTurnScore());
}
board.repaint();
}
}
actionPerformed( )
The actionPerformed( ) method is used to grab input from the various components the
applet uses. It handles the Challenge and Done buttons, as well as the name entry field
and the chat entry field.
public void actionPerformed(ActionEvent ae) {
Object source = ae.getSource();
if(source == chat) {
server.chat(chat.getText());
chat.setText("");
}
else if(source == challenge) {
challenge_them();
}
else if(source == done) {
our_turn();
}
else if(source == namefield) {
TextComponent tc = (TextComponent)source;
nameEntered(tc.getText());
}
}
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1089
A
P
P
LY
IN
G
JA
V
A
IntroCanvas.java
The IntroCanvas subclass of Canvas is very simple. It just overrides paint( ) to draw
the name of the applet and a brief copyright notice. It creates some custom colors and
fonts. The display strings are held in static variables simply for clarity.
import java.awt.*;
import java.awt.event.*;
class IntroCanvas extends Canvas {
private Color pink = new Color(255, 200, 200);
private Color blue = new Color(150, 200, 255);
private Color yellow = new Color(250, 220, 100);
private int w, h;
private int edge = 16;
private static final String title = "Scrabblet";
private static final String name =
"Copyright 1999 - Patrick Naughton";
private static final String book =
"Chapter 32 from 'Java: The Complete Reference'";
private Font namefont, titlefont, bookfont;
IntroCanvas() {
setBackground(yellow);
titlefont = new Font("SansSerif", Font.BOLD, 58);
namefont = new Font("SansSerif", Font.BOLD, 18);
bookfont = new Font("SansSerif", Font.PLAIN, 12);
addMouseListener(new MyMouseAdapter());
}
d( )
The private method d( ) is a convenience method that paints centered text with an
optional isometric offset. This is used to give the main title a highlight/shadow effect
by drawing a white string up and to the left by 1, a black string down and to the right
by 1, and then drawing the string one last time in pink, not offset at all.
private void d(Graphics g, String s, Color c, Font f, int y,
int off) {
g.setFont(f);
FontMetrics fm = g.getFontMetrics();
g.setColor(c);
1090 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
g.drawString(s, (w - fm.stringWidth(s)) / 2 + off, y + off);
}
public void paint(Graphics g) {
Dimension d = getSize();
w = d.width;
h = d.height;
g.setColor(blue);
g.fill3DRect(edge, edge, w - 2 * edge, h - 2 * edge, true);
d(g, title, Color.black, titlefont, h / 2, 1);
d(g, title, Color.white, titlefont, h / 2, -1);
d(g, title, pink, titlefont, h / 2, 0);
d(g, name, Color.black, namefont, h * 3 / 4, 0);
d(g, book, Color.black, bookfont, h * 7 / 8, 0);
}
mousePressed( )
In the following code fragment, notice that MyMouseAdapter is an inner class that
extends MouseAdapter. It overrides the mousePressed( ) method to cause this canvas’
parent to hide( ) if it is clicked on. This is only useful in single-player mode to dismiss
the pop-up frame.
class MyMouseAdapter extends MouseAdapter {
public void mousePressed(MouseEvent me) {
((Frame)getParent()).setVisible(false);
}
}
}
Board.java
The Board class encapsulates most of the game logic as well as the look and feel of the
board. It is the biggest class in the game, weighing in at over 500 lines of code. There
are several private variables that store the game state. The 15×15 array of Letters
named board is used to store the tiles on each square of the board. The tray array holds
the Letters that are currently on our tray. Remember that the Scrabblet applet class
holds the seven Letters from our opponent. The Point objects orig and here are used to
remember letter positions. The name and others_name variables are used simply to
display names for the scoreboard. In single-player mode, both will be null. The two
players’ scores are stored in total_score and others_score, while our last turn’s result is
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1091
A
P
P
LY
IN
G
JA
V
A
stored in turn_score. The two constructors set up the names of the players, or leave
them blank in single-player mode.
import java.awt.*;
import java.awt.event.*;
class Board extends Canvas {
private Letter board[][] = new Letter[15][15];
private Letter tray[] = new Letter[7];
private Point orig = new Point(0,0);
private Point here = new Point(0,0);
private String name;
private int total_score = 0;
private int turn_score = 0;
private int others_score = 0;
private String others_name = null;
Board(String our_name, String other_name) {
name = our_name;
others_name = other_name;
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
Board() {
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
othersTurn( ), getTurnScore( ), and getTray( )
These three methods are used to control the access to several private variables.
First, othersTurn( ) is called by the applet when the other player finishes a turn. It
increments the player’s score and repaints that area of the board to reflect the change.
The getTurnScore( ) method simply returns the saved last turn’s score, after making
sure the scoreboard is painted with the correct value. The applet uses this method to
pass the score to our opponent, where it will eventually call othersTurn( ) on the
remote machine. The getTray( ) method simply provides a read-only access to the
private tray array.
1092 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
void othersTurn(int score) {
others_score += score;
paintScore();
repaint();
}
int getTurnScore() {
paintScore();
return turn_score;
}
Letter getTray(int i) {
return tray[i];
}
addLetter( )
The addLetter( ) method is used to place a letter on the tray. The letter is placed in the
first slot that is empty. If the method can’t find an empty slot, it returns false.
synchronized boolean addLetter(Letter l) {
for (int i = 0; i < 7; i++) {
if (tray[i] == null) {
tray[i] = l;
moveLetter(l, i, 15);
return true;
}
}
return false;
}
existingLetterAt( )
The private method existingLetterAt( ) is used to check a board position to see if it has
a letter in it that is not currently in play. This is used by findwords( ) next to make sure
that at least one letter in a turn is touching an already existing letter.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1093
A
P
P
LY
IN
G
JA
V
A
private boolean existingLetterAt(int x, int y) {
Letter l = null;
return (x >= 0 && x <= 14 && y >= 0 && y <= 14
&& (l = board[y][x]) != null && l.recall() == null);
}
findwords( )
findwords( ) is a very large method used to examine the state of the board for a legal
turn. If the rules for letter placement are broken, then null is returned. If no tiles were
in play, then ““ is returned. If all of the tiles played in this turn are legal, then the list of
words they formed is returned as a string containing the space-separated words. The
instance variables turn_score and total_score are updated to reflect the value of the
words that were just played.
First findwords( ) counts the tiles at play, ntiles, storing them in a separate array
called atplay. Next, it looks at the first two tiles (if more than one was played) to
determine if they are vertically or horizontally oriented. Then it inspects all of the other
tiles at play, to make sure they are along the same line. If any of the tiles is out of that
row or column, the method returns null.
synchronized String findwords() {
String res = "";
turn_score = 0;
int ntiles = 0;
Letter atplay[] = new Letter[7];
for (int i = 0; i < 7; i++) {
if (tray[i] != null && tray[i].recall() != null) {
atplay[ntiles++] = tray[i];
}
}
if (ntiles == 0)
return res;
boolean horizontal = true; // if there's one tile,
// call it horizontal
boolean vertical = false;
if (ntiles > 1) {
int x = atplay[0].x;
int y = atplay[0].y;
horizontal = atplay[1].y == y;
1094 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
vertical = atplay[1].x == x;
if (!horizontal && !vertical) // diagonal...
return null;
for (int i = 2; i < ntiles; i++) {
if (horizontal && atplay[i].y != y
|| vertical && atplay[i].x != x)
return null;
}
}
Next, it looks at each tile to be sure that at least one of them is touching an existing
tile on one of its four sides. A special case is made for the beginning of the game: if the
center tile is covered and more than one tile is played, it is legal.
// make sure that at least one played tile is
// touching at least one existing tile.
boolean attached = false;
for (int i = 0; i < ntiles; i++) {
Point p = atplay[i].recall();
int x = p.x;
int y = p.y;
if ((x == 7 && y == 7 && ntiles > 1) ||
existingLetterAt(x-1, y) || existingLetterAt(x+1, y) ||
existingLetterAt(x, y-1) || existingLetterAt(x, y+1)) {
attached = true;
break;
}
}
if (!attached) {
return null;
}
This next loop iterates over every letter in the main word, (i == –1), then comes
back again for each letter (i == 0..ntiles), which might also create a word orthogonal to
the main direction, which is managed via horizontal.
// we use -1 to mean check the major direction first
// then 0..ntiles checks for words orthogonal to it.
for (int i = -1; i < ntiles; i++) {
Point p = atplay[i==-1?0:i].recall(); // where is it?
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1095
A
P
P
LY
IN
G
JA
V
A
int x = p.x;
int y = p.y;
int xinc, yinc;
if (horizontal) {
xinc = 1;
yinc = 0;
} else {
xinc = 0;
yinc = 1;
}
int mult = 1;
String word = "";
int word_score = 0;
The method then picks each tile and moves left or up from it to find the first tile
in each word. Once at the beginning of the word, it moves right or down from it,
inspecting every letter. It counts the letters in letters_seen. For each letter, it determines
the point contribution based on the bonus multiplier beneath it. If the square is played
for the first time, the multiplier value is applied; otherwise the tile is counted at face
value. This score is accumulated in word_score.
// here we back up to the top/left-most letter
while (x >= xinc && y >= yinc &&
board[y-yinc][x-xinc] != null) {
x -= xinc;
y -= yinc;
}
int n = 0;
int letters_seen = 0; // letters we've just played.
Letter l;
while (x < 15 && y < 15 && (l = board[y][x]) != null) {
word += l.getSymbol();
int lscore = l.getPoints();
if (l.recall() != null) {  // one we just played...
Color t = tiles[y < 8 ? y : 14 - y][x < 8 ? x : 14 - x];
if (t == w3)
mult *= 3;
else if (t == w2)
1096 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
mult *= 2;
else if (t == l3)
lscore *= 3;
else if (t == l2)
lscore *= 2;
if (i == -1) {
letters_seen++;
}
}
word_score += lscore;
n++;
x += xinc;
y += yinc;
}
word_score *= mult;
One last error check is done on the main word only. Since the loop ends whenever
it hits a blank square or the edge of the board, it should cover all of the freshly played
tiles, as well as some previously played ones. If it sees fewer tiles, then there must have
been a gap in them, which is an illegal position, so it returns null. If that test is passed,
it checks to see if all seven tiles were played, awarding a 50-point bonus if they were.
After inspecting the main word, findwords( ) inverts the sense of horizontal and looks
for orthogonal words on the subsequent passes.
if (i == -1) {     // first pass...
// if we didn't see all the letters, then there was a gap,
// which is an illegal tile position.
if (letters_seen != ntiles) {
return null;
}
if (ntiles == 7) {
turn_score += 50;
}
// after the first pass, switch to looking the other way.
horizontal = !horizontal;
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1097
A
P
P
LY
IN
G
JA
V
A
As findwords( ) walks across the word, it needs to make sure that it only scores
letters that form at least two-letter words. In this case, it adds the word_score to the
turn_score and appends this word to the result string. Once all of the letters have been
inspected, it totals the score and returns.
if (n < 2)  // don't count single letters twice.
continue;
turn_score += word_score;
res += word + " ";
}
total_score += turn_score;
return res;
}
commit( ) and commitLetter( )
The commit( ) and commitLetter( ) methods commit the letters that were tentatively
placed on the board. These letters are removed from the tray and painted in a darker
color on the board. As each letter is committed, commit( ) notifies the server of the
position of each letter by calling move( ) so that the opponent’s board can be updated.
synchronized void commit(ServerConnection s) {
for (int i = 0 ; i < 7 ; i++) {
Point p;
if (tray[i] != null && (p = tray[i].recall()) != null) {
if (s != null)  // there's a server connection
s.move(tray[i].getSymbol(), p.x, p.y);
commitLetter(tray[i]);  // marks this as not in play.
tray[i] = null;
}
}
}
void commitLetter(Letter l) {
if (l != null && l.recall() != null) {
l.paint(offGraphics, Letter.DIM);
l.remember(null);   // marks this as not in play.
}
}
1098 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
update( ) and paint( )
Many private variables are declared here to provide easy access to the dimensions of
the board. This code also declares two offscreen buffers, one to be used as the image of
the board and all of the permanently set tiles and another to use as a double buffer for
the display. The update( ) method simply calls paint( ) to avoid flicker. The paint( )
method makes a quick call to checksize( ) to make sure all of the buffers have been
created, then checks to see if we are dragging a letter around by means of pick != null.
If so, then paint( ) makes a copy of the offscreen graphics context and clips it to the
bounds of the letter it is painting, x0, y0, w0, h0. Next, it clips the onscreen graphics
context to the same rectangle. This will minimize the number of pixels it will have to
move for each move of the mouse.
To paint, we copy the background image, offscreen, then call paint on each
letter in the tray with the setting of NORMAL. We paint the letter we are dragging
around in the BRIGHT mode. Finally, we copy the double buffer image,
offscreen2, to the screen.
private Letter pick;  // the letter being dragged around.
private int dx, dy;   // offset to topleft corner of pick.
private int lw, lh;   // letter width and height.
private int tm, lm;   // top and left margin.
private int lt;       // line thickness (between tiles).
private int aw, ah;   // letter area size.
private Dimension offscreensize;
private Image offscreen;
private Graphics offGraphics;
private Image offscreen2;
private Graphics offGraphics2;
public void update(Graphics g) {
paint(g);
}
public synchronized void paint(Graphics g) {
Dimension d = checksize();
Graphics gc = offGraphics2;
if (pick != null) {
gc = gc.create();
gc.clipRect(x0, y0, w0, h0);
g.clipRect(x0, y0, w0, h0);
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1099
A
P
P
LY
IN
G
JA
V
A
gc.drawImage(offscreen, 0, 0, null);
for (int i = 0 ; i < 7 ; i++) {
Letter l = tray[i];
if (l != null && l != pick)
l.paint(gc, Letter.NORMAL);
}
if (pick != null)
pick.paint(gc, Letter.BRIGHT);
g.drawImage(offscreen2, 0, 0, null);
}
LetterHit( )
LetterHit( ) returns the letter that is under the point x,y and returns null if no letter
is there.
Letter LetterHit(int x, int y) {
for (int i = 0; i < 7; i++) {
if (tray[i] != null && tray[i].hit(x, y)) {
return tray[i];
}
}
return null;
}
unplay( )
This simple method removes a letter from play that was placed on the board but was
not yet committed.
private void unplay(Letter let) {
Point p = let.recall();
if (p != null) {
board[p.y][p.x] = null;
let.remember(null);
}
}
1100 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
moveToTray( )
The moveToTray( ) method is just a simple convenience to compute the screen position
of a letter in a given tray slot.
private void moveToTray(Letter l, int i) {
int x = lm + (lw + lt) * i;
int y = tm + ah - 2 * lt;
l.move(x, y);
}
dropOnTray( )
The dropOnTray( ) method is used whenever we drop a letter over the tray area or off
the board anywhere. This allows us to shuffle the contents of the tray as well as simply
return tiles from the board.
private void dropOnTray(Letter l, int x) {
unplay(l); // unhook where we were.
// find out what slot this letter WAS in.
int oldx = 0;
for (int i = 0 ; i < 7 ; i++) {
if (tray[i] == l) {
oldx = i;
break;
}
}
// if the slot we dropped on was empty,
// find the rightmost occupied slot.
if (tray[x] == null) {
for (int i = 6 ; i >= 0 ; i--) {
if (tray[i] != null) {
x = i;
break;
}
}
}
// if the slot we dropped on was from a tile already
// played on the board, just swap slots with it.
if (tray[x].recall() != null) {
tray[oldx] = tray[x];
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1101
A
P
P
LY
IN
G
JA
V
A
} else {
// we are just rearranging a tile already on the tray.
if (oldx < x) {   // shuffle left.
for (int i = oldx ; i < x ; i++) {
tray[i] = tray[i+1];
if (tray[i].recall() == null)
moveToTray(tray[i], i);
}
} else {          // shuffle right.
for (int i = oldx ; i > x ; i--) {
tray[i] = tray[i-1];
if (tray[i].recall() == null)
moveToTray(tray[i], i);
}
}
}
tray[x] = l;
moveToTray(l, x);
}
getLetter( )
getLetter( ) is a simple read-only wrapper on the board array.
Letter getLetter(int x, int y) {
return board[y][x];
}
moveLetter( )
The moveLetter( ) method handles the cases where we want to move tiles to board
positions or set them on the tray. If the x,y position is out of range for the board, then
the tray is used. When a letter is moved to the board, it must be a blank slot, otherwise
the letter is sent back to the value stored in orig.
void moveLetter(Letter l, int x, int y) {
if (y > 14 || x > 14 || y < 0 || x < 0) {
// if we are off the board.
if (x > 6)
x = 6;
if (x < 0)
1102 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
x = 0;
dropOnTray(l, x);
} else {
if (board[y][x] != null) {
x = orig.x;
y = orig.y;
} else {
here.x = x;
here.y = y;
unplay(l);
board[y][x] = l;
l.remember(here);
// turn it back into pixels
x = lm + (lw + lt) * x;
y = tm + (lh + lt) * y;
}
l.move(x, y);
}
}
checksize( )
This method has a misleading name. checksize( ) does a lot more than verify the size of
the applet, but it is convenient to do this kind of initialization once, when we confirm
the size of the applet. This method contains the drawing code for the main board
pattern. It paints all of the squares, including the colors and the bonus score text.
private Color bg = new Color(175, 185, 175);
private Color w3 = new Color(255, 50, 100);
private Color w2 = new Color(255, 200, 200);
private Color l3 = new Color(75, 75, 255);
private Color l2 = new Color(150, 200, 255);
private Color tiles[][] = {
{w3, bg, bg, l2, bg, bg, bg, w3},
{bg, w2, bg, bg, bg, l3, bg, bg},
{bg, bg, w2, bg, bg, bg, l2, bg},
{l2, bg, bg, w2, bg, bg, bg, l2},
{bg, bg, bg, bg, w2, bg, bg, bg},
{bg, l3, bg, bg, bg, l3, bg, bg},
{bg, bg, l2, bg, bg, bg, l2, bg},
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1103
A
P
P
LY
IN
G
JA
V
A
{w3, bg, bg, l2, bg, bg, bg, w2}
};
private Dimension checksize() {
Dimension d = getSize();
int w = d.width;
int h = d.height;
if (w < 1 || h < 1)
return d;
if ((offscreen == null) ||
(w != offscreensize.width) ||
(h != offscreensize.height)) {
System.out.println("updating board: " + w + " x " + h + "\r");
offscreen = createImage(w, h);
offscreensize = d;
offGraphics = offscreen.getGraphics();
offscreen2 = createImage(w, h);
offGraphics2 = offscreen2.getGraphics();
offGraphics.setColor(Color.white);
offGraphics.fillRect(0,0,w,h);
// lt is the thickness of the white lines between tiles.
// gaps is the sum of all the whitespace.
// lw, lh are the dimensions of the tiles.
// aw, ah are the dimensions of the entire board
// lm, tm are the left and top margin to center aw, ah in the applet.
lt = 1 + w / 400;
int gaps = lt * 20;
lw = (w - gaps) / 15;
lh = (h - gaps - lt * 2) / 16; // compensating for tray height;
aw = lw * 15 + gaps;
ah = lh * 15 + gaps;
lm = (w - aw) / 2 + lt;
tm = (h - ah - (lt * 2 + lh)) / 2 + lt;
1104 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
offGraphics.setColor(Color.black);
offGraphics.fillRect(lm,tm,aw-2*lt,ah-2*lt);
lm += lt;
tm += lt;
offGraphics.setColor(Color.white);
offGraphics.fillRect(lm,tm,aw-4*lt,ah-4*lt);
lm += lt;
tm += lt;
int sfh = (lh > 30) ? lh / 4 : lh / 2;
Font font = new Font("SansSerif", Font.PLAIN, sfh);
offGraphics.setFont(font);
for (int j = 0, y = tm; j < 15; j++, y += lh + lt) {
for (int i = 0, x = lm; i < 15; i++, x += lw + lt) {
Color c = tiles[j < 8 ? j : 14 - j][i < 8 ? i : 14 - i];
offGraphics.setColor(c);
offGraphics.fillRect(x, y, lw, lh);
offGraphics.setColor(Color.black);
if (lh > 30) {
String td = (c == w2 || c == l2) ? "DOUBLE" :
(c == w3 || c == l3) ? "TRIPLE" : null;
String wl = (c == l2 || c == l3) ? "LETTER" :
(c == w2 || c == w3) ? "WORD" : null;
if (td != null) {
center(offGraphics, td, x, y + 2 + sfh, lw);
center(offGraphics, wl, x, y + 2 * (2 + sfh), lw);
center(offGraphics, "SCORE", x, y + 3 * (2 + sfh), lw);
}
} else {
String td = (c == w2 || c == l2) ? "2" :
(c == w3 || c == l3) ? "3" : null;
String wl = (c == l2 || c == l3) ? "L" :
(c == w2 || c == w3) ? "W" : null;
if (td != null) {
center(offGraphics, td + wl, x,
y + (lh - sfh) * 4 / 10 + sfh, lw);
}
}
}
}
Color c = new Color(255, 255, 200);
offGraphics.setColor(c);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1105
A
P
P
LY
IN
G
JA
V
A
offGraphics.fillRect(lm, tm + ah - 3 * lt, 7 * (lw + lt), lh +
2 * lt);
Letter.resize(lw, lh);
// if we already have some letters, place them.
for (int i = 0; i < 7; i++) {
if (tray[i] != null) {
moveToTray(tray[i], i);
}
}
paintScore();
}
return d;
}
center( )
center( ) is a convenience routine that checksize( ) uses to center the “Double Letter
Score” text.
private void center(Graphics g, String s, int x, int y, int w) {
x += (w - g.getFontMetrics().stringWidth(s)) / 2;
g.drawString(s, x, y);
}
paintScore( )
The paintScore( ) method paints the two players’ scores or just the one score in
single-player mode.
private void paintScore() {
int x = lm + (lw + lt) * 7 + lm;
int y = tm + ah - 3 * lt;
int h = lh + 2 * lt;
Font font = new Font("TimesRoman", Font.PLAIN, h/2);
offGraphics.setFont(font);
FontMetrics fm = offGraphics.getFontMetrics();
offGraphics.setColor(Color.white);
offGraphics.fillRect(x, y, aw, h);
offGraphics.setColor(Color.black);
1106 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
if (others_name == null) {
int y0 = (h - fm.getHeight()) / 2 + fm.getAscent();
offGraphics.drawString("Score: " + total_score, x, y + y0);
} else {
h/=2;
int y0 = (h - fm.getHeight()) / 2 + fm.getAscent();
offGraphics.drawString(name + ": " + total_score, x, y + y0);
offGraphics.drawString(others_name + ": " + others_score,
x, y + h + y0);
}
}
private int x0, y0, w0, h0;
selectLetter( )
The selectLetter( ) method checks the mouse position to see if the cursor is over a letter.
If so, it stores that in pick and computes how far the mouse was from the upper-left
corner of the letter, which is stored in dx, dy. It also remembers the original position of
this letter in orig.
private void selectLetter(int x, int y) {
pick = LetterHit(x, y);
if(pick != null) {
dx = pick.x - x;
dy = pick.y - y;
orig.x = pick.x;
orig.y = pick.y;
}
repaint();
}
dropLetter( )
In dropLetter( ), the user has dropped the letter if he or she was carrying one. It
determines which square on the board the letter was over when it was dropped. It then
calls moveLetter( ) to attempt to move the letter to that square.
private void dropLetter(int x, int y) {
if(pick != null) {
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1107
A
P
P
LY
IN
G
JA
V
A
// find the center of the tile
x += dx + lw / 2;
y += dy + lh / 2;
// find the tile index
x = (x - lm) / (lw + lt);
y = (y - tm) / (lh + lt);
moveLetter(pick, x, y);
pick = null;
repaint();
}
}
dragLetter( )
The dragLetter( ) method is handled differently than the other mouse-related events.
This is mainly due to performance considerations. The goal is to have as smooth an
interaction with the user as possible. dragLetter( ) goes to some length to compute the
bounding box of where the tile was before this drag plus where it is now. It then
directly calls paint(getGraphics( )). This is nonstandard Java applet programming, but
it performs much more reliably.
private void dragLetter(int x, int y) {
if (pick != null) {
int ox = pick.x;
int oy = pick.y;
pick.move(x + dx, y + dy);
x0 = Math.min(ox, pick.x);
y0 = Math.min(oy, pick.y);
w0 = pick.w + Math.abs(ox - pick.x);
h0 = pick.h + Math.abs(oy - pick.y);
paint(getGraphics());
}
}
mousePressed( )
In the following code fragment, notice that MyMouseAdapter is an inner class that
extends MouseAdapter. It overrides the mousePressed( ) and mouseReleased( )
methods.
1108 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The mousePressed( ) method invokes the selectLetter( ) method to do the
necessary processing. The x and y coordinates of the current mouse position are
obtained from the argument supplied to the mousePressed( ) method.
class MyMouseAdapter extends MouseAdapter {
public void mousePressed(MouseEvent me) {
selectLetter(me.getX(), me.getY());
}
mouseReleased( )
The mouseReleased( ) method invokes the dropLetter( ) method to do the necessary
processing. The x and y coordinates of the current mouse position are obtained from
the argument supplied to the mouseReleased( ) method.
public void mouseReleased(MouseEvent me) {
dropLetter(me.getX(), me.getY());
}
}
mouseDragged( )
In the following code fragment, notice that MyMouseMotionAdapter is an inner class
that extends MouseMotionAdapter. It overrides the mouseDragged( ) method.
The mouseDragged( ) method invokes the dragLetter( ) method to do the necessary
processing. The x and y coordinates of the current mouse position are obtained from
the argument supplied to the mouseDragged( ) method.
class MyMouseMotionAdapter extends MouseMotionAdapter {
public synchronized void mouseDragged(MouseEvent me) {
dragLetter(me.getX(), me.getY());
}
}
}
Bag.java
The Bag class is very clean compared with Board. It is a simple abstraction for the bag
of letters. When you create a Bag, you pass in a random seed, which allows you to
create two bags that are random but the same by passing in the same random seed. The
random number generator is stored in rand. There are two somewhat strange arrays of
integers, named letter_counts and letter_points. Both arrays are 27 slots long. They
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1109
A
P
P
LY
IN
G
JA
V
A
represent the blank tile in slot 0, and A through Z in 1 through 26. The letter_counts
array says how many of each letter are in a full bag. For example, letter_counts[1] is 9,
which says there are nine A tiles in the bag. Similarly, the letter_points array maps
each letter to its point value. The A tiles are worth only 1 point, and the lone Z is worth
10. There are 100 letters stored in the array called letters. The number of letters actually
left in the bag during game play is stored in n.
import java.util.Random;
class Bag {
private Random rand;
private int letter_counts[] = {
2, 9, 2, 2, 4, 12, 2, 3, 2, 9, 1, 1, 4, 2,
6, 8, 2, 1, 6, 4, 6, 4, 2, 2, 1, 2, 1
};
private int letter_points[] = {
0, 1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3,
1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10
};
private Letter letters[] = new Letter[100];
private int n = 0;
Bag( )
The Bag constructor takes the seed and makes a Random object out of it. It then scans
through the letter_counts array, making the right number of new Letter objects, being
careful to replace the blank tile with an asterisk. It then calls putBack( ) for each letter,
to put them in the bag.
Bag(int seed) {
rand = new Random(seed);
for (int i = 0; i < letter_counts.length; i++) {
for (int j = 0; j < letter_counts[i]; j++) {
Letter l = new Letter(i == 0 ? '*' : (char)('A' + i - 1),
letter_points[i]);
putBack(l);
}
}
}
1110 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
takeOut( )
This next method is slightly clever and a little inefficient, but in a noncritical way.
takeOut( ) picks a random number between 0 and n –1. It then extracts the letter at
that offset from the letters array. It closes the hole over that slot in letters using
System.arraycopy( ). Then it decrements n and returns the letter.
synchronized Letter takeOut() {
if (n == 0)
return null;
int i = (int)(rand.nextDouble() * n);
Letter l = letters[i];
if (i != n - 1)
System.arraycopy(letters, i + 1, letters, i, n - i - 1);
n--;
return l;
}
putBack( )
The putBack( ) method is used by the constructor to put the tiles in the bag originally.
It could also be used by a future game enhancement that would let players trade in
tiles they were unhappy with in exchange for losing a turn. It simply puts the letter
back at the end of the array.
synchronized void putBack(Letter l) {
letters[n++] = l;
}
}
Letter.java
The Letter class is fairly clean in that it doesn’t know anything about the game or the
board. It merely encapsulates the position and visual rendering of a single letter. It uses
several static variables to hold information about fonts and sizes. This is done so that
the applet doesn’t end up with 100 fonts in memory at once. This has the side effect
that a browser page cannot contain two instances of the Scrabblet applet if they each
have different sizes. The second one to initialize will overwrite the values in these
static variables.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1111
A
P
P
LY
IN
G
JA
V
A
The w and h variables hold the constant width and height of every letter. The font
and smfont variables are the AWT font objects for the big letter and the smaller point
value. The ints y0 and ys0 store the offset of the baseline of the letter and the points,
respectively. A few constants are provided to be passed back into paint( ) to describe
which color state to paint in: NORMAL, DIM, and BRIGHT mode.
import java.awt.*;
class Letter {
static int w, h;
private static Font font, smfont;
private static int y0, ys0;
private static int lasth = -1;
static final int NORMAL = 0;
static final int DIM = 1;
static final int BRIGHT = 2;
colors[ ], mix( ), gain( ), and clamp( )
The colors array is initialized statically with nine color objects—three sets of three
colors. The mix( ) method is used to take a set of RGB values like 250, 220, 100 and turn
them into three colors, which can be used to provide 3-D–like highlights and lowlights.
The mix( ) method calls on gain( ) to boost or decimate the brightness of a given color
and calls on clamp( ) to make sure it remains in the legal range.
private static Color colors[][] = {
mix(250, 220, 100),   // normal
mix(200, 150, 80),    // dim
mix(255, 230, 150)    // bright
};
private static Color mix(int r, int g, int b)[] {
Color arr[] = new Color[3];
arr[NORMAL] = new Color(r, g, b);
arr[DIM] = gain(arr[0], .71);
arr[BRIGHT] = gain(arr[0], 1.31);
return arr;
}
private static int clamp(double d) {
return (d < 0) ? 0 : ((d > 255) ? 255 : (int) d);
}
1112 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
private static Color gain(Color c, double f) {
return new Color(
clamp(c.getRed() * f),
clamp(c.getGreen() * f),
clamp(c.getBlue() * f));
}
Instance Variables
The valid flag is used to make sure that all of the sizing variables are set up exactly
once, the first time this Letter is painted. There are several variables cached here to
keep from having to do lots of computation each time the applet paints—such as, x0,
w0, xs0, ws0, and gap—which are all explained in the following comments. The tile
Point object is used to remember which square on the 15×15 board this Letter is on. If
this variable is null, then the Letter is not on the board. The x,y pair is used to exactly
locate the Letter.
private boolean valid = false;
// quantized tile position of Letter. (just stored here).
private Point tile = null;
int x, y;               // position of Letter.
private int x0;         // offset of symbol on tile.
private int w0;         // width in pixels of symbol.
private int xs0;        // offset of points on tile.
private int ws0;        // width in pixels of points.
private int gap = 1;    // pixels between symbol and points.
Letter( ), getSymbol( ), and getPoints( )
The symbol is a string that holds the letter displayed, and points is the point value of
this letter. These are both initialized by the only constructor and returned by the
wrapper methods getSymbol( ) and getPoints( ), respectively.
private String symbol;
private int points;
Letter(char s, int p) {
symbol = "" + s;
points = p;
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1113
A
P
P
LY
IN
G
JA
V
A
String getSymbol() {
return symbol;
}
int getPoints() {
return points;
}
move( ), remember( ), and recall( )
The move( ) method is used to tell this tile where to draw. The remember( ) method,
however, is more complicated. It can be called with a null, which means that this tile
should “forget” where it was. This indicates that the letter is not in play. Otherwise, it
tells which coordinate on the board this letter is occupying. This state is inspected by a
call to recall( ).
void move(int x, int y) {
this.x = x;
this.y = y;
}
void remember(Point t) {
if (t == null) {
tile = t;
} else {
tile = new Point(t.x, t.y);
}
}
Point recall() {
return tile;
}
resize( )
The resize( ) method is called once by the board in order to tell every letter how big to
be. Remember, w and h are static, so this affects all Letter instances at once.
static void resize(int w0, int h0) {
w = w0;
h = h0;
}
1114 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
hit( )
The hit( ) method returns true if the xp,yp pair passed in falls inside the bounds of
this Letter.
boolean hit(int xp, int yp) {
return (xp >= x && xp < x + w && yp >= y && yp < y + h);
}
validate( )
The validate( ) method is used to load the fonts to find out how big the letters are,
to decide where to paint them. This information is cached in the private variables
discussed earlier. The results of these calculations are used next in paint( ).
private int font_ascent;
void validate(Graphics g) {
FontMetrics fm;
if (h != lasth) {
font = new Font("SansSerif", Font.BOLD, (int)(h * .6));
g.setFont(font);
fm = g.getFontMetrics();
font_ascent = fm.getAscent();
y0 = (h - font_ascent) * 4 / 10 + font_ascent;
smfont = new Font("SansSerif", Font.BOLD, (int)(h * .3));
g.setFont(smfont);
fm = g.getFontMetrics();
ys0 = y0 + fm.getAscent() / 2;
lasth = h;
}
if (!valid) {
valid = true;
g.setFont(font);
fm = g.getFontMetrics();
w0 = fm.stringWidth(symbol);
g.setFont(smfont);
fm = g.getFontMetrics();
ws0 = fm.stringWidth("" + points);
int slop = w - (w0 + gap + ws0);
x0 = slop / 2;
if (x0 < 1)
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1115
A
P
P
LY
IN
G
JA
V
A
x0 = 1;
xs0 = x0 + w0 + gap;
if (points > 9)
xs0--;
}
}
paint( )
The paint( ) method is called by the board. It passes in an integer, i, which is one of
NORMAL, BRIGHT, or DIM from this class. That is used as an index into the colors
array to select the base color. A sequence of rectangles is filled to create the appearance
of a 3-D highlighted and shadowed button. If points is greater than zero, indicating a
nonblank letter, then the main letter is drawn, and its point value is drawn next to it.
void paint(Graphics g, int i) {
Color c[] = colors[i];
validate(g);
g.setColor(c[NORMAL]);
g.fillRect(x, y, w, h);
g.setColor(c[BRIGHT]);
g.fillRect(x, y, w - 1, 1);
g.fillRect(x, y + 1, 1, h - 2);
g.setColor(Color.black);
g.fillRect(x, y + h - 1, w, 1);
g.fillRect(x + w - 1, y, 1, h - 1);
g.setColor(c[DIM]);
g.fillRect(x + 1, y + h - 2, w - 2, 1);
g.fillRect(x + w - 2, y + 1, 1, h - 3);
g.setColor(Color.black);
if (points > 0) {
g.setFont(font);
g.drawString(symbol, x + x0, y + y0);
g.setFont(smfont);
g.drawString("" + points, x + xs0, y + ys0);
}
}
}
1116 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
ServerConnection.java
The last class in the client side of this applet is ServerConnection, which encapsulates
the communication with the server and our opponent. There are several variables
declared at the beginning of the class. The socket port number to attach to on the server
is 6564. CRLF is the Internet constant string representing end-of-line. The I/O streams
from and to the server are in and out, respectively. The unique ID by which this
connection is known on the server is stored in id. The ID that we are connected to as
an opponent is stored in toid. The Scrabblet applet we are connecting for is scrabblet.
import java.io.*;
import java.net.*;
import java.util.*;
class ServerConnection implements Runnable {
private static final int port = 6564;
private static final String CRLF = "\r\n";
private BufferedReader in;
private PrintWriter out;
private String id, toid = null;
private Scrabblet scrabblet;
ServerConnection( )
The ServerConnection constructor takes the name of an Internet site to attach to and
attempts to open a socket to the right port on that host. If that succeeds, it wraps an
InputStreamReader and a BufferedReader around the input and a PrintWriter around
the output. If the connection fails, an exception is thrown to the caller.
public ServerConnection(Scrabblet sc, String site) throws
IOException {
scrabblet = sc;
Socket server = new Socket(site, port);
in = new BufferedReader(new
InputStreamReader(server.getInputStream()));
out = new PrintWriter(server.getOutputStream(), true);
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1117
A
P
P
LY
IN
G
JA
V
A
readline( )
The readline( ) method is merely a convenience function that converts the IOException
from a readLine( ) into a simple null return.
private String readline() {
try {
return in.readLine();
} catch (IOException e) {
return null;
}
}
setName( ) and delete( )
The setName( ) method tells the server to associate this name with us, and the delete( )
method is used to remove us from any lists the server is keeping.
void setName(String s) {
out.println("name " + s);
}
void delete() {
out.println("delete " + id);
}
setTo( ) and send( )
The setTo( ) method binds the ID of the opponent. Future send( ) calls will go to this
player.
void setTo(String to) {
toid = to;
}
void send(String s) {
if (toid != null)
out.println("to " + toid + " " + s);
}
1118 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
challenge( ), accept( ), chat( ), move( ), turn( ), and quit( )
The following short methods send one-line messages from this client to the server,
which will in turn send those messages on to our opponent. The challenge message is
used to initiate starting a game, and accept is sent in response to a challenge. For each
letter that moves, the move message is sent, and then the turn message is sent at the
end of each turn. If the client quits or leaves the page with the applet on it, it sends the
quit message.
void challenge(String destid) {
setTo(destid);
send("challenge " + id);
}
void accept(String destid, int seed) {
setTo(destid);
send("accept " + id + " " + seed);
}
void chat(String s) {
send("chat " + id + " " + s);
}
void move(String letter, int x, int y) {
send("move " + letter + " " + x + " " + y);
}
void turn(String words, int score) {
send("turn " + score + " " + words);
}
void quit() {
send("quit " + id);  // tell other player
out.println("quit"); // unhook
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1119
A
P
P
LY
IN
G
JA
V
A
start( )
The next method simply starts the thread that manages the client side of the network.
// reading from server...
private Thread t;
void start() {
t = new Thread(this);
t.start();
}
Keywords
The static variables and static block shown here are used to initialize the keys
Hashtable with a mapping between the strings in keystrings and their position in
the array—for example, keys.get(“move”) == MOVE. The lookup( ) method takes
care of unpacking the Integer objects into the right int, with –1 meaning the keyword
was not found.
private static final int ID = 1;
private static final int ADD = 2;
private static final int DELETE = 3;
private static final int MOVE = 4;
private static final int CHAT = 5;
private static final int QUIT = 6;
private static final int TURN = 7;
private static final int ACCEPT = 8;
private static final int CHALLENGE = 9;
private static Hashtable keys = new Hashtable();
private static String keystrings[] = {
"", "id", "add", "delete", "move", "chat",
"quit", "turn", "accept", "challenge"
};
static {
1120 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
for (int i = 0; i < keystrings.length; i++)
keys.put(keystrings[i], new Integer(i));
}
private int lookup(String s) {
Integer i = (Integer) keys.get(s);
return i == null ? -1 : i.intValue();
}
run( )
run( ) is the main loop of the game’s connection to the server. It goes into a blocking
call to readline( ) that will return with a String whenever a line of text comes from the
server. It uses a StringTokenizer to break the line into words. The switch statement
dispatches us to the right code, based on the first word in the input line. Each of the
keywords in the protocol parses the input line differently, and most of them make
method calls back into the Scrabblet class to do their work.
public void run() {
String s;
StringTokenizer st;
while ((s = readline()) != null) {
st = new StringTokenizer(s);
String keyword = st.nextToken();
switch (lookup(keyword)) {
default:
System.out.println("bogus keyword: " + keyword + "\r");
break;
case ID:
id = st.nextToken();
break;
case ADD: {
String id = st.nextToken();
String hostname = st.nextToken();
String name = st.nextToken(CRLF);
scrabblet.add(id, hostname, name);
}
break;
case DELETE:
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1121
A
P
P
LY
IN
G
JA
V
A
scrabblet.delete(st.nextToken());
break;
case MOVE: {
String ch = st.nextToken();
int x = Integer.parseInt(st.nextToken());
int y = Integer.parseInt(st.nextToken());
scrabblet.move(ch, x, y);
}
break;
case CHAT: {
String from = st.nextToken();
scrabblet.chat(from, st.nextToken(CRLF));
}
break;
case QUIT: {
String from = st.nextToken();
scrabblet.quit(from);
}
break;
case TURN: {
int score = Integer.parseInt(st.nextToken());
scrabblet.turn(score, st.nextToken(CRLF));
}
break;
case ACCEPT: {
String from = st.nextToken();
int seed = Integer.parseInt(st.nextToken());
scrabblet.accept(from, seed);
}
break;
case CHALLENGE: {
String from = st.nextToken();
scrabblet.challenge(from);
}
break;
}
}
}
}
1122 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The Server Code
These last two classes are not part of this applet. Rather, they must be installed and
run separately on the web server that the applet classes are to be loaded from. This
will require the security rights to install and run so-called daemon processes on the
web site, which not many people have. Fortunately, most users of this game will not
be setting up their own servers; more likely, they will just play games connected to
existing ones.
Server.java
Server is the main class for the server side of Scrabblet. Once this is installed on the
web server, you have to run it using the command-line Java interpreter for that system,
as shown here:
C:\java\Scrabblet> java Server
Once running, Server will respond with the following message:
Server listening on port 6564
The Server class starts out by declaring a few variables. The port has to be the same
number, 6564, as we saw in ServerConnection. The idcon Hashtable is used to store
all of the connections to all of the clients. We use a hash table rather than an array to
manage frequent insertion and deletion, which require lots of array copying. The id is
incremented for each new connection. This corresponds to the id instance variable we
saw earlier in the client.
import java.net.*;
import java.io.*;
import java.util.*;
public class Server implements Runnable {
private int port = 6564;
private Hashtable idcon = new Hashtable();
private int id = 0;
static final String CRLF = "\r\n";
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1123
A
P
P
LY
IN
G
JA
V
A
addConnection( )
The addConnection( ) method is called every time a new client connects to our applet.
This method creates a new instance of ClientConnection, described next, to manage
the client. It passes in a reference to this Server, the socket the client connected with,
and the current value of id. Finally, it increments the id to have it ready for the next
connection.
synchronized void addConnection(Socket s) {
ClientConnection con = new ClientConnection(this, s, id);
// we will wait for the ClientConnection to do a clean
// handshake setting up its "name" before calling
// set() below, which makes this connection "live."
id++;
}
set( )
The set( ) method is called from ClientConnection in response to the client telling
us its “name.” set( ) tracks all of the connections in the idcon hash table, and first it
removes this id from the table so that it won’t get duplicates if the client sends its
name twice. The method calls setBusy(false) to signify that this connection is available
to play a game. Then it walks through all of the other connections by enumerating the
keys of the idcon hash table. For all nonbusy connections (those players waiting for
an opponent), set( ) sends an “add” protocol message so they will all know about this
connection.
synchronized void set(String the_id, ClientConnection con) {
idcon.remove(the_id) ;  // make sure we're not in there twice.
con.setBusy(false);
// tell this one about the other clients.
Enumeration e = idcon.keys();
while (e.hasMoreElements()) {
String id = (String)e.nextElement();
ClientConnection other = (ClientConnection) idcon.get(id);
if (!other.isBusy())
con.write("add " + other + CRLF);
}
idcon.put(the_id, con);
broadcast(the_id, "add " + con);
}
1124 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
sendto( )
sendto( ) is called in response to a “to” protocol message. It writes whatever is in the
body string directly to the connection identified by dest.
synchronized void sendto(String dest, String body) {
ClientConnection con = (ClientConnection)idcon.get(dest);
if (con != null) {
con.write(body + CRLF);
}
}
broadcast( )
The broadcast( ) method is used to send a single message, in body, to every single
connection except the one identified in exclude (typically, the sender).
synchronized void broadcast(String exclude, String body) {
Enumeration e = idcon.keys();
while (e.hasMoreElements()) {
String id = (String)e.nextElement();
if (!exclude.equals(id)) {
ClientConnection con = (ClientConnection) idcon.get(id);
con.write(body + CRLF);
}
}
}
delete( )
The delete( ) method is used to tell all of the connected clients to forget they ever heard
of the_id. This is used by clients that are engaged in a game to remove themselves from
other players’ eligibility lists.
synchronized void delete(String the_id) {
broadcast(the_id, "delete " + the_id);
}
kill( )
The kill( ) method is called whenever a client explicitly quits, sending the “quit”
message, or when a client simply dies if the browser quits.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1125
A
P
P
LY
IN
G
JA
V
A
synchronized void kill(ClientConnection c) {
if (idcon.remove(c.getId()) == c) {
delete(c.getId());
}
}
run( )
The run( ) method is the main loop of the server. It creates a new socket on port 6564
and goes into an infinite loop accepting socket connections from clients. It calls
addConnection( ) with each socket that it accepts.
public void run() {
try {
ServerSocket acceptSocket = new ServerSocket(port);
System.out.println("Server listening on port " + port);
while (true) {
Socket s = acceptSocket.accept();
addConnection(s);
}
} catch (IOException e) {
System.out.println("accept loop IOException: " + e);
}
}
main( )
main( ) is, of course, the method run by the Java command-line interpreter. It creates a
new instance of Server and launches a new Thread to run it.
public static void main(String args[]) {
new Thread(new Server()).start();
try {
Thread.currentThread().join();
} catch (InterruptedException e) { }
}
}
1126 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
ClientConnection.java
This class is the mirror image of ServerConnection in the applet. One of these is
created for each client. Its job is to manage all of the I/O to and from a client. The
private instance variables hold all of the states about this client. The Socket is stored in
sock. The buffered reader and output streams are stored in in and out. The host name
of the client machine is kept in host. A reference to the Server instance that created this
client is held in server. The name of the player on this client is stored in name, while
the player’s automatically assigned ID number is held in id. The busy Boolean variable
stores whether or not this client is actively engaged in a game.
import java.net.*;
import java.io.*;
import java.util.*;
class ClientConnection implements Runnable {
private Socket sock;
private BufferedReader in;
private OutputStream out;
private String host;
private Server server;
private static final String CRLF = "\r\n";
private String name = null;    // for humans
private String id;
private boolean busy = false;
ClientConnection( )
The constructor saves the reference to the server and socket and remembers the unique
ID. We wrap an InputStreamReader and a BufferedReader around the input so that it
can call readLine( ) on it. Then it writes the id back to the client to let it know what
number it is. Finally, it creates and starts a new Thread to handle this connection.
public ClientConnection(Server srv, Socket s, int i) {
try {
server = srv;
sock = s;
in = new BufferedReader(new
InputStreamReader(s.getInputStream()));
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1127
A
P
P
LY
IN
G
JA
V
A
out = s.getOutputStream();
host = s.getInetAddress().getHostName();
id = "" + i;
// tell the new one who it is...
write("id " + id + CRLF);
new Thread(this).start();
} catch (IOException e) {
System.out.println("failed ClientConnection " + e);
}
}
toString( )
We override toString( ) so that we can have a clean representation of this connection
for logging.
public String toString() {
return id + " " + host + " " + name;
}
getHost( ), getId( ), isBusy( ), and setBusy( )
We wrap host, id, and busy in public methods to allow read-only access.
public String getHost() {
return host;
}
public String getId() {
return id;
}
public boolean isBusy() {
return busy;
}
public void setBusy(boolean b) {
busy = b;
}
1128 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
close( )
The close( ) method is called if the client explicitly quits or if we get an exception
reading from the socket. We call kill( ) in the server, which removes us from any lists.
Then we close the socket, which also closes both the input and output streams.
public void close() {
server.kill(this);
try {
sock.close();   // closes in and out too.
} catch (IOException e) { }
}
write( )
To write a string to a stream, we have to convert it to an array of bytes, using
getBytes( ).
public void write(String s) {
byte buf[];
buf = s.getBytes();
try {
out.write(buf, 0, buf.length);
} catch (IOException e) {
close();
}
}
readline( )
The readline( ) method merely converts the IOException from readLine( ) into a null
return value.
private String readline() {
try {
return in.readLine();
} catch (IOException e) {
return null;
}
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1129
A
P
P
LY
IN
G
JA
V
A
Keywords
This section is very similar to the same part of the ServerConnection class, which
represents the other end of the wire. The static variables and static block shown here
are used to initialize the keys Hashtable with a mapping between the strings in
keystrings and their position in the array—for example, keys.get(“quit”) == QUIT.
The lookup( ) method takes care of unpacking the Integer objects into the right int,
with –1 meaning the keyword was not found.
static private final int NAME = 1;
static private final int QUIT = 2;
static private final int TO = 3;
static private final int DELETE = 4;
static private Hashtable keys = new Hashtable();
static private String keystrings[] = {
"", "name", "quit", "to", "delete"
};
static {
for (int i = 0; i < keystrings.length; i++)
keys.put(keystrings[i], new Integer(i));
}
private int lookup(String s) {
Integer i = (Integer) keys.get(s);
return i == null ? -1 : i.intValue();
}
run( )
run( ) has the loop that manages all of the communication with this client. It uses a
StringTokenizer to parse the input lines, keying off of the first word in each line. The
lookup( ) method just shown is used to look up these first words in the keys hash
table. We then switch, based on the integer value of the keyword. The NAME
message comes from clients when they first gain a human identity. We call set( ) in
the server to get this connection set up. The QUIT message is sent when the client
wants to end its server session. The TO message contains a destination ID and a
message body to be sent to that client. We call sendto( ) in the server to pass the
message along. The last message is DELETE, which is sent by clients that want to
continue being connected but no longer want to have their names listed as available
to play. run( ) sets the busy flag and calls delete( ) in the server, which notifies the
clients that we don’t want to be called.
1130 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public void run() {
String s;
StringTokenizer st;
while ((s = readline()) != null) {
st = new StringTokenizer(s);
String keyword = st.nextToken();
switch (lookup(keyword)) {
default:
System.out.println("bogus keyword: " + keyword + "\r");
break;
case NAME:
name = st.nextToken() +
(st.hasMoreTokens() ? " " + st.nextToken(CRLF) : "");
System.out.println("[" + new Date() + "] " + this + "\r");
server.set(id, this);
break;
case QUIT:
close();
return;
case TO:
String dest = st.nextToken();
String body = st.nextToken(CRLF);
server.sendto(dest, body);
break;
case DELETE:
busy = true;
server.delete(id);
break;
}
}
close();
}
}
Enhancing Scrabblet
This applet represents a complete client/server, multiplayer board game. In the future,
the code in Server and ServerConnection could be extended in many ways. It could be
used to support other turn-based games. It could track and maintain a high-score list
for each game. It could be dynamically extensible to understand new protocol verbs.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1131
A
P
P
LY
IN
G
JA
V
A
One such example for the game described in this chapter would be to have a lookup
function that checked a series of submitted words against a dictionary stored on the
server. The server could then be the arbiter for such disputes as whether xyzy is a valid
word. You could also construct a word robot, which would reside on the server but act
like another player and use the dictionary to generate the best word placement from its
current set of seven letters. It could even use a list of pithy quotes to throw into the chat
window after each move. You might want to try making some of these enhancements
yourself.
This applet is intended for entertainment and educational purposes. Any similarity
to any and all commercial products is merely coincidental.
1132 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Appendix A
Using Java’s
Documentation
Comments
1133
