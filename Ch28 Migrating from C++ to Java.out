Chapter 28
Migrating from C++
to Java
981
This chapter discusses several of the issues that arise when you move from C++to Java. Since many Java programmers come from a C++ background, it is naturalto want to carry over the skills, techniques, and code acquired in this language.
Although C++ and Java were designed to address the programming needs of two
very different environments, many of the same coding techniques, algorithms, and
optimizations apply to both. However, as explained in Part One, Java is not “the
Internet version of C++.” While there are many similarities between the two languages,
there are also several differences. This chapter reviews those differences and shows
ways to handle some of the more challenging ones.
The Differences Between C++ and Java
Before we look at specific situations, let’s review the basic differences between C++
and Java. The differences fall into three categories:
■ C++ features not supported by Java
■ Features unique to Java
■ Shared features which differ between C++ and Java
Each is examined here.
What Java Has Removed from C++
There are a number of C++ features that Java does not support. In some cases, a
specific C++ feature simply didn’t relate to the Java environment. In other cases, the
designers of Java eliminated some of the duplication of features that exists in C++. In
still other instances, a feature of C++ is not supported by Java because it was deemed
too dangerous for Internet applets.
Perhaps the single biggest difference between Java and C++ is that Java does not
support pointers. As a C++ programmer you know that the pointer is one of C++’s
most powerful and important language features. It is also one of its most dangerous
when used improperly. Pointers don’t exist in Java for two reasons:
■ Pointers are inherently insecure. For example, using a C++-style pointer, it is
possible to gain access to memory addresses outside a program’s code and
data. A malicious program could make use of this fact to damage the system,
perform unauthorized accesses (such as obtaining passwords), or otherwise
violate security restrictions.
982 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
■ Even if pointers could be restricted to the confines of the Java run-time system
(which is theoretically possible), the designers of Java believed that they were
inherently troublesome.
Since pointers don’t exist in Java, neither does the -> operator.
Here are a few more of the most important “omissions”:
■ Java does not include structures or unions. These were felt to be redundant
since the class encompasses them.
■ Java does not support operator overloading. Operator overloading is sometimes
a source of ambiguity in a C++ program, and the Java design team felt that it
causes more trouble than benefit.
■ Java does not include a preprocessor nor does it support the preprocessor
directives. The preprocessor plays a less important role in C++ than it does
in C. The designers of Java felt that it was time to eliminate it entirely.
■ Java does not perform any automatic type conversions that result in a loss of
precision. For example, a conversion from long integer to integer must be
explicitly cast.
■ All the code in a Java program is encapsulated within one or more classes.
Therefore, Java does not have what you normally think of as global variables
or global functions.
■ Java does not allow default arguments. In C++, you may specify a value
that a parameter will have when there is no argument corresponding to
that parameter when the function is invoked. This is not allowed in Java.
■ Java does not support the inheritance of multiple superclasses by a subclass.
■ Although Java supports constructors, it does not have destructors. It does,
however, add the finalize( ) function.
■ Java does not support typedef.
■ It is not possible to declare unsigned integers in Java.
■ Java does not allow the goto.
■ Java does not have the delete operator.
■ The << and >> in Java are not overloaded for I/O operations.
■ In Java, objects are passed by reference only. In C++, objects may be passed by
value or by reference.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 983
984 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
New Features Added by Java
There are a number of features in Java that have no equivalent in C++. Perhaps the
three most important are multithreading, packages, and interfaces, but there are
several others that enrich the Java programming environment as well.
■ As explained earlier, multithreading allows two or more pieces of the same
program to execute concurrently. Further, this approach to concurrence is
supported at the language level. There is no parallel for this in C++. If you
need to multithread a C++ program, you will need to do so manually, using
operating system functions. While both methods allow for concurrent execution
of two or more threads, Java’s approach is cleaner and easier to use.
■ There is no feature in C++ that directly corresponds to a Java package. The
closest similarity is a set of library functions that use a common header file.
However, constructing and using a library in C++ is completely different from
constructing and using a package in Java.
■ The Java interface is somewhat similar to a C++ abstract class. (An abstract class
in C++ is a class that contains at least one pure virtual function.) For example, it
is impossible to create an instance of a C++ abstract class or a Java interface.
Both are used to specify a consistent interface that subclasses will implement.
The main difference is that an interface more cleanly represents this concept.
■ Java has a streamlined approach to memory allocation. Like C++, it supports
the new keyword. However, it does not have delete. Instead, when the last
reference to an object is destroyed, the object, itself, is automatically deleted the
next time that garbage collection occurs.
■ Java “removes” the C++ standard library, replacing it with its own set of API
classes. While there is substantial functional similarity, there are significant
differences in the names and parameters. Also, since all of the Java API library
is object-oriented, and only a portion of the C++ library is, there will be
differences in the way library routines are invoked.
■ The break and continue statements have been enhanced in Java to accept labels
as targets.
■ The char type in Java declares 16-bit-wide Unicode characters. This makes
them similar to C++’s wchar_t type. The use of Unicode helps ensure
portability.
■ Java adds the >>> operator, which performs an unsigned right shift.
■ In addition to supporting single-line and multiline comments, Java adds a third
comment form: the documentation comment. Documentation comments begin
with a /** and end with a */.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 985
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
■ Java contains a built-in string type called String. String is somewhat similar
to the standard string class type provided by C++. Of course, in C++ string is
only available if you include its class declarations in your program. It is not a
built-in type.
Features That Differ
There are some features common to both C++ and Java that each language handles a
bit differently:
■ While both C++ and Java support a Boolean data type, Java does not implement
true and false in the same way as C++. In C++, true is any nonzero value. False
is zero. In Java, true and false are predefined literals, and these are the only
values that a boolean expression may have. While C++ also defines true and
false, which may be assigned to a bool variable, C++ automatically converts
nonzero values into true and zero values into false. This does not occur in Java.
■ When you create a C++ class, the access specifiers apply to groups of
statements. In Java, access specifiers apply only to the declarations that they
immediately precede.
■ C++ supports exception handling that is fairly similar to Java’s. However,
in C++ there is no requirement that a thrown exception be caught.
With these additions, deletions, and differences as a backdrop, the rest of this
chapter will look closely at a few of the key issues that you must deal with when
converting code from C++ to Java.
Eliminating Pointers
When you convert a C++ program into Java, perhaps the greatest number of changes
will be caused by pointers. Most C++ code is heavily dependent upon pointers for its
operation. You can’t program anything very significant in C++ without using a pointer.
There are four general categories of pointer usage that you will encounter in
C++ code:
■ As parameters to functions. Although C++ supports the reference parameter,
there is a large base of legacy code that was originally written in C. C does not
support reference parameters. In C, if a function needs to change the value of an
argument, it is necessary to explicitly pass a pointer to that argument. Therefore,
it is still common to find pointer parameters used in C++ code that was originally
ported from C. Also, in some cases the same function library will need to be
shared by both C and C++ code, which prevents the use of reference parameters.
986 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Additionally, many of the standard library functions supported by C++ are
holdovers from C. When one of these C-based functions requires the address
of an argument, a pointer to the argument is used. Inside the function, the
argument is then accessed through its pointer.
■ To provide a more efficient means of implementing certain constructs—
especially array indexing. For example, it is often more efficient to sequentially
move through an array using a pointer rather than an array index. While modern
compilers implement highly efficient optimizations, pointers can still provide a
significant performance boost. Thus, the use of pointers to access arrays is
ubiquitous in C++ code.
■ To support memory allocation. In C++, when you allocate memory, an
address (that is, a pointer) to that memory is returned. This address must be
assigned to a pointer variable. Once this has been done, the pointer can point to
any part of the allocated memory—or anywhere else, for that matter—by means
of pointer arithmetic. In Java, when an object is allocated by new, a reference to
the object is returned. This reference must be assigned to a reference variable of
a compatible type. While Java reference variables do implicitly point to the
object that was allocated by the new operator, they cannot be manipulated in
the same way as C++ pointers. And they cannot point to memory outside of the
Java run-time context.
■ To provide access to any arbitrary machine address, possibly to call a ROM
routine or to read/write directly to memory. Since Java purposely disallows
such actions, this use of pointers has no direct parallel. If you are writing
applications, not applets, you can always use Java’s native capabilities
(described in Part One) to gain access to native code routines that would
be allowed access to such system resources.
Let’s look at two situations in which pointer-based C++ code is converted to Java.
Converting Pointer Parameters
For the most part, it is quite easy to convert a C++ function that uses pointer
parameters into its equivalent Java method. Since Java passes all objects by reference,
sometimes the conversion simply requires the removal of C++’s pointer operators. For
example, consider this C++ program that reverses the signs of a Coord object, which
stores a pair of Cartesian coordinates. The function reverseSign( ) is passed a pointer
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 987
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
to the Coord object that will be reversed. As you can see, C++’s *, &, and -> pointer
operators are used to perform the operation.
// Reverse the signs of a coordinate - C++ version.
#include <iostream>
using namespace std;
class Coord {
public:
int x;
int y;
};
// Reverse the sign of the coordinates.
void reverseSign(Coord *ob) {
ob->x = -ob->x;
ob->y = -ob->y;
}
int main()
{
Coord ob;
ob.x = 10;
ob.y = 20;
cout << "Original values for ob: ";
cout << ob.x << ", " << ob.y << "\n";
reverseSign(&ob);
cout << "Sign reversed values for ob: ";
cout << ob.x << ", " << ob.y << "\n";
return 0;
}
988 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
This program can be recoded into the following Java version. As you can see, most
of the conversion involves the deletion of the C++ pointer operators. Since Java passes
objects by reference, changes to the parameter automatically affect the argument.
// Reverse the signs of a coordinate - Java version.
class Coord {
int x;
int y;
};
class DropPointers {
// Reverse the sign of the coordinates.
static void reverseCoord(Coord ob) {
ob.x = -ob.x;
ob.y = -ob.y;
}
public static void main(String args[]) {
Coord ob = new Coord();
ob.x = 10;
ob.y = 20;
System.out.println("Original values for ob: " +
ob.x + ", " + ob.y);
reverseCoord(ob);
System.out.println("Sign reversed values for ob: " +
ob.x + ", " + ob.y);
}
}
The output from both of these programs is the same and is shown here:
Original values for ob: 10, 20
Sign reversed values for ob: -10, -20
Converting Pointers that Operate on Arrays
Conceptually, converting C++-style pointer-based array accessing into the equivalent
Java-compatible array indexing is straightforward—simply substitute the appropriate
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 989
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
array-indexing statements. However, in practice this may require some thought.
Pointer-based array accessing can be a bit difficult to follow, because the normal C++
coding style encourages rather dense, complex expressions. For example, this short
C++ program copies the contents of one array to another. It uses 0 to mark the end of
the arrays. Pay special attention to the pointer expressions. Even in this simple example,
if you did not know that this program copied the contents of nums to copy (and later
displayed the arrays), it would require some careful thought before you were completely
sure that you knew what the code was doing.
// Copy an array in C++ using pointers.
#include <iostream>
using namespace std;
int main()
{
int nums[] = {10, 12, 24, 45, 23, 19, 44,
88, 99, 65, 76, 12, 89, 0};
int copy[20];
int *p1, *p2; // integer pointers
// copy array
p1 = nums; // p1 points to start of nums array
p2 = copy;
while(*p1) *p2++ = *p1++;
*p2 = 0; // terminate copy with zero
// Display contents of each array.
cout << "Here is the original array:\n";
p1 = nums;
while(*p1) cout << *p1++ << " ";
cout << endl;
cout << "Here is the copy:\n";
p1 = copy;
while(*p1) cout << *p1++ << " ";
cout << endl;
return 0;
}
990 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Even though it is quite simple for C++ code, at first glance the line
while(*p1) *p2++ = *p1++;
still requires a moment of thought to decipher its exact operation. One of the
advantages of Java is that it does not encourage the creation of such expressions
in the first place. Here is the Java version of the program. As you can see, its purpose
and effects are transparent.
// Array copy without pointers using Java.
class CopyArray {
public static void main(String args[]) {
int nums[] = {10, 12, 24, 45, 23, 19, 44,
88, 99, 65, 76, 12, 89, 0};
int copy[] = new int[14];
int i;
// copy array
for(i=0; nums[i]!=0; i++)
copy[i] = nums[i];
nums[i] = 0; // terminate copy with zero
// Display contents of each array.
System.out.println("Here is the original array:");
for(i=0; nums[i]!=0; i++)
System.out.print(nums[i] + " ");
System.out.println();
System.out.println("Here is the copy:");
for(i=0; nums[i]!=0; i++)
System.out.print(copy[i] + " ");
System.out.println();
}
}
Both versions of the program produce the following results:
Here is the original array:
10 12 24 45 23 19 44 88 99 65 76 12 89
Here is the copy:
10 12 24 45 23 19 44 88 99 65 76 12 89
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 991
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Much C++ code is sprinkled with obscure, difficult to understand pointer expressions.
While these expressions do tend to increase speed of execution, they are one of the
most troubling issues associated with the maintenance of C++ programs. They will also
present difficulty when you convert the code to Java. When you are confronted with a
complex pointer expression, it is sometimes useful to begin by breaking it into its
subexpressions so that its exact operation becomes clear.
C++ Reference Parameters Versus Java
Reference Parameters
In the preceding section, you saw an example of a C++ program that used a pointer
parameter. In Java, this became a reference parameter. Of course, C++ also supports
reference parameters. As mentioned, most pointer parameters found in C++ code
are simply holdovers from C. Nearly all new C++ code will use reference parameters
when a function needs access to the argument, itself. (In essence, pointer parameters,
although still common, are actually anachronisms in most C++ code.) Since both Java
and C++ support reference parameters, you might think that the conversion of a C++
function that uses reference parameters to a Java method would involve few changes.
Unfortunately, this is not always the case. To understand why, let’s convert the
following C++ program, which swaps the contents of two Coord objects using
reference parameters:
// Swap coordinates -- C++ version.
#include <iostream>
using namespace std;
class Coord {
public:
int x;
int y;
};
// Swap contents of two Coord objects.
void swap(Coord &a, Coord &b) {
Coord temp;
// swap contents of objects
temp = a;
a = b;
b = temp;
}
992 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
int main()
{
Coord ob1, ob2;
ob1.x = 10;
ob1.y = 20;
ob2.x = 88;
ob2.y = 99;
cout << "Original values:\n";
cout << "ob1: " << ob1.x << ", " << ob1.y << "\n";
cout << "ob2: " << ob2.x << ", " << ob2.y << "\n";
cout << "\n";
swap(ob1, ob2);
cout << "Swapped values:\n";
cout << "ob1: " << ob1.x << ", " << ob1.y << "\n";
cout << "ob2: " << ob2.x << ", " << ob2.y << "\n";
return 0;
}
Following is the output produced by this program. As you can see, the contents of
ob1 and ob2 have been exchanged:
Original values:
ob1: 10, 20
ob2: 88, 99
Swapped values:
ob1: 88, 99
ob2: 10, 20
In Java, all objects are accessed via an object reference variable. Thus, when an
object is passed to a method, only its reference is passed. This means that all objects
are automatically passed by reference to a Java method. Without thinking any deeper
about what is actually occurring, someone might initially try the following (incorrect)
conversion of the preceding program:
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 993
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
// Swap program incorrectly converted to Java.
class Coord {
int x;
int y;
};
class SwapDemo {
static void swap(Coord a, Coord b) {
Coord temp = new Coord();
// this won't swap contents of a and b!
temp = a;
a = b;
b = temp;
}
public static void main(String args[]) {
Coord ob1 = new Coord();
Coord ob2 = new Coord();
ob1.x = 10;
ob1.y = 20;
ob2.x = 88;
ob2.y = 99;
System.out.println("Original values:");
System.out.println("ob1: " +
ob1.x + ", " + ob1.y);
System.out.println("ob2: " +
ob2.x + ", " + ob2.y + "\n");
swap(ob1, ob2);
System.out.println("Swapped values:");
System.out.println("ob1: " +
ob1.x + ", " + ob1.y);
System.out.println("ob2: " +
ob2.x + ", " + ob2.y + "\n");
}
}
994 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The output produced by this incorrect program is shown here:
Original values:
ob1: 10, 20
ob2: 88, 99
Swapped values:
ob1: 10, 20
ob2: 88, 99
As you can see, the values of ob1 and ob2 in main( ) have not been exchanged!
Although a bit counterintuitive at first, the reason is actually obvious, once you
understand precisely what happens when an object reference is passed to a method.
Java passes all arguments to methods using call-by-value. This means that a copy of the
argument is made, and what occurs to the copy inside the method has no effect on the
argument used to call the method. However, this situation is blurred a bit in the case of
object references.
When an object reference is passed to a method, a copy of the reference variable is
made, as just explained. This means that the parameter inside the method will refer to
the same object as does the reference variable used as an argument outside the method.
Therefore, operations on the object through the parameter will affect the object referred
to by the argument (since they are one and the same). But operations on the reference
parameter, itself, affect only that parameter. Thus, when the preceding program attempts
to swap the objects by exchanging the objects pointed to by a and b, all that is happening
is that the parameters (that is, the copies of the arguments) are exchanging what they
are referring to, but this does not alter what ob1 and ob2 refer to back in main( ).
To fix the program, swap( ) needs to be rewritten so that the contents of the objects
are exchanged, not what the parameters refer to. Here is the corrected version of swap( ):
// Corrected version of swap().
static void swap(Coord a, Coord b) {
Coord temp = new Coord();
// swap contents of objects
temp.x = a.x;
temp.y = a.y;
a.x = b.x;
a.y = b.y;
b.x = temp.x;
b.y = temp.y;
}
If you substitute this version of swap( ) into the preceding program, the correct results
will be achieved.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 995
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Converting C++ Abstract Classes into
Java Interfaces
One of the most innovative aspects of Java is the interface. As explained earlier in this
book, an interface specifies the form of its various methods without specifying any
implementation details. Each class that implements an interface does so by creating
the actual methods declared by the interface. Thus, in Java an interface is the means
by which you can define the general form of a class while ensuring that all specific
versions of the class conform to the same set of rules. The interface is one of the ways
that Java provides support for polymorphism.
In C++, there is no direct parallel to the interface. Instead, in C++, if you wish to
define the form of a class without defining implementation details, you must do so by
using an abstract class. Abstract classes in C++ are similar to abstract classes in Java:
they do not contain a full set of implementation details. In C++, an abstract class contains
at least one pure virtual function. A pure virtual function defines no implementation; it
only defines the function prototype. Thus, a pure virtual function in C++ is essentially
the same as an abstract method in Java. In C++, abstract classes serve a function similar
to interfaces in Java. For this reason, they are one of the items that you will want to
watch for when converting code to Java. While not all C++ abstract classes can be
converted into Java interfaces, many can. Let’s look at two examples.
Here is a short C++ program that uses an abstract class called IntList to define the
form of an integer list. An implementation of this class is created by IntArray, which
uses an array to implement a list of integers.
// A C++-style abstract class and its implementation.
#include <iostream>
#include <cstdlib>
using namespace std;
// An abstract class that defines the form of an integer list.
class IntList {
public:
virtual int getNext() = 0; // pure virtual functions
virtual void putOnList(int i) = 0;
};
// Create an implementation of an integer list.
class IntArray : public IntList {
int storage[100];
int putIndex, getIndex;
public:
IntArray() {
putIndex = 0;
getIndex = 0;
996 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}
// Return next integer in list.
int getNext() {
if(getIndex >= 100) {
cout << "List Underflow";
exit(1);
}
getIndex++;
return storage[getIndex-1];
}
// Put an integer on the list.
void putOnList(int i) {
if(putIndex < 100) {
storage[putIndex] = i;
putIndex++;
}
else {
cout << "List Overflow";
exit(1);
}
}
};
int main()
{
IntArray nums;
int i;
for(i=0; i<10; i++) nums.putOnList(i);
for(i=0; i<10; i++)
cout << nums.getNext() << endl;
return 0;
}
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 997
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
In this program, the abstract class IntList defines only the form of an integer list. It
contains only pure virtual functions and does not declare any data. For these reasons, it
can be made into an interface when the program is converted into Java, as shown here:
// Here, IntList is made into an interface which IntArray implements.
// Define interface for an integer list.
interface IntListIF {
int getNext();
void putOnList(int i);
}
// Create an implementation of an integer list.
class IntArray implements IntListIF {
private int storage[];
private int putIndex, getIndex;
IntArray() {
storage = new int[100];
putIndex = 0;
getIndex = 0;
}
// Create an implementation of an integer list.
public int getNext() {
if(getIndex >= 100) {
System.out.println("List Underflow");
System.exit(1);
}
getIndex++;
return storage[getIndex-1];
}
// Put an integer on the list.
public void putOnList(int i) {
if(putIndex < 100) {
storage[putIndex] = i;
putIndex++;
}
else {
System.out.println("List Overflow");
System.exit(1);
}
}
}
class ListDemo {
public static void main(String args[]) {
IntArray nums = new IntArray();
int i;
for(i=0; i<10; i++) nums.putOnList(i);
for(i=0; i<10; i++)
System.out.println(nums.getNext());
}
}
As you can see, there is nearly a one-to-one correspondence between the C++ abstract
class IntList and the Java interface IntListIF. It is possible to convert IntList into
IntListIF because it contained only pure virtual functions. This is the key. If IntList had
contained any data or function implementations, then it would not have qualified for
conversion into an interface.
When you convert or adapt C++ code into Java, look for examples of abstract
classes that contain only pure virtual functions. These are prime candidates for
conversion to Java interfaces. But don’t overlook abstract C++ classes that contain a
small number of implemented functions or data. It is possible that these items don’t
really belong in the abstract class to begin with and should be defined by individual
implementations. Since C++ does not define an interface construct, there was no reason
for C++ programmers to think in terms of one.
Sometimes a concrete member is contained in an otherwise abstract class simply for
expedience—not because it is the most logical place for it. For example, consider the
following abstract C++ class:
// An abstract C++ class.
class SomeClass {
bool isOK;
public:
virtual int f1() = 0;
virtual void f2(int i) = 0;
virtual double f3() = 0;
virtual int f4(int a, char ch) = 0;
};
998 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 999
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
The only reason that this class cannot be made into a Java interface is the existence
of isOK. Presumably, isOK is used to indicate some status associated with the class.
However, if you think about it, there really is no reason for isOK to be defined as a
variable. Instead, you could specify a method called isOK( ) that returns the status.
In this approach, isOK( ) will be defined, along with the other methods, by any
implementing class. Thus, you could convert the preceding C++ abstract class into
the following Java interface:
interface SomeClass {
int f1();
void f2(int i);
double f3();
int f4(int a, char ch);
boolean isOK();
}
Many abstract classes in C++ can—and should—be converted into interfaces when
you move code to Java. In doing so, you will probably find that it clarifies the structure
of the class hierarchy.
Converting Default Arguments
One extensively used feature of C++ that Java does not support is default function
arguments. For example, the area( ) function shown in the following C++ program
computes the area of a rectangle if called with two arguments, or the area of a square
if called with one argument.
// C++ program that uses default arguments.
#include <iostream>
using namespace std;
/* Compute area of a rectangle.  For a square,
pass only one argument.
*/
double area(double l, double w=0) {
if(w==0)  return l * l;
else return l * w;
}
int main()
{
cout << "Area of 2.2 by 3.4 rectangle: ";
cout << area(2.2, 3.4) << endl;
1000 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
cout << "Area of 3.0 by 3.0 square: ";
cout << area(3.0) << endl;
return 0;
}
As you can see, when area( ) is called with only one argument, the second defaults to
zero. When this happens, the function simply uses the first argument for both the
length and the width of the rectangle.
While convenient, default arguments are not, of course, necessary. In essence,
default arguments are actually a shorthand form of function overloading in which one
form of the function has a different number of parameters than the other. Thus, to
convert a C++ function that contains one or more default arguments into Java, simply
create overloaded methods that handle each case. In this example, you need a version
of area( ) that takes two arguments and another that takes only one argument. Using
this approach, here is the preceding program rewritten for Java:
// Java version of area program.
class Area {
// Compute area of a rectangle.
static double area(double l, double w) {
if(w==0)  return l * l;
else return l * w;
}
// Overload area( ) for a square.
static double area(double l) {
return l * l;
}
public static void main(String args[]) {
System.out.println("Area of 2.2 by 3.4 rectangle: " +
area(2.2, 3.4));
System.out.println("Area of 3.0 by 3.0 square: " +
area(3.0));
}
}
Converting C++ Multiple-Inheritance
Hierarchies
C++ allows one class to inherit two or more base classes at the same time. Java does
not. To understand the difference, consider the two hierarchies depicted here:
In both cases, subclass C inherits classes A and B. However, in the hierarchy on the left,
C inherits both A and B at the same time. In the one on the right, B inherits A, and C
inherits B. By not allowing the inheritance of multiple base classes by a single subclass,
Java greatly simplifies the inheritance model. Multiple inheritance carries with it
several special cases that must be handled. This adds overhead to both the compiler
and the run-time system, while providing only marginal benefit for the programmer.
Since C++ supports multiple inheritance and Java does not, you may have to deal
with this issue when porting C++ applications to Java. While every situation is
different, two general pieces of advice can be offered. First, in many cases, multiple
inheritance is employed in a C++ program when there is actually no need to do so.
When this is the case, just convert the class structure to a single-inheritance hierarchy.
For example, consider this C++ class hierarchy that defines a class called House:
class Foundation {
// ...
};
class Walls {
// ...
};
class Rooms {
// ...
};
class House : public Foundation, Walls, Rooms {
// ...
};
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 1001
Notice that House multiply inherits Foundation, Walls, and Rooms. While there is
nothing wrong with structuring a C++ hierarchy like this, it is not necessary. For
example, here is the same set of classes structured for Java:
class Foundation {
// ...
}
class Walls extends Foundation {
// ...
}
class Rooms extends Walls {
// ...
}
class House extends Rooms {
// ...
}
Here, each class extends the preceding one, with House becoming the final extension.
Sometimes a multiple inheritance hierarchy is more readily converted by including
objects of the multiply inherited classes in the final object. For example, here is another
way that House could be constructed in Java:
class Foundation {
// ...
}
class Walls{
// ...
}
class Rooms {
// ...
}
/* Now, House includes Foundation, Walls, and Rooms
as object members.
*/
1002 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
class House {
Foundation f;
Walls w;
Rooms r;
// ...
}
Here, Foundation, Walls, and Rooms are objects that are part of House rather than
inherited by House.
One other point: sometimes a C++ program will contain a multiple-inheritance
hierarchy simply because of poor initial design. A good time to correct this type of
design flaw is when you port to Java.
Destructors Versus Finalization
When you move from C++ to Java, one of the more subtle, yet important issues you
will face is the difference between a C++ destructor and a Java finalize( ) method.
Although similar in many respects, their actual operation is distinctively different.
Let’s begin by reviewing the purpose and effect of a C++ destructor and the Java
finalize( ) method.
In C++, when an object goes out of scope, it is destroyed. Just prior to its destruction,
its destructor function is called (if it has one). This is a hard-and-fast rule. There are no
exceptions. Let’s look more closely at each part of this rule:
■ Every object is destroyed when it goes out of scope. Thus, if you declare a
local object inside a function, when that function returns, that local object is
automatically destroyed. The same goes for function parameters and for objects
returned by functions.
■ Just before destruction, the object’s destructor is called. This happens
immediately, and before any other program statements will execute. Thus, a
C++ destructor will always execute in a deterministic fashion. You can always
know when and where a destructor will be executed.
In Java, the tight linkage of the destruction of an object and the calling of its
finalize( ) method does not exist. In Java, objects are not explicitly destroyed when
they go out of scope. Rather, an object is marked as unused when there are no longer
any references pointing to it. Even then, the finalize( ) method will not be called until
the garbage collector runs. Thus, you cannot know precisely when or where a call to
finalize( ) will occur. Even if you execute a call to gc( ) (the garbage collector), there is
no guarantee that finalize( ) will immediately be executed.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 1003
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
While the deterministic behavior of a C++ constructor and the somewhat
probabilistic aspect of finalization are of little concern in most cases, they will have
an impact on others. For example, consider the following C++ program:
// This C++ program can call f() indefinitely.
#include <iostream>
#include <cstdlib>
using namespace std;
const int MAX = 5;
int count = 0;
class X {
public:
// constructor
X() {
if(count<MAX) {
count++;
}
else  {
cout << "Error -- can't construct";
exit(1);
}
}
// destructor
~X() {
count--;
}
};
void f()
{
X ob; // allocate an object
// destruct on way out
}
int main()
{
int i;
for(i=0; i < (MAX*2); i++) {
f();
1004 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
cout << "Current count is: " << count << endl;
}
return 0;
}
Here is the output generated by this program:
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Look carefully at the constructor and destructor for X. The constructor increments
the value of count as long as count is less than MAX. The destructor decrements count.
Thus, count is incremented when an X object is created and decremented when an X
object is destroyed. But no more than MAX objects can exist at any one time. However,
in main( ), f( ) is called MAX*2 times without causing an error! Here is why. Inside f( ),
an object of type X is created, causing count to be incremented, and then the function
returns. This causes the object to immediately go out of scope and its destructor to be
called, which decrements count. Thus, calling f( ) has no net effect on the value of
count. This means that it can be called indefinitely. However, this is not the case when
this program is converted to Java.
Here is the Java version of the preceding program:
// This Java program will fail after 5 calls to f().
class X {
static final int MAX = 5;
static int count = 0;
// constructor
X() {
if(count<MAX) {
count++;
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 1005
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
}else  {
System.out.println("Error -- can't construct");
System.exit(1);
}
}
// finalization
protected void finalize() {
count--;
}
static void f()
{
X ob = new X(); // allocate an object
// destruct on way out
}
public static void main(String args[]) {
int i;
for(i=0; i < (MAX*2); i++) {
f();
System.out.println("Current count is: " + count);
}
}
}
This program will fail after five calls to f( ), as this output shows:
Current count is: 1
Current count is: 2
Current count is: 3
Current count is: 4
Current count is: 5
Error — can’t construct
The reason the program fails is that garbage collection does not occur each time f( )
returns. Thus, finalize( ) is not invoked, and the value of count is not decremented.
After five calls to the method, count reaches its maximum value and the program fails.
1006 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
It is important to emphasize that precisely when garbage collection occurs is
implementation dependent. It is possible that for some implementation of Java, on
some platform, the preceding program will function similarly to its C++ version.
However, the point of the example remains: In C++, you know when and where a
destructor will be called. In Java, you do not know when or where finalize( ) will be
executed. Therefore, when porting code from C++ to Java, you will need to watch for
instances in which the precise timing of the execution of a destructor is relied upon.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 1007
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
This page intentionally left blank.
Part IV
Applying Java
This page intentionally left blank.
Chapter 29
The DynamicBillboard
Applet
1011
Robert Temple is a software engineer who has designed several highly used applets.His work includes the ESPNET SportsZone “HitCharts” and “Batter vs. Pitcher”applets. One of his most impressive applets is DynamicBillboard, which he wrote
while he was at Embry-Riddle Aeronautical University in Florida.
The DynamicBillboard applet displays a sequence of images by repeatedly
changing the image on the screen to another after a period of time. The transition
between one image and the next is done with one of a variety of special effects. One
example of a transition is the SmashTransition, where the new image drops down
from above the old image and appears to smash the old image out of place. The applet
links to other pages through a URL associated with each image. When the user presses
the mouse button with the cursor over the applet, the browser will go to the new page
associated with the current image. The DynamicBillboard applet provides web sites
with an elegant way to rotate ads, banners, or billboards on a single static page.
Robert has included many interesting optimizations. This applet would not be
functional without the careful changes that he crafted. There are enough tips and tricks
in this source code to help you make your applets really fly.
The APPLET Tag
The APPLET tag for DynamicBillboard is fairly easy to configure. You name the main
class in the code parameter and specify the width and height, as with most applets:
<applet code=DynamicBillboard width=392 height=72>
There are several parameters that must be specified for the applet to function
properly. Without them the applet does nothing. Also, you will notice that if you make
any mistakes naming files and such, the behavior is a little unfriendly: either nothing
happens or some of your billboards will be blank. The following parameters are
specified as:
<param name=parameter_name value="your value here">
■ bgcolor This parameter is used to set the background color of the applet
before the first image loads. You can use this to get rid of the gray applet
square quickly.
■ delay This parameter specifies the number of milliseconds between
each billboard. Typically, it’s a number like 5000 or 10000, meaning five or
ten seconds.
1012 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
■ billboards This parameter specifies the number of billboards you wish to
cycle through.
■ bill# This is shorthand for bill0, bill1, bill2, and so on, up to one less than the
number of billboards you’ve specified. (Robert is a typical programmer who
starts counting at 0.) You will have as many of these as you specified in the
billboards parameter. The value of each of these bill#s will be a pair of strings
separated by a comma. The first one is the image name to display for this
billboard. The second is the URL of where to go when the user clicks on this
billboard. Here is an example:
<param name="bill0" value="sample.jpg,http://www.example.com/">
■ transitions This is a list beginning with the number of items in the list as an
integer, followed by the list of Transition subclass names. Here is an example:
<param name="transitions" value="2,TearTransition,SmashTransition">
Here is an example of a complete APPLET tag with all of the transitions discussed
in this chapter:
<applet code=DynamicBillboard width=392 height=72>
<param name="bgcolor" value="#ffffff">
<param name="delay" value="5000">
<param name="billboards" value="5">
<param name="bill0"
value="board1.jpg,http://www.someURL">
<param name="bill1"
value="board2.jpg,http://www.someURL">
<param name="bill2"
value="board3.jpg,http://www.someURL">
<param name="bill3"
value="board4.jpg,http://www.someURL">
<param name="bill4"
value="board5.jpg,http://www.someURL">
<param name="transitions"
value="5,ColumnTransition,FadeTransition,TearTransition,
SmashTransition,UnrollTransition">
</applet>
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1013
A
P
P
LY
IN
G
JA
V
A
Source Code Overview
Robert designed the applet with a fast load time in mind. He tries to keep the size of
the applet to a minimum so that there is less code to send across the network. He also
attempts to delay some of the loading and initializing of the applet until after the first
image is displayed. As far as the user is concerned, the applet is running after the first
image is fully displayed, even though there is a lot more work to be done.
The applet consists of three main classes and any number of transition classes.
The three main classes are DynamicBillboard, BillData, and BillTransition. The
DynamicBillboard class is a top-level Applet subclass that uses all of the other classes.
The BillData class encapsulates a number of billboard attributes, including the image
and the URL associated with the image. The BillTransition class is an abstract class
that contains methods and attributes common to all transitions. The three main classes
are described next, along with five popular transitions.
DynamicBillboard.java
This is the main applet class. It implements Runnable to include a thread that
controls the continuous process of creation and animation of the transitions.
The transition_classes array stores the names of the transition classes as strings.
It uses strings because it loads these classes dynamically using the method
java.lang.Class.forName(String). This allows the applet to put off the loading of
these classes until they are first instantiated.
init( )
The init( ) method is called automatically when the applet is first loaded. Most applets
use this method to perform all of their necessary initialization. Robert, however,
decided to separate his initialization into two methods: init( ) and finishInit( ). The
idea behind splitting up the initialization is to try to display the first image within the
applet in the least amount of time, minimizing the time that the applet is showing a
blank rectangle while it is loading and initializing. The only processing that is done
in this init( ) method is that which is absolutely necessary to get initial content to the
screen, because the browser will not call paint( ) until after init( ) returns.
The first thing that Robert does with init( ) is to change the background color of the
applet and the parent frame in which the applet is embedded. In the past, the space
that an applet uses on the screen was shown as a solid gray box while the applet was
loading and initializing. This box would tend to stand out on pages that use a background
color other than gray, which is just about every page created since 1994. Robert discovered
a way around this problem. He found that applets always have a parent container in
which they are embedded. Under both Netscape Navigator and Internet Explorer, this
container is derived from the core Java class: java.awt.Container. Robert uses the
methods inherited from java.awt.Component—setBackground( ) and repaint( )—to
change the background color to the value of a bgcolor applet parameter. This makes
1014 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
the applet space stand out less than it does when it is gray. All this is done even before
the applet begins to load the first image.
With newer browsers, this frame no longer defaults to gray but rather uses the
background color of the page. Thus, today applets will not benefit from changing the
background color. However, this appoach still illustrates an interesting technique,
which you can adapt for other purposes.
After changing background colors, Robert’s applet reads in a parameter that tells
how many different billboards there will be and then allocates an array of BillData
objects based on this parameter.
With the help of Math.random( ), a random billboard is chosen to start.
parseBillData( ) is called to parse the parameters for this billboard.
parseBillData( )
This method creates and initializes the next billboard (BillData) object that the applet
will use. It only gets called if the billboard object has not been created yet (the element
corresponding to the next billboard object in the billboard array will be null).
Normally, parseBillData( ) calls the BillData method initPixels( ) after creating
the new object to initialize a pixel array within the BillData object. The first time this
method is called, however, the applet is still concentrating on getting the first image to
the screen as fast as possible. It knows this because the reference to the image that is
used to paint the applet is still null. So instead it sets the image variable and waits to
call the processor-intensive initPixel( ) method until after the first image is loaded.
finishInit( )
After the first image is displayed on the screen, the applet can finish the rest of its
initialization. This includes initializing the names of all the transition classes and
initializing the pixels array for the first billboard and reading the target parameter.
finishInit( ) is called from the run( ) method of the applet. The run( ) method
restarts from the top each time the user leaves and comes back to the page. When this
happens, finishInit( ) will be called again. Since the applet has already finished its
initialization, Robert does not want it to reinitialize everything. This is why the applet
checks to see if the delay variable has already been initialized. If it has, then the applet
can skip the rest of the initialization.
start( ) and stop( )
The start( ) and stop( ) methods respectively are called when the user comes to or
leaves the page. They ensure that the applet thread that runs the transitions is on or off.
If stop( ) is called while the applet is in the middle of running a transition, some
data might be left in an improper state. Some variables are reset in start( ) to make sure
the applet restarts with a new transition.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1015
A
P
P
LY
IN
G
JA
V
A
In start( ), the mouse cursor is changed to a hand so that when the mouse cursor is
over the applet, it will appear to be a link.
run( )
The run( ) method starts with a loop that waits for the first image to be fully loaded
before proceeding. It then finishes the initialization of the applet by calling
finishInit( ). From there, it enters the main loop of the program.
This main loop drives the transitions between billboards. Using the delay
parameter passed in from the HTML to the applet, the applet calculates when the next
transition is supposed to be run. While it is waiting, it prepares for the transition. It
starts the preparation by determining which billboard is to be displayed next, parsing
the billboard data from HTML parameters if this has not been done yet for this
billboard. Then it randomly chooses which transition to run next, being careful not to
let the applet run the same transition consecutively.
Once the applet has determined what transition will be run next, it creates a new
instance of this transition class by dynamically loading the class using the String name
and then creating a new instance of the class. The dynamic loading of the transition
classes has a big impact on the loading time of the applet as a whole. Instead of every
single class having to be downloaded before the applet starts, only three classes are
sent initially: DynamicBillboard, BillData, and BillTransition. The other transition
classes are only downloaded by the applet the first time they are needed. This reduces
the initial download of the applet significantly. Some class files might not even need to
be sent if the user leaves the page quickly.
Finally, the applet calls the init( ) method on the transition object, passing the
applet and image pixels for the current and next billboard as parameters. This creates
all the cell frames that are used to animate a transition. With the transition ready to go,
the applet only need wait for the proper time to start the transition.
The applet performs the transition by using simple frame animation—drawing each
cell in order onto the screen, with a short delay between each frame. The applet calls
the toolkit method sync( ) just to be sure that the drawing of one cell does not take
place before the previous cell has been shown on the screen. After the last cell is
displayed, the applet draws the image from the next billboard onto the screen to
complete the transition.
Following this, the mouse_over_applet flag is checked to see if the mouse cursor
is currently over the applet. If so, the URL of the previous billboard is showing on the
status bar and must be updated to reflect the URL of the new billboard. This is done
with a call to the applet method showStatus( ). The applet has completed this
transition and is now ready to begin the next one.
mouseMoved( ) and mouseExited( )
mouseMoved( ) and mouseExited( ) are used to change the text that appears on the
status bar. When the mouse cursor is over the applet, the status bar is supposed to
show the URL that the current billboard links to. So when mouseMoved( ) gets called,
1016 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
the applet shows the URL on the status bar. When mouseExited( ) is called, the URL
text is removed from the status bar. Both methods also set the Boolean mouse_inside_
applet to the appropriate value. This variable is used in the run( ) method after a
transition is run. If the mouse is positioned over the applet when the transition
completes, then the applet knows to show the URL of the new billboard on the
status bar.
mouseReleased( )
When the mouse button is pressed with the cursor over the applet and then released,
the mouseReleased( ) method is called. The applet uses getAppletContext( ).show-
Document( ) to send the browser to the URL that the current billboard points to. As
Robert found out, sometimes browsers take a long time to display this new page. To
keep the applet from running more transitions while the new page is waiting to load,
stop( ) is called to force the main thread to quit. To let users know that the applet is
loading the new page, the applet changes the mouse cursor to the wait cursor.
It is important to remember that users can come back to this page after going to a
new page. The wait cursor will still be present on the applet when users come back.
The start( ) method is always called when the user comes back to a page with an
applet, so the applet resets the cursor to the hand cursor there.
The Code
Here is the source code for the DynamicBillboard class:
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.awt.*;
import java.awt.image.*;
public class DynamicBillboard
extends java.applet.Applet
implements Runnable {
BillData[] billboards;
int current_billboard;
int next_billboard;
String[] transition_classes;
Thread thread = null;
Image image = null;
long delay = -1;
boolean mouse_inside_applet;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1017
A
P
P
LY
IN
G
JA
V
A
String link_target_frame;
boolean stopFlag;
public void init() {
String s = getParameter("bgcolor");
if(s != null) {
Color color = new Color(Integer.parseInt(s.substring(1), 16));
setBackground(color);
getParent().setBackground(color);
getParent().repaint();
}
billboards = new
BillData[Integer.parseInt(getParameter("billboards"))];
current_billboard = next_billboard
= (int)(Math.random() *billboards.length);
parseBillData();
}
void parseBillData() {
String s = getParameter("bill" + next_billboard);
int field_end = s.indexOf(",");
Image new_image = getImage(getDocumentBase(),
s.substring(0, field_end));
URL link;
try {
link = new URL(getDocumentBase(),
s.substring(field_end + 1));
}
catch (java.net.MalformedURLException e) {
e.printStackTrace();
link = getDocumentBase();
}
billboards[next_billboard] = new BillData(link, new_image);
if(image == null) {
image = new_image;
}
else {
prepareImage(new_image, this);
billboards[next_billboard].initPixels(getSize().width,
getSize().height);
}
1018 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}void finishInit() {
if(delay != -1) {
return;
}
delay = Long.parseLong(getParameter("delay"));
link_target_frame = getParameter("target");
if(link_target_frame == null) {
link_target_frame = "_top";
}
String s = getParameter("transitions");
int field_end = s.indexOf(",");
int trans_count = Integer.parseInt(s.substring(0, field_end));
transition_classes = new String[trans_count];
for(--trans_count; trans_count > 0; --trans_count) {
s = s.substring(field_end + 1);
field_end = s.indexOf(",");
transition_classes[trans_count] = s.substring(0, field_end);
}
transition_classes[0] = s.substring(field_end + 1);
billboards[next_billboard].initPixels(getSize().width,
getSize().height);
mouse_inside_applet = false;
}
public void paint(Graphics g) {
g.drawImage(image, 0, 0, this);
}
public void update(Graphics g) {
paint(g);
}
public void start() {
next_billboard = current_billboard;
image = billboards[current_billboard].image;
setCursor(new Cursor(Cursor.HAND_CURSOR));
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1019
A
P
P
LY
IN
G
JA
V
A
if(thread == null) {
thread = new Thread(this);
thread.start();
}
}
public void stop() {
if(thread != null) {
stopFlag = true;
}
}
public void run() {
while((checkImage(image, this) & ImageObserver.ALLBITS) == 0) {
try { Thread.sleep(600); } catch (InterruptedException e) {}
}
finishInit();
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
int last_transition_type = -1;
BillTransition transition;
long next_billboard_time;
while(true) {
if(stopFlag)
return;
next_billboard_time = System.currentTimeMillis() + delay;
current_billboard = next_billboard;
if(++next_billboard >= billboards.length) {
next_billboard = 0;
}
if(billboards[next_billboard] == null) {
parseBillData();
try { Thread.sleep(120); } catch (InterruptedException e) {}
}
int transition_type = (int)(Math.random() *
(transition_classes.length - 1));
if(transition_type >= last_transition_type) {
++transition_type;
1020 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}last_transition_type = transition_type;
try {
String trans = transition_classes[last_transition_type];
transition = (BillTransition)Class.forName(trans)
.newInstance();
}
catch(Exception e) {
e.printStackTrace();
continue;
}
transition.init(this,billboards[current_billboard].image_pixels,
billboards[next_billboard].image_pixels);
if(System.currentTimeMillis() < next_billboard_time) {
try {
Thread.sleep(next_billboard_time -
System.currentTimeMillis());
} catch (InterruptedException e) { };
}
Graphics g = getGraphics();
for(int c = 0; c < transition.cells.length; ++c) {
image = transition.cells[c];
g.drawImage(image, 0, 0, null);
getToolkit().sync();
try { Thread.sleep(transition.delay); }
catch(InterruptedException e) { };
}
image = billboards[next_billboard].image;
g.drawImage(image, 0, 0, null);
getToolkit().sync();
g.dispose();
if(mouse_inside_applet == true) {
showStatus(billboards[next_billboard].link.toExternalForm());
}
transition = null;
try { Thread.sleep(120); } catch (InterruptedException e) {}
}
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1021
A
P
P
LY
IN
G
JA
V
A
public class MyMouseAdapter extends MouseAdapter {
public void mouseExited(MouseEvent me) {
mouse_inside_applet = false;
showStatus("");
}
public void mouseReleased(MouseEvent me) {
stop();
setCursor(new Cursor(Cursor.WAIT_CURSOR));
getAppletContext().showDocument(billboards[current_billboard].link,
link_target_frame);
}
}
public class MyMouseMotionAdapter extends MouseMotionAdapter {
public void mouseMoved(MouseEvent me) {
mouse_inside_applet = true;
showStatus(billboards[current_billboard].link.toExternalForm());
}
}
}
BillData.java
The BillData class is mostly just a data structure for encapsulating attributes associated
with individual billboards. It contains three variables. The first variable stores the
URL to which the billboard is a link. The second variable has an Image that the applet
uses to draw on the screen. The third variable includes a pixel array of the image in
RGB format.
The pixel array is used by transitions in combination with another BillData pixel
array to create the cells for transition animation. The array is only one-dimensional.
The pixels in it are arranged in such a way that the first element in this array is the
top-left corner of the image. The second element is the pixel just to the right of this
corner. Elements that follow are the pixels to the right of this one, and so on, until the
rightmost pixel is reached. Then the leftmost pixel on the next line of the image is used.
This continues until the last index in the array, which corresponds to the pixel on the
bottom-right corner of the image.
You might notice that Robert has made all of the variables in this class public.
Normally, it is good programming practice to hide the data members that should be
read only by other classes. This is done by making them protected or private and then
creating functions to return references to the variables. Unfortunately, in Java this
increases the size of the compiled bytecode even when the one line function is made
1022 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
final and the code is compiled with optimizations. So to make the applet smaller and
hence faster to download, Robert made the data members public.
The Constructor
The constructor for a BillData object simply initializes the URL and Image variables
with the two parameters passed in. Initializing the pixel array is done in a separate
method, because it is very processor-intensive. This gives the applet a chance to initialize
the pixel array only when it needs it.
initPixels( )
The initPixels( ) method creates the pixel array from the image using the Java core
class: java.awt.image.PixelGrabber.
The Code
Here is the source code for the BillData class:
import java.net.*;
import java.awt.*;
import java.awt.image.*;
public class BillData {
public URL link;
public Image image;
public int[] image_pixels;
public BillData(URL link, Image image) {
this.link = link;
this.image = image;
}
public void initPixels(int image_width, int image_height) {
image_pixels = new int[image_width * image_height];
PixelGrabber pixel_grabber = new
PixelGrabber(image.getSource(), 0, 0,
image_width, image_height, image_pixels, 0, image_width);
try {
pixel_grabber.grabPixels();
}
catch (InterruptedException e) {
image_pixels = null;
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1023
A
P
P
LY
IN
G
JA
V
A
}}
BillTransition.java
The BillTransition class is used as a base class for other transition classes. These other
classes create transition cells between two individual billboard images. This abstract
class contains variables and methods that are common to all transitions.
There are no constructors provided in the BillTransition class. This is because the
applet does not use “new” to create new instances and instead uses the factory method,
java.lang.Class.newInstance( ). Objects created in this way have no way to directly
initialize themselves using parameters in constructors. This factory method indirectly
creates objects using a default constructor, one without any parameters. The
BillTransition class provides a number of overloaded init( ) methods to initialize
instances with parameters.
In previous versions of DynamicBillboard, Robert used static variables within
different transition classes to store data that only needed to be initialized once. It was
discovered, however, that when more than one instance of the applet ran from a web
server, the applets would share the static variables. This led to some problems if one
applet needed a different static value than the other when the applets were different
sizes. An example is the FadeTransition class used to create an array whose size
depended on the dimensions of the applet. When another DynamicBillboard was
created with dimensions that were smaller than the previous applet, it would
overwrite this array with an array too small for the first applet. This would cause the
first applet to crash.
Robert introduced the static hash table called object_table in this version of the
applet to work around this problem. Now transition classes can store data inside this
hash table using the transition name in conjunction with the applet size as a key. When
this data needs to be used, the applet can look to see if it exists for the applet’s size
within the hash table. If it does not, then it can create the data and store it in the hash
table for later use. Now if there is more than one applet on a web server and both are
the same size, then only one has to initialize the data.
init( )
The init( ) method is overloaded three times. The first method, which has three
parameters, is abstract and must be overridden by classes derived from this class. The
other two methods initialize data members within this class. Robert’s intention was to
have the init( ) method of classes that are derived from this class call one of these two
methods to initialize data members of BillTransition.
1024 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
createCellFromWorkPixels( )
The createCellFromWorkPixels( ) method is used to perform the common task of
converting the work_pixels array into an Image object. Notice that it uses the owner
variable to complete this task. This is the only reason the owner variable is needed by
transition classes. When a transition has completed assembly of a new cell in the
work_pixels array, it should call this method.
The Code
Here is the source code for the BillTransition class:
import java.util.*;
import java.awt.*;
import java.awt.image.*;
public abstract class BillTransition {
static Hashtable object_table = new Hashtable(20);
public Image[] cells;
public int delay;
Component owner;
int cell_w;
int cell_h;
int pixels_per_cell;
int[] current_pixels;
int[] next_pixels;
int[] work_pixels;
public abstract void
init(Component owner, int[] current_pixels, int[] next_pixels);
final protected void
init(Component owner, int[] current_pixels, int[] next_pixels,
int number_of_cells, int delay) {
this.delay = delay;
this.next_pixels = next_pixels;
this.current_pixels = current_pixels;
this.owner = owner;
cells = new Image[number_of_cells];
cell_w = owner.getSize().width;
cell_h = owner.getSize().height;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1025
A
P
P
LY
IN
G
JA
V
A
pixels_per_cell = cell_w * cell_h;
work_pixels = new int[pixels_per_cell];
}
final protected void
init(Component owner, int[] current_pixels, int[] next_pixels,
int number_of_cells) {
init(owner, current_pixels, next_pixels, number_of_cells, 120);
}
final void createCellFromWorkPixels(int cell) {
cells[cell] = owner.createImage(
new MemoryImageSource(cell_w, cell_h,
work_pixels, 0, cell_w));
owner.prepareImage(cells[cell], null);
}
}
ColumnTransition.java
The ColumnTransition class changes one image into another by drawing increasingly
large columns of the new image onto the old image. The column sizes increase to the
left, and the same pixels are always drawn on the left side of each column. This makes
the billboard appear to be sliding in from behind the old billboard through vertical
slots in the current billboard.
To create the cells for this transition, the billboard space is split up into a number of
columns, each column 24 pixels wide. Each of the seven image cells the transition will
create will have pixels on the left side of each column from the old image and pixels
on the right side from the new image. The first cell that is created starts out with only
the three right pixels in each column taken from the new image. With each successive
cell, three more pixels are filled in from the new image. The last cell has only the three
left pixels in each column from the old image.
Because the width of the image space is most likely not perfectly divisible by 24,
there will be some remaining pixels remaining on the right side of the image. These
pixels are accounted for in each cell with the rightmost_columns_max_width and
rightmost_columns_x_start variables.
init( )
The init( ) function starts by calling the base class’ init( ) method to initialize the variables
contained within this base class. It goes on to initialize the variables associated with the
rightmost column and then copies all of the pixels from the current billboard into the
work pixels. The loop that follows creates all of the cell frames.
1026 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The nextCell( ) method changes work_pixels, and the method inherited from the
BillTransition class, createCellFromWorkPixels( ), is used to convert these pixels into
an image. Because the process of creating the cells can be very demanding on the CPU,
Robert tells the thread to sleep occasionally to allow other threads to run.
nextCell( )
The nextCell( ) method modifies the work_pixels array for the next cell. It loops
through each line of the image starting from the bottom line and fills part of each
column by copying pixels from the next billboard onto the work_pixels array. It does
not ever need to copy pixels from the old billboard, because these were already copied
to the array in the init( ) method.
It’s worth repeating that the pixel arrays used to form the images are only
one-dimensional. Every width pixel represents one horizontal line of the image.
The Code
Here is the source code for the ColumnTransition class:
import java.awt.*;
import java.awt.image.*;
public class ColumnTransition extends BillTransition {
final static int CELLS = 7;
final static int WIDTH_INCREMENT = 3;
final static int MAX_COLUMN_WIDTH = 24;
int rightmost_columns_max_width;
int rightmost_columns_x_start;
int column_width = WIDTH_INCREMENT;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 200);
rightmost_columns_max_width = cell_w % MAX_COLUMN_WIDTH;
rightmost_columns_x_start = cell_w - rightmost_columns_max_ width;
System.arraycopy(current_pixels, 0,
work_pixels, 0, pixels_per_cell);
for(int c = 0; c < CELLS; ++c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
NextCell();
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1027
A
P
P
LY
IN
G
JA
V
A
try { Thread.sleep(100); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
column_width += WIDTH_INCREMENT;
}
work_pixels = null;
}
void NextCell() {
int old_column_width = MAX_COLUMN_WIDTH - column_width;
for(int p = pixels_per_cell - cell_w; p >= 0; p -= cell_w) {
for (int x = 0; x < rightmost_columns_x_start; x +=
MAX_COLUMN_WIDTH) {
System.arraycopy(next_pixels, x + p, work_pixels,
old_column_width + x + p, column_width);
}
if(old_column_width <= rightmost_columns_max_width) {
System.arraycopy(next_pixels, rightmost_columns_x_start + p,
work_pixels, rightmost_columns_x_start +
old_column_width + p - 1,
rightmost_columns_max_width -
old_column_width + 1);
}
}
}
}
Here is what the column transition looks like before, during, and after:
1028 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
FadeTransition.java
The FadeTransition class changes one image into another by randomly including a
number of new pixels from the next billboard in each successive cell frame. This makes
the next billboard appear to fade in over the old billboard.
The heart of this transition is a two-dimensional array of short integers called
random. This array holds an index for every element in the next billboard’s image pixel
array. These indexes are randomly distributed in the two-dimensional array. The eight
elements in the first dimension of this array will be used when cells are created, one for
each new cell. The last element is never actually used, because there are only seven
cells. It is included when the random array is created to ensure that the indexes are
randomly distributed correctly.
The FadeTransition uses this array to pick pixels from the next billboard to
overwrite pixels of the old billboard. For the first cell, the work_pixels array contains
nothing but pixels from the old billboard. One-eighth of these pixels get changed to
the next billboard’s pixels. For the following cell, the same work_pixels array is used,
and one-eighth more pixels are filled in from the next billboard. For this cell the
result has one-fourth of the pixels from the next billboard, while the remainder are
from the old billboard. This continues until the last cell, cell number seven, which has
seven-eighths of its pixels from the new billboard. Remember, the DynamicBillboard
applet simply uses the whole image from the next billboard after the last cell to
complete the transition.
Because the size of this two-dimensional array is dependent on the size of the
applet, it must be unique to each applet. Using a static variable to store this array is
unacceptable, because applets of different sizes would share this array. Since it is fairly
time-consuming to create this array, it does not make sense to re-create it every time
this transition is to be used.
This is where the superclass’ static variable, object_table, first comes into play.
Once this array is created, it can be stored in this hash table with a key that includes the
size of the applet. When the array needs to be used, the applet can get the appropriate
one out of the hash table. If it does not exist in the hash table, the applet can then create
the array and store it in the hash table for future use. New applets of the same size as
the current applet will benefit from a usable array already being there. This seems like
a lot of effort, but in practice, web sites tend to use this applet on a large number of
pages with a standard layout size for each banner advertisement. So, it saves an
enormous amount of memory and CPU time to cache these tables.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1029
A
P
P
LY
IN
G
JA
V
A
createRandomArray( )
The createRandomArray( ) static method creates the two-dimensional random array.
It takes two parameters that describe the size of the applet. It is highly optimized,
because originally it was too slow. It includes its own random-number generator that is
very fast, but with a short cycle. Because of this, it is fairly complicated and beyond the
scope of this book. The basic idea is that Java’s built-in random-number generator is
better at generating truly random distribution, but it is too slow for this application.
Plus, the user will not notice exactly how random this transition is, so Robert’s
home-grown random-number generator is sufficient.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. Then, like some other transitions, it copies all of the old
billboard’s pixels into the work_pixels array.
The two-dimensional random array is pulled out of the object_table for an applet
of this size. If it does not exist yet, it is created and stored in the object_table. With the
random array in hand, the method just loops through each cell and each index in the
random array, copying pixels from the next billboard into the work pixels.
The Code
Here is the source code for the FadeTransition class:
import java.awt.*;
import java.awt.image.*;
public class FadeTransition extends BillTransition {
private static final int CELLS = 7;
private static final int MULTIPLIER = 0x5D1E2F;
private static short[][] createRandomArray(int number_pixels,
int cell_h) {
int total_cells = CELLS + 1;
int new_pixels_per_cell = number_pixels / total_cells;
short[][] random = new short[total_cells][new_pixels_per_cell];
int random_count[] = new int[total_cells];
for(int s = 0; s < total_cells; ++s) {
random_count[s] = 0;
}
int cell;
int rounded_new_pixels_per_cell =
new_pixels_per_cell * total_cells;
1030 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
int seed = (int)System.currentTimeMillis();
int denominator = 10;
while((new_pixels_per_cell % denominator > 0 ||
cell_h % denominator == 0) && denominator > 1) {
--denominator;
}
int new_randoms_per_cell = new_pixels_per_cell / denominator;
int new_randoms = rounded_new_pixels_per_cell / denominator;
for(int p = 0; p < new_randoms_per_cell; ++p) {
seed *= MULTIPLIER;
cell = (seed >>> 29);
random[cell][random_count[cell]++] = (short)p;
}
seed += 0x5050;
try { Thread.sleep(150); } catch (InterruptedException e) {}
for(int p = new_randoms_per_cell; p < new_randoms; ++p) {
seed *= MULTIPLIER;
cell = (seed >>> 29);
while(random_count[cell] >= new_randoms_per_cell) {
if(++cell >= total_cells) {
cell = 0;
}
}
random[cell][random_count[cell]++] = (short)p;
}
for(int s = 0; s < CELLS; ++s) {
for(int ps = new_randoms_per_cell; ps < new_pixels_per_cell;
ps += new_randoms_per_cell) {
int offset = ps * total_cells;
for(int p = 0; p < new_randoms_per_cell; ++p) {
random[s][ps + p] = (short)(random[s][p] + offset);
}
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1031
A
P
P
LY
IN
G
JA
V
A
try { Thread.sleep(50); } catch (InterruptedException e) {}
}
random[CELLS] = null;
return random;
}
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS);
System.arraycopy(current_pixels, 0, work_pixels,
0, pixels_per_cell);
short random[][] = (short[][])object_table.get(
getClass().getName() + pixels_per_cell);
if(random == null) {
random = createRandomArray(pixels_per_cell, cell_h);
object_table.put(getClass().getName() + pixels_per_cell,
random);
}
for(int c = 0; c < CELLS; ++c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
int limit = random[c].length;
for(int p = 0; p < limit; ++p) {
int pixel_index = random[c][p];
work_pixels[pixel_index] = next_pixels[pixel_index];
}
try { Thread.sleep(50); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
}
work_pixels = null;
}
}
Here is what the fade transition looks like before, during, and after:
1032 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
SmashTransition.java
The SmashTransition class changes one image into another by dropping the new
image onto the old one. The old image appears to crumble under the weight of
the new image.
Two instance variables, drop_amount and location, are used to create the frames.
The location variable keeps track of the pixel that the smashed image starts on. The
drop_amount variable stores the number of pixels of the new image to drop onto the
smashed image every frame. In other words, it is the number to add to the location
variable each frame. A static array called fill_pixels is used to color a whole line of the
work_pixels array white.
The smash effect is done by drawing the old image in an accordion-like fashion.
It starts out by drawing the first lines of the old image offset to the right. Each
progressive line is offset a little bit more to the right. This continues until some
maximum left offset is reached. At this point, the offset is reduced every line until
an offset of zero is reached. This continues until all of the lines of the smashed image
are drawn.
It does not draw the lines from the old image in their entirety. It uses a length that
is a bit shorter than the actual length.
The number of lines to draw for the smashed image decreases each frame as the old
billboard becomes more and more compacted. This transition uses lines that are evenly
distributed across the old image. This ensures that the smashed image does not appear
to be falling off the bottom of the applet or sliding under the new image.
setupFillPixels( )
The setupFillPixels( ) static method is used to ensure that the fill_pixels array is
initialized and is at least as long as one whole line for this applet. If this array has not
been initialized yet or is not long enough for this applet, then this method respectively
re-creates or creates and fills in the array. If there is more than one instance of this
applet running, both can share this fill_pixels array, but it must be at least as long as
the widest applet.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1033
A
P
P
LY
IN
G
JA
V
A
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. It follows this with a call to the method described earlier,
setupFillPixels( ). The initial values of the drop_amount and location variables are then
calculated. After this, the init( ) method goes into a loop to create each frame. It actually
does this in reverse, creating the last frame first. It does not have to be done in reverse.
However, running loops in reverse saves one byte of code in the resulting class file. After
each cell is created, the location variable is incremented to the next proper location.
Smash( )
The Smash( ) method modifies the work_pixels array for the next cell. It creates the
smashed image of the old billboard in the work_pixels array and draws in the pixels
for the new image. This method takes one parameter, max_fold, which is used as the
maximum right offset that the lines in the fold will have. It is also used by subtracting
this from the line width to determine the length of the lines to draw for the folds.
The method begins by copying the pixels from the new image onto work_ pixels.
It then initializes a number of variables that it uses to draw the smashed image. The
drawing of this smashed image is done line by line, in a loop. Within the loop, it first
makes the current line totally white. It then copies a portion of the correct line from
the old billboard over this line. To get the accordion effect, it does not start drawing
onto the same pixel location as it did for drawing the white line. It instead offsets
the destination pixels to the right by a few pixels. After drawing in the line, it adds a
number to the offset counter. It follows this with a bounds check to see if the offset has
gone beyond the minimum or maximum offset. If it has, it flips the sign of the number
it adds to the offset counter each line. The effect of this is that the direction of the offset
is reversed.
The Code
Here is the source code for the SmashTransition class:
import java.awt.*;
import java.awt.image.*;
public class SmashTransition extends BillTransition {
final static int CELLS = 8;
final static float FOLDS = 8.0f;
static int[] fill_pixels;
static void setupFillPixels(int width) {
if(fill_pixels != null && fill_pixels.length <= width) {
return;
1034 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}fill_pixels = new int[width];
for(int f = 0; f < width; ++f) {
fill_pixels[f] = 0xFFFFFFFF;
}
}
int drop_amount;
int location;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 160);
setupFillPixels(cell_w);
drop_amount =  (cell_h / CELLS) * cell_w;
location = pixels_per_cell - ((cell_h / CELLS) / 2) * cell_w;
for(int c = CELLS - 1; c >= 0; --c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
Smash(c + 1);
try { Thread.sleep(150); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
location -= drop_amount;
}
work_pixels = null;
}
void Smash(int max_fold) {
System.arraycopy(next_pixels, pixels_per_cell - location,
work_pixels, 0, location);
int height = cell_h - location / cell_w;
float fold_offset_adder = (float)max_fold * FOLDS / (float)height;
float fold_offset = 0.0f;
int fold_width = cell_w - max_fold;
float src_y_adder = (float)cell_h / (float)height;
float src_y_offset = cell_h - src_y_adder / 2;
for(int p = pixels_per_cell - cell_w; p >= location; p -=
cell_w) {
System.arraycopy(fill_pixels, 0, work_pixels, p, cell_w);
System.arraycopy(current_pixels, (int)src_y_offset * cell_w,
work_pixels, p + (int)fold_offset, fold_width);
src_y_offset -= src_y_adder;
fold_offset += fold_offset_adder;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1035
A
P
P
LY
IN
G
JA
V
A
if(fold_offset < 0.0 || fold_offset >= max_fold) {
fold_offset_adder *= -1.0f;
}
}
}
}
Here is what the smash transition looks like before, during, and after:
TearTransition.java
The TearTransition creates the illusion of the current billboard getting torn off the
applet like a piece of paper. It gets ripped upwards and toward the left to reveal the
next billboard image underneath.
There is only one member variable used in this transition, x_cross. It is used as a
multiplier to create the tear effect. The larger the value of this variable, the smaller the
tear effect will appear to be.
The code for this transition has many optimizations. One optimization of
significance is to create the cell frames in reverse order, building the last cell frame first
and the first, last. In their normal order, each subsequent cell frame reveals a little bit
more of the new image underneath. If the frames were to be created in the normal
order, the tear effect would have to be drawn, along with the new image pixels
revealed in the current frame, which had been covered by the tearing effect in the
previous frame. Doing it in reverse only requires redrawing the tearing effect each cell
1036 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
frame. For example, the last frame, created first, starts out with the tearing effect using
only a small portion of the upper-left corner of the image, while the rest of the pixels
are taken from the new billboard image. In the second to the last frame, which is
created second, the new tear effect draws over a little bit more of the upper-left corner
of the image, while the rest of the image remains the same. The cell frames that follow
draw the new tear effect over more and more of the image, but always covering up the
old tear effect from the last frame.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. It then copies all of the new billboard’s pixels into the
work_pixels array and copies the first line of the old billboard’s pixels onto the first
line of the work_pixels array. After the x_cross variable is initialized, the init( ) method
loops through each cell frame in reverse order. Inside the loop, it creates each cell
frame and decreases the value of the x_cross variable.
Tear( )
The Tear( ) method modifies the work_pixels array for the next cell. It draws the tear
effect onto the work pixels. It draws the tear effect line by line. To draw one line, the
method copies pixels from the old image pixels into the work_pixels array. It uses two
counters, one that is an index into the work_pixels array, the destination, and one that
references an index into the array of pixels for the old billboard, the source. Both
counters are started at zero. The destination counter is always incremented by one.
The source counter, however, is incremented by a floating-point number that is always
greater than one. When the loop is run until the destination index is larger than the
width of the line, the result is the source index growing faster than the destination
index. The overall effect is that in the destination, only a number of pixels on the left
side of the image will be copied from the source. The pixels taken from the source will
skip some pixels, resulting in pixels taken from the source being evenly distributed
across the line.
Each line of the cell frame will use a larger value for the floating-point number on
the line above. This makes lines toward the bottom draw on fewer pixels for the tear
effect than lines toward the top.
This method has one big optimization that it uses to get around the slow array
indexing in Java. Whenever a element in an array is used, bounds checking is done
to ensure that the index is within the bounds of the array. There is a performance hit
involved in this bounds checking. The standard Java class, System, provides a method
that allows you to copy sections of arrays from one array to another almost as fast or as
fast as copying one array element into another. This method is used to speed up the
creation lines within the cell frames. It only uses this method when the applet knows
some of the source pixels will be adjacent to one another. If the applet skips at least
every other pixel from the source image, then it will use the standard loop method.
An x_increment value less than 0.5 indicates that less than 1.5 will be added to the
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1037
A
P
P
LY
IN
G
JA
V
A
source index counter each time, and there will be a speed benefit from using the array
copy method for a particular line.
The Code
Here is the source code for the TearTransition class:
import java.awt.*;
import java.awt.image.*;
public class TearTransition extends BillTransition {
static final int CELLS = 7;
static final float INITIAL_X_CROSS = 1.6f;
static final float X_CROSS_DIVISOR = 3.5f;
float x_cross;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS);
System.arraycopy(next_pixels, 0, work_pixels, 0,
pixels_per_cell);
System.arraycopy(current_pixels, 0, work_pixels, 0, cell_w);
x_cross = INITIAL_X_CROSS;
for(int c = CELLS - 1; c >= 0; --c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
Tear();
try { Thread.sleep(150); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
x_cross /= X_CROSS_DIVISOR;
}
work_pixels = null;
}
final void Tear() {
float x_increment;
int p, height_adder;
p = height_adder = cell_w;
for (int y = 1; y < cell_h; ++y) {
x_increment = x_cross * y;
if(x_increment >= 0.50f) {
float fx = 0.0f;
1038 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
x_increment += 1.0f;
int x = 0;
do {
work_pixels[p++] = current_pixels[height_adder + x];
x = (int)(fx += x_increment);
} while(x < cell_w);
}
else {
float overflow = 1.0f / x_increment;
float dst_end = overflow / 2.0f  + 1.49999999f;
int dst_start = 0, src_offset = 0, length = (int)dst_end;
while(dst_start + src_offset + length < cell_w) {
System.arraycopy(current_pixels, p + src_offset,
work_pixels, p, length);
++src_offset;
dst_end += overflow;
p += length;
dst_start += length;
length = (int)dst_end - dst_start;
}
length = cell_w - src_offset - dst_start;
System.arraycopy(current_pixels, p + src_offset,
work_pixels, p, length);
}
p = height_adder += cell_w;
}
}
}
Here is what the tear transition looks like before, during, and after:
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1039
A
P
P
LY
IN
G
JA
V
A
UnrollTransition.java
UnrollTransition makes it appear as if a rolled-up poster is placed on the bottom of the
applet and then unrolled upward, gradually revealing the next image and covering
the old image. To enhance the unroll illusion, the roll gradually decreases in size as it
makes its way upward on the billboard.
Two instance variables are used during the creation of unroll transitions. The
location variable references pixels within the pixel arrays. It stores the current pixel
that the roll first appears on. The unroll_amount array variable tells the class how
many vertical pixels the roll should move upward each frame.
The most difficult part of creating each cell frame is drawing the roll. The only
other task that needs to be completed each frame is to draw the pixels from the new
image onto the space vacated by the roll from the previous frame.
The roll is drawn with scan lines from the new image. The first line of the roll is
drawn with the scan line located at the Y coordinate above the roll’s Y coordinate on
the applet. For example, if the roll is located on line ten for a particular cell frame,
then line nine of the new image will be used to draw the first line of the roll. Each
subsequent line of the roll is drawn using a line from the image located above the
previous line of the new image. So, continuing the example, the second line of the roll
will be drawn using line eight of the new image.
The roll is painted with its 3-D appearance by drawing each line of the roll with a
slight offset to the left. Lines closer to the center of the roll are drawn with a larger
offset than lines close to the top and bottom. The top and bottom lines of the rolls are
then shaded to make it look as if a light were above the applet. This results in the top
line being a bit brighter than the rest of the roll and the bottom line being a bit darker.
createUnrollAmountArray( )
Each consecutive cell frame in this transition unrolls the roll onto the applet a little
bit less than the previous cell frame. The createUnrollAmountArray( ) static method
is used to calculate an array that indicates how much each cell frame should unroll
the roll.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. Then the location variable is initialized to an index past the
last pixel in a pixel array. This is followed by copying all of the old billboard’s pixels
into the work_pixels array.
1040 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
An array that stores the number of pixels to unroll each frame is pulled out of the
object_table for an applet of this height. If it does not exist in the hash table, it is
created and stored in the object_table.
Then the init( ) method loops through each cell, moving the roll upward by
subtracting from the location variable and drawing each cell frame. It makes the
current thread take a break before and after the processor-intensive cell frame
creation, to allow other threads in Java’s multitasking environment to execute.
After the cell frame is created from the work_pixels array with the call to the
createCellFromWorkPixels( ) method, the area the roll was on is drawn over with
pixels from the new image. This prepares the work_pixels array for the next cell frame.
Unroll( )
The Unroll( ) method modifies the work_pixels array for the next cell. It draws the roll
onto the work pixels. This method first calculates the offset that it needs to use for
drawing each line of the roll. It then loops through each line of the roll, copying scan
lines from the new image onto the work_pixels array. The pixels that are exposed due
to the left offset of each line are filled in with pixels from the static fill_pixels array.
Another loop then increments though each pixel on the top and the bottom lines of
the roll, brightening pixels on the top line and darkening pixels on the bottom line.
The Code
Here is the source code for the UnrollTransition class:
import java.awt.*;
import java.awt.image.*;
public class UnrollTransition extends BillTransition {
final static int CELLS = 9;
static int fill_pixels[] = { 0xFFFFFFFF, 0xFF000000,
0xFF000000, 0xFFFFFFFF };
private static int[] createUnrollAmountArray(int cell_h) {
float unroll_increment =
((float)cell_h / (float)(CELLS + 1)) /
((float)(CELLS + 2) / 2.0f);
int total = 0;
int unroll_amount[] = new int[CELLS + 1];
for(int u = 0; u <= CELLS; ++u) {
unroll_amount[u] = (int)(unroll_increment * (CELLS - u + 1));
total += unroll_amount[u];
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1041
A
P
P
LY
IN
G
JA
V
A
if(total < 0) {
unroll_amount[0] -= 1;
}
return unroll_amount;
}
int location;
int[] unroll_amount;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 220);
location = pixels_per_cell;
System.arraycopy(current_pixels, 0,
work_pixels, 0, pixels_per_cell);
unroll_amount = (int[])object_table.get(getClass().getName() +
cell_h);
if(unroll_amount == null) {
unroll_amount = createUnrollAmountArray(cell_h);
object_table.put(getClass().getName() + cell_h, unroll_amount);
}
for(int c = 0; c < CELLS; ++c) {
location -= unroll_amount[c] * cell_w;
try { Thread.sleep(150); } catch (InterruptedException e) {}
Unroll(c);
try { Thread.sleep(100); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
System.arraycopy(next_pixels, location,
work_pixels, location,
unroll_amount[c] * cell_w);
}
work_pixels = null;
}
void Unroll(int c) {
int y_flip = cell_w;
int offset[] = new int[unroll_amount[c]];
for(int o = 0; o < unroll_amount[c]; ++o) {
offset[o] = 4;
}
offset[0] = 2;
1042 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
if(unroll_amount[c] > 1) {
offset[1] = 3;
}
if(unroll_amount[c] > 2) {
offset[unroll_amount[c] - 1] = 2;
}
if(unroll_amount[c] > 3) {
offset[unroll_amount[c] - 2] = 3;
}
int offset_index = 0;
int end_location = location + unroll_amount[c] * cell_w;
for(int p = location; p < end_location; p += cell_w) {
System.arraycopy(next_pixels,
p - y_flip + offset[offset_index],
work_pixels,
p, cell_w - offset[offset_index]);
System.arraycopy(fill_pixels, 0,
work_pixels,
p + cell_w - offset[offset_index],
offset[offset_index]);
++offset_index;
y_flip += cell_w + cell_w;
}
for(int x = location + cell_w - 1; x > location; --x) {
work_pixels[x] |= 0xFFAAAAAA;
work_pixels[x + unroll_amount[c]] &= 0xFF555555;
}
}
}
Here is what the unroll transition looks like before, during, and after:
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1043
A
P
P
LY
IN
G
JA
V
A
Dynamic Code
Robert has shown us how to create interactive high-performance graphics by
working around many of the apparent limitations in Java. He shows how to use
System.arraycopy( ) to effectively shuffle pixel data around. He shows how to properly
use cooperative multithreading to do computation and network transfers in the
background while the user isn’t waiting. Robert proves that high-performance direct
pixel manipulation algorithms can be efficiently written in Java if you are careful.
In addition to containing interesting code, DynamicBillboard is a very compelling
applet for nonprogrammers and users alike. It is easily configured by HTML editors,
extensible by Java programmers, and entertaining to web users. In this age of
advertising rates being driven by “click-through,” where advertisers only want to pay
for transfers from a content site to their site, Robert’s applet can be used to increase
traffic and ultimately increase revenue.
1044 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1045
A
P
P
LY
IN
G
JA
V
A
1046 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Chapter 30
ImageMenu: An
Image-Based Web Menu
1047
The ImageMenu applet is a simple program that presents an image-based menuwith an arbitrary number of choices in a vertical list. When the user moves themouse cursor over these choices, the one under the cursor changes appearance,
indicating that it can be clicked on. When the user clicks on a choice, the web browser
changes to a new document specified for that choice. ImageMenu was created by
David LaVallée, the creator of several interesting applets. Figure 30-1 shows an
instance of ImageMenu.
ImageMenu uses the showDocument( ) function in AppletContext to make the
hypertext leap to the new pages. The novelty of ImageMenu is that it uses different
portions of a single source image to draw the menu on the screen. Basing a menu on
an image rather than on text frees you to design menus that use any font or image you
desire. You can also provide various types of selection feedback. You no longer need to
rely on the AWT’s limited rendering functions.
1048 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 30-1. An example of ImageMenu
The ImageMenu applet was inspired by an applet called Navigation, created by
top-notch Java programmer Sean Welch. The difference between Navigation and
ImageMenu is efficiency in bandwidth and applet tag specification. The Navigation
applet uses a source image that is the applet’s width times the number of possible
selections wide to display all of its states. Both applets download a single image, which
is much more efficient over the Internet than loading multiple files. A menu of seven
choices for the Navigation applet (100×140 pixels) would require a source image of
700×140. The applet described here, ImageMenu, uses a source image that is two times
the applet width, or 200×140. Most web designers hate typing when they don’t have to,
which leads to the second significant difference between Navigation and ImageMenu:
abbreviated applet parameters.
While ImageMenu is many times more efficient, using a smaller source image and
fewer bytes of parameters, Welch’s Navigation has one inimitable trait—it can display
individually selected “states” that bleed over into the space of the next menu item. The
ImageMenu applet requires that each menu item be self-contained in a rectangular area
that cannot overlap with adjacent items. This would prohibit, for example, ascending
letters (like h) from overlapping descending letters (such as j) in the line above.
The Source Image
While you won’t see the code for Navigation here, looking at its GIF image shows clearly
what it does. The source image for Navigation in Figure 30-2 shows seven columns,
each of which provides a visual representation of a possible selection. However, each
selectable item only has two states, so each row has five redundant copies of the
unselected state.
The source image for ImageMenu is shown in Figure 30-3. Given this image, it is
simple to render any of the seven possible states of a six-choice menu. First, drawImage( )
displays the left half of the source image. This is the state where no items are selected.
If any of the items is selected, then the clipping rectangle is simply set to the bounds of
the selected item, and drawImage( ) is used to display the right-hand side. This will
paint just the selected cell through the clipping rectangle.
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1049
A
P
P
LY
IN
G
JA
V
A
Figure 30-2. The source image for the Navigation applet
The APPLET Tag
The APPLET tag for ImageMenu contains many pieces of information. We will
use java.util.StringTokenizer to read the urlList and the frame targetList parameters
whose values are plus sign–delimited lists of values. We’ll also infer the coordinates of
each menu item by dividing the height of the applet by the number of URLs parsed in
urlList. For readability in the APPLET tag, we also allow a prefix and suffix, which will
be concatenated with a URL when it’s time to move to a new page.
<applet code="ImageMenu" width=140 height=180 hspace=0 vspace=0>
<param name="img" value="menu.jpg">
<param name="urlPrefix"
value="http://www.osborne.com/">
<param name="urlList"
value="pressroom/pressroom.shtml+aboutus/aboutus.shtml+
1050 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 30-3. The source image for ImageMenu
downloads/downloads.shtml+errata/errata.shtml">
<param name="targetList"
value="_self+_self+_self+_self+_self+_self">
<param name="urlSuffix" value="">
</applet>
The Methods
This is a small applet—about 100 lines of Java source. We will walk through all eight
methods here and then show all the source together at the end of the chapter.
init( )
When the applet is being initialized, init( ) saves the size in the Dimension variable d
and parses the applet param tags. It then uses a StringTokenizer to parse strings delimited
by the plus sign to create the string arrays url and target. The number of URLs that are
parsed is the number that is used to divide the vertical space into menu cells. From this
calculation, init( ) saves the number and height of the cells in cells and cellH, respectively.
update( )
We nullify the update( ) method of Applet to avoid flashing. As mentioned in Chapter 23,
the update( ) method in the Applet superclass fills a rectangle with the background color
before calling paint( ). Since we’re not going to use repaint( ), we can just eliminate
update completely.
lateInit( )
The lateInit( ) private method creates the offscreen Image object that will be used for
double buffering the display of the menu. This method also employs a MediaTracker
object to synchronously get the source image.
paint( )
The paint( ) method is quite simple. First, it checks to see if the offscreen buffer has been
created yet. If it hasn’t, lateInit( ) is called to create the buffer and load the menu image.
After that, it draws the left half of the image on the offscreen buffer. This requires,
of course, that the menu image be twice the width of the applet. That way, the applet
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1051
A
P
P
LY
IN
G
JA
V
A
will simply clip away the right half of the menu image when drawImage(img, 0, 0,
null) is called. Then, if any cell is selected (selectedCell >= 0), it sets the clip rectangle
to the bounds of that menu item. You’ll notice that paint( ) gets the graphics context of
the offscreen image every time. This has the effect of resetting the clipping rectangle to
the bounds of the image. AWT’s lack of a resetClip( ) method requires some strange
coding style.
Next, the entire image is painted again, but this time, it is offset by the width of the
applet to the left, via drawImage(img, -d.width, 0, null). This has the effect of placing
just the right highlighted menu item in the clip rectangle. Lastly, the offscreen buffer is
copied to the applet window.
The speed of most graphic displays is largely throttled by the speed of the CPU’s
access directly to the screen. Additionally, many modern display cards are optimized for
copying rectangular areas from memory to the display in support of windowing systems.
Therefore, you are much better off doing all your drawing on an offscreen buffer rather
than copying the bits to the screen. On similar PC systems, we have seen between 10
and 400 buffer changes a second, depending on pixel depth and display card architecture.
mouseExited( )
Special handling is needed for mouseExited( ), because it causes all of the menu items
to be unselected. All we have to do is set selectedCell and oldCell to –1, which makes
the subsequent paint( ) call show all the items as unselected. Having oldCell set to –1
means that the next time the mouse enters the applet and causes a mouseMoved( ) call,
the first item will paint properly.
mouseDragged( )
The mouseDragged( ) method is called when the mouse moves with any of its buttons
pressed. In this applet, we want to do the same thing on drag or move, so we just call
mouseMoved( ) directly, passing in the same parameters we received.
mouseMoved( )
Whenever the mouse moves, mouseMoved( ) checks the y coordinate to see which of the
cells was selected. If the selectedCell is different from oldCell, meaning the user moved
from one cell to another, the menu is repainted. This is an optimization that avoids the
constant repainting of identical screen bits every time the mouse moves. You will notice
that repaint( ) is not called here. We are taking a shortcut through the normal applet
protocol by calling paint( ) directly after fetching the Graphics context from
1052 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
getGraphics( ). This makes for a much snappier response. After the menu is painted,
the status line is set to reflect the newly selected item, which is also saved in oldCell.
mouseReleased( )
mouseReleased( ) sends the browser to the URL that corresponds to the currently selected
menu item. The desired URL is then constructed. If the URL was improperly formatted
in the APPLET tag, the exception is displayed on the status line and returned without
attempting to switch documents. The showDocument( ) method puts the document
described in the URL into the frame listed in the target array. As a final feature, the
state of this SHIFT key is checked by calling the isShiftDown( ) method of MouseEvent.
If SHIFT was pressed, the URL is opened into a new blank browser window instead of
the one specified in target.
The Code
The source code for ImageMenu is shown here:
import java.awt.* ;
import java.awt.event.*;
import java.applet.*;
import java.util.*;
import java.net.*;
public class ImageMenu extends Applet {
Dimension d;
Image img, off;
Graphics offg;
int MAXITEMS = 64;
String url[] = new String[MAXITEMS];
String target[] = new String[MAXITEMS];
String urlPrefix, urlSuffix;
int selectedCell = -1;
int oldCell = -1;
int cellH;
int cells;
public void init() {
d = getSize();
urlPrefix = getParameter("urlPrefix");
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1053
A
P
P
LY
IN
G
JA
V
A
urlSuffix = getParameter("urlSuffix");
StringTokenizer st;
st = new StringTokenizer(getParameter("urlList"), "+");
int i=0;
while(st.hasMoreTokens() && i < MAXITEMS)
url[i++] = st.nextToken();
cells = i;
cellH = d.height/cells;
st = new StringTokenizer(getParameter("targetList"), "+");
i=0;
while(st.hasMoreTokens() && i < MAXITEMS)
target[i++] = st.nextToken();
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
private void lateInit() {
off = createImage(d.width, d.height);
try {
img = getImage(getDocumentBase(), getParameter("img"));
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
} catch(Exception e) {
showStatus("error: " + e);
}
}
public void update(Graphics g) {}
public void paint(Graphics g) {
if(off == null)
lateInit();
offg = off.getGraphics();
offg.drawImage(img, 0, 0, this);
if (selectedCell >= 0) {
offg.clipRect(0, selectedCell * cellH, d.width, cellH)
offg.drawImage(img, -d.width, 0, this);
}
1054 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
g.drawImage(off, 0, 0, this);
}
class MyMouseMotionAdapter extends MouseMotionAdapter {
public void mouseDragged(MouseEvent me) {
mouseMoved(me);
}
public void mouseMoved(MouseEvent me) {
int y = me.getY();
selectedCell = (int)(y/(double)d.height*cells);
if (selectedCell != oldCell) {
paint(getGraphics());
showStatus(urlPrefix + url[selectedCell] + urlSuffix);
oldCell = selectedCell;
}
}
}
class MyMouseAdapter extends MouseAdapter {
public void mouseExited(MouseEvent me) {
selectedCell = oldCell = -1;
paint(getGraphics());
showStatus("");
}
public void mouseReleased(MouseEvent me) {
URL u = null;
try {
u = new URL(urlPrefix + url[selectedCell] + urlSuffix);
} catch(Exception e) {
showStatus("error: " + e);
}
if (me.isShiftDown())
getAppletContext().showDocument(u, "_blank");
else
getAppletContext().showDocument(u, target[selectedCell]);
}
}
}
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1055
A
P
P
LY
IN
G
JA
V
A
Summary
In use, the ImageMenu applet can look great and it provides a lot of leverage for a very
small program. Use of the showDocument(URL u, String target) in this applet allows
for a subtle optimization in web page design. If you put an ImageMenu applet in a
frame in an HTML frameset and use it to send documents to a second frame, the applet
never has to be reloaded, which makes the user’s experience better.
1056 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Chapter 31
The Lavatron Applet:
A Sports Arena Display
1057
Lavatron is a sports arena lightbulb display. Normally, an applet doesn’thave much of a history, but this one does. David LaVallée, the author of theImageMenu applet from Chapter 30, wanted to achieve this kind of effect for a
long time. The history of Lavatron begins way back in 1974, when LaVallée was the
stick boy for the California Golden Seals of the NHL. David recalls, “Our scoreboard
just displayed, well, the score. The game was the thing; there wasn’t much to distract
hockey fans other than the dah-dah-dah-dat-dah-dah of the organ player.”
In 1979, LaVallée became fascinated with the idea of a graphical programmable
scoreboard when he was the repair guy for the Digital Equipment Corporation PDP
11/34 that ran the scoreboard at the Canadian National Exhibition Stadium (where
the Toronto Blue Jays used to play). That scoreboard was based on plain old 100-watt
lightbulbs like you use at home. In 1991, Toronto was treated to the Sony Jumbotron
HDTV scoreboard at the Skydome: true color, images, video, and three times the height
of the Hard Rock Cafe. In 1992, LaVallée wrote the first version of Lavatron in Objective-
C and PostScript. Finally, in 1995, Lavatron was written again from scratch to run under
Java, and it has undergone several performance tweaks and iterations since. The version
shown here has been updated for Java 2.
There are many possible enhancements to Lavatron (see Figure 31-1) that you
might want to try, such as drawing the source image dynamically in memory rather
than downloading it, or scrolling an animated sequence. But it’s an interesting
animated display applet that you may find useful as is.
1058 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 31-1. The Lavatron applet in action. The source image contains a bitmap
of the title Java 2: The Complete Reference on a white background.
How Lavatron Works
Lavatron is able to present an interesting image onscreen because of a small trick that it
employs, and its side effect allows the applet to load very quickly. The reason it loads
so quickly is that there isn’t much data transmitted over the Net. The source image is a
JPEG image that is 64 times smaller than the displayed image. Each pixel in the source
image is scaled up to an 8×8-pixel square. Here is the trick that Lavatron uses to
produce the lightbulb effect. An 8×8-pixel image of a transparent circle surrounded by
a black bezel, with a white highlight for a dash of style, is painted over the scaled-up
color pixel. As an optimization, the bulbs are preassembled into an image that can be
painted once for each column. Figure 31-2 shows what the bulb mask looks like blown
up. The two white pixels are the highlight. The black pixels in the corner are opaque.
Finally, all of the gray pixels in the middle are transparent, to allow the lightbulb color
to show through.
Lavatron paints so fast because it doesn’t have to repaint what it has already drawn.
The technique of copying the area of the screen that’s good and painting just the portion
that’s new is used in many common operations involving scrolling. The awt.Graphics
function copyArea( ) takes a portion of an image defined by a rectangle and moves it
by an x,y offset from its starting location. As a graphics speed optimization, copyArea( )
is hard to beat. It consistently outperforms any other technique of image rendering,
such as the use of drawImage( ), or drawImage( ) through a clipRect( ). Building an
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1059
A
P
P
LY
IN
G
JA
V
A
Figure 31-2. A blown-up light bulb image
image much larger than your applet, which has several source images concatenated
into a single image, and then using copyArea to move them into place and clipping the
result onscreen is a very fast Java rendering technique.
The Source Code
Lavatron starts by initializing data, which includes loading the source image and
creating the column of bulb images. The last stage of the initialization is painting the
offscreen (double buffer) image full of dimmed (black) lightbulbs to start the display
with a clean image. Subsequent painting of the offscreen image begins by using
copyArea( ) to move the existing portion of the image to the left by the width of the
column of bulbs about to be added on the right edge. Then the pixel values for the next
column are read and used as the color to fill a column of 8×8 rectangles at the right
edge of the applet. The transparent column of bulbs is painted, and then the whole
backing image is drawn to the screen. Since this applet doesn’t have to do much except
scroll the image, it avoids the normal repaint( ) loop by forking a thread that repeatedly
calls paint( ), pausing only to call yield( ) to allow other threads to run.
The APPLET Tag
The source code starts with the APPLET tag for Lavatron, shown here. This applet
looks best when the width is an even multiple of the bulb size and the height is the
bulb size times the source image height. The only parameter is for the name of the
source image file, named in img.
<applet code=Lavatron.class width=560 height=128>
<param name="img" value="swsm.jpg">
</applet>
Lavatron.java
The main applet is small, about 100 lines of Java source code. However, there is also
a support class that is required, which is described in the next section.
init( )
The init( ) method first determines the size of the applet by using getSize( ), and then
rounds up the size to a multiple of the bulb size, specified by bulbS, and stores it in
offw,offh. It then creates an image that size, called offscreen, for use as a double
buffer for the display. The Graphics object used for drawing on offscreen is saved
in offGraphics. The size of the applet, in bulb units rather than pixels, is stored in
bulbsW,bulbsH.
Next, the image of a column of bulbs is created by calling createBulbs( ), passing in
the size of the image to create. Then the image named in the img applet parameter is
1060 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
loaded. This is done by passing the result of getImage( ) to MediaTracker’s addImage( )
method, and then calling waitForID( ), which waits until the image is fully loaded
before returning.
To draw the blown-up version of this image, init( ) needs to retrieve the color
information for each pixel in the image. First, it obtains the size of the image, using
getWidth( ) and getHeight( ), saving the width in pixscan. It then assigns pixels to a
new array of pixscan * h integers. Then a PixelGrabber is created. When grabPixels( )
is called, the array is filled in with the color values.
The final step of init( ) is to paint black bulbs on the offscreen image, which makes
the effect more dramatic as the image scrolls from the right side revealing lighted bulbs.
createBulbs( )
The createBulbs( ) method is a helper to init( ). It returns an Image of a stack of bulb
images that can be used to mask out a column of colored squares to make them look
like lit lightbulbs. It is a little tricky, but quite elegant.
First, it allocates the right number of ints in an array to store the pixels. Then, it
declares another array, which is a picture of a single bulb, represented by the numbers
0, 1, and 2. The 0s represent black, the 1s transparent pixels, and the 2s represent the
white highlight. Next, a short array is declared—bulbCLUT (bulb Color Look Up Table).
This maps the 0, 1, and 2 just mentioned into full 32-bit pixel values. The 0xff000000 is
opaque black. The high-order byte is alpha, or transparency. The 0x00c0c0c0 is a fully
transparent light gray, and the 0xffffffff is opaque white.
The for loop runs through each pixel, loading the appropriate 0, 1, or 2 from bulbBits
based on the position in the column. This is achieved by use of the mod (%) operator.
This value is then used to look up the color from bulbCLUT. Given this array of pixels,
createBulbs( ) returns the output of createImage( ), passing in a MemoryImageSource
object prepared with the pixels we just constructed.
color( )
The color( ) method returns the color of the pixel at the x,y position in the source image
as a Color object. Since this applet runs continuously, we decided not to simply create
a new Color object each time a single bulb was painted. This would be abusive of the
garbage-collected heap. Instead, unique Color objects are stored in a hash table. The
maximum number of Color objects in the hash table can be as much as the width times
the height of the source image, but in practice, it is usually much less.
update( )
Lavatron overrides update( ) to do nothing, because we don’t want AWT’s implementation
to cause flicker.
paint( )
The paint( ) method is quite simple. The first step calls copyArea( ) to move all of the
columns to the left by one column’s width. Then a for loop is used to fill the rightmost
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1061
A
P
P
LY
IN
G
JA
V
A
column with rectangles in the Color of the appropriate pixel, using color( ). The bulb
image strip is then painted over the new column. Then the current scrolled position,
scrollX, is updated to be one more to the right, modulo the width, pixscan.
start( ), stop( ), and run( )
When the applet starts, it creates and starts a new Thread called t. This thread will call
run( ), which will keep calling paint( ) as fast as possible, while maintaining the courtesy
of calling yield( ) so that other threads can run. When the applet stop( ) method is
called, stopFlag is set to true. This variable is checked by the infinite loop in the run( )
method. Program control breaks from the loop when stopFlag is true.
A useful enhancement would be to introduce a threshold frame rate, say 30 fps (frames
per second), and change the call to the yield( ) into an appropriate call to sleep( ) if the
rendering is too fast.
The Code
Here is the source code for the Lavatron class:
import java.applet.*;
import java.awt.* ;
import java.awt.image.* ;
public class Lavatron extends Applet implements Runnable {
int scrollX;
int bulbsW, bulbsH;
int bulbS = 8;
Dimension d;
Image offscreen, bulb, img;
Graphics offgraphics;
int pixels[];
int pixscan;
IntHash clut = new IntHash();
boolean stopFlag;
public void init() {
d = getSize();
int offw = (int) Math.ceil(d.width/bulbS) * bulbS;
int offh = (int) Math.ceil(d.height/bulbS) * bulbS;
offscreen = createImage(offw, offh);
offgraphics = offscreen.getGraphics();
bulbsW = offw/bulbS;
bulbsH = offh/bulbS;
1062 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
bulb = createBulbs(bulbS, bulbsH*bulbS);
try {
img = getImage(getDocumentBase(), getParameter("img"));
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
pixscan = img.getWidth(null);
int h = img.getHeight(null);
pixels = new int[pixscan * h];
PixelGrabber pg = new PixelGrabber(img, 0, 0, pixscan, h,
pixels, 0, pixscan);
pg.grabPixels();
} catch (InterruptedException e) { };
scrollX = 0;
// paint black bulbs on the offscreen image
offgraphics.setColor(Color.black);
offgraphics.fillRect(0, 0, d.width, d.height);
for (int x=0; x<bulbsW; x++)
offgraphics.drawImage(bulb, x*bulbS, 0, null);
}
Image createBulbs(int w, int h) {
int pixels[] = new int[w*h];
int bulbBits[] = {
0,0,1,1,1,1,0,0,
0,1,2,1,1,1,1,0,
1,2,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
0,1,1,1,1,1,1,0,
0,0,1,1,1,1,0,0
};
int bulbCLUT[] = { 0xff000000, 0x00c0c0c0, 0xffffffff };
for (int i=0; i<w*h; i++)
pixels[i] = bulbCLUT[bulbBits[i%bulbBits.length]];
return createImage(new MemoryImageSource(w, h, pixels, 0, w));
}
public final Color color(int x, int y) {
int p = pixels[y*pixscan+x];
Color c;
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1063
A
P
P
LY
IN
G
JA
V
A
if ((c=(Color)clut.get(p)) == null)
clut.put(p, c = new Color(p));
return c;
}
public void update() {}
public void paint(Graphics g) {
offgraphics.copyArea(bulbS, 0, bulbsW*bulbS-bulbS, d.height,
-bulbS, 0);
for (int y=0; y<bulbsH; y++) {
offgraphics.setColor(color(scrollX, y));
offgraphics.fillRect(d.width-bulbS, y*bulbS, bulbS, bulbS);
}
offgraphics.drawImage(bulb, d.width-bulbS, 0, null);
g.drawImage(offscreen, 0, 0, null);
scrollX = (scrollX + 1) % pixscan;
}
Thread t;
public void run() {
while (true) {
paint(getGraphics());
try{t.yield();} catch(Exception e) { };
if(stopFlag)
break;
}
}
public void start() {
t = new Thread(this);
t.setPriority(Thread.MIN_PRIORITY);
stopFlag = false;
t.start();
}
public void stop() {
stopFlag = true;
}
}
1064 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
IntHash( )
As mentioned in the preceding section, Color objects are stored in a hash table rather
than creating the same ones over and over. As a further optimization, we created our
own version of Java’s Hashtable class, which uses normal ints as keys rather than
requiring an Object handle.
Integer data needs much less room to store in the pixel array than Color objects,
so we use a hash table as a mechanism to look up Color objects from the integer value
of any individual pixel. Creating Color objects on the fly from the integer value of
each pixel is very expensive, because it creates a lot of memory garbage that must be
collected. One possible solution would be to use a Java Hashtable, except that doing so
would create just as much garbage, since only objects can be used as keys in a standard
Java hash table. Thus, to store an int in Java’s hash table, you would have to create a
new Integer object as a key to be matched. In a high duty cycle applet like Lavatron,
garbage Integer objects would be created by the thousands per second. This is not a
good solution.
The proper solution was to build our own hash table, IntHash, which uses the
integer data type values rather than the Integer object for its keys. IntHash is about 60
lines of code. The IntHash class duplicates the interface of the java.util.Hashtable class
with the exception that the type of the argument to put( ) and get( ) is an int data type
rather than an Object. There’s no need to explain how a hash table works in this
chapter, but suffice it to say that put(42, “Hello”) == get(42).
The Code
Here is the source code for the IntHash class:
class IntHash {
private int capacity;
private int size;
private float load = 0.7F;
private int keys[];
private Object vals[];
public IntHash(int n) {
capacity = n;
size = 0;
keys = new int[n];
vals = new Object[n];
}
public IntHash() {
this(101);
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1065
A
P
P
LY
IN
G
JA
V
A
}private void rehash() {
int newcapacity = capacity * 2 + 1;
Object newvals[] = new Object[newcapacity];
int newkeys[] = new int[newcapacity];
for (int i = 0; i < capacity; i++) {
Object o = vals[i];
if (o != null) {
int k = keys[i];
int newi = (k & 0x7fffffff) % newcapacity;
while (newvals[newi] != null)
newi = (newi + 1) % newcapacity;
newkeys[newi] = k;
newvals[newi] = o;
}
}
capacity = newcapacity;
keys = newkeys;
vals = newvals;
}
public void put(int k, Object o) {
int i = (k & 0x7fffffff) % capacity;
while (vals[i] != null && k != keys[i]) // hash collision.
i = (i + 1) % capacity;
if (vals[i] == null)
size++;
keys[i] = k;
vals[i] = o;
if (size > (int)(capacity * load))
rehash();
}
public final Object get(int k) {
int i = (k & 0x7fffffff) % capacity;
while (vals[i] != null && k != keys[i]) // hash miss
i = (i + 1) % capacity;
return vals[i];
}
1066 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public final boolean contains(int k) {
return get(k)!=null;
}
public int size() {
return size;
}
public int capacity() {
return capacity;
}
}
Hot Lava
This applet is another small example of the kind of amazing performance you can
squeeze out of Java if you are careful and diligent. David LaVallée uses many tricks
to avoid excessive memory allocation and unnecessary calls to AWT drawing
functions. Creating the lightbulb mask image from a small array of integers rather
than a loaded GIF image saves download time and increases flexibility. The use of
paint(getGraphics( )) rather than repaint( ) increases frame rate significantly. The
performance gains from using copyArea( ) over rerendering the image or calling
drawImage( ) are profound. Finally, the creation and use of IntHash makes for that
last performance boost by not forcing the system to garbage-collect as often.
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1067
A
P
P
LY
IN
G
JA
V
A
This page intentionally left blank.
Chapter 32
Scrabblet: A Multiplayer
Word Game
1069
Scrabblet is a complete multiplayer, networked, client/server game. It is the mostcomplicated applet in this book, and it handles some of the thorniest issues in Javaprogramming. Scrabblet consists of more than 1,400 lines of code in 11 classes.
Two of these classes are part of the server side of the applet. The other nine are
downloaded to a web browser and act as the simulation of the game. All of the code
elements used in the game have been described in detail in this book. In this chapter,
we will dissect each class and show how easy it is to build a multiplayer game.
Network Security Concerns
Most applets on the Net today don’t do much with the network after they have
been downloaded. One of the reasons is that networking has been made more difficult
in Java out of security concerns. Most Java applet environments, such as Netscape
Navigator and Microsoft Internet Explorer, severely restrict an applet’s use of the
network. This situation is created by TCP/IP’s lack of authentication in its most basic
protocols. This inherent limitation of the Internet is managed carefully by corporations
that want to protect their proprietary data through the use of firewalls. A firewall is a
computer that sits between a private network and the rest of the Internet. All Internet
connections flow through it, and it is able to filter and reject connections and packets,
both incoming and outgoing. This way, if a program on the outside of the firewall
attempts to attach to an internal network port, the firewall can block it. If it weren’t for
the firewall, system administrators would have to audit the security of each machine
on their internal network. In the case of a firewall-protected network, only the firewall
needs to be secure, and every machine inside is considered “friendly” and left
unprotected from every other machine inside.
This is where Java could have posed a security threat. If Java-enabled browsers
allowed applets to connect to arbitrary Internet addresses, then an applet could act as
a proxy to some malicious program on the outside of the firewall. Once an applet had
been downloaded and automatically run by the web browser, it could then connect to
the neighboring computers and servers. These computers would not expect anything
hostile to come from an internal computer, so they would accept the connections. The
applet would then be free to steal sensitive data and transmit it back through the
firewall to the malicious Internet host.
Because of this scenario, applets are only allowed to make network connections
to exactly one host: the one they were loaded from. This restricts the applet from
snooping around the internal network. One of the many well-publicized “Java security
attacks” from researchers at Princeton University was a way of tricking a Java run-time
system into allowing an applet to open network sockets on otherwise forbidden
machines. Thankfully, this problem was very difficult to reproduce and has
subsequently been addressed.
What does security have to do with a multiplayer game? Plenty. The easiest way to
program a multiplayer game would be to have the players communicate directly with
1070 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
each other, in a “peer-to-peer” network. This way, playing the game would not rely on
having any particular server software running. Unfortunately, the applet is only able to
connect back to the server that it was loaded from. This means that two players have to
communicate all of their messages to each other via the server.
In this chapter, you will see the source code to a simple server, which manages a list
of connected clients and passes messages between those clients. For the most part, this
server knows nothing about the game being played. It just passes the messages blithely
from point A to point B. This function is handled by two classes, Server and
ClientConnection. They will be described at the end of this chapter.
The Game
Before users can play a multiplayer game, they must choose somebody to play against.
Rather than forcing a phone call to arrange a game, this applet takes a different approach.
When it is first run, it prompts the user to enter his or her name (see Figure 32-1). This
name is passed to the server, which broadcasts the player’s name to all other potential
competitors. The user then sees a list of all available players (see Figure 32-2), selects
one, and clicks on the Challenge button. Currently, there is no way to confirm or deny
a challenge; they are automatically accepted. Once a challenge is made, both players
see the game board appear, and all other competitors simply see both players’ names
disappear from the available list.
It is quite an easy game to play, but it is very difficult to win against a skilled
opponent. Players are presented with a 15×15 grid of squares and given a set of seven
square tiles with letters of the alphabet engraved on them (see Figure 32-3). These tiles
are selected at random from a bag of 100 tiles. The tiles can be clicked on with the
mouse and dragged to a destination square on the grid. If the spot is already occupied,
the tile is returned to its original position. Tiles may be adjusted on the board during a
turn, but not when the turn is over.
The first player starts by placing several tiles in a line on the board to form a word
in the English language. The first word must cover the center square. Subsequent
words must touch at least one tile already played on the board. The player clicks on the
Done button to end the turn. If a player can’t find a valid word, the player can pass by
clicking on Done twice in a row without having any tiles on the board. The two players
take turns placing words until all of the tiles are used.
The board shown in Figure 32-3 is for smaller displays, and thus the multiplier
squares are marked with simple characters. 2L doubles the value of the letter on that
square. 3L triples the letter’s value. 2W means the whole word gets double the points;
3W means triple the word score. If you make the applet big enough, it will use more
descriptive labels for these squares, as shown in Figure 32-4.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1071
A
P
P
LY
IN
G
JA
V
A
1072 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-1. The user must type in his or her name to begin
Figure 32-2. The list of competitors
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1073
A
P
P
LY
IN
G
JA
V
A
Figure 32-3. Patrick and Herb are ready to play against each other
Figure 32-4. Everything is clearer with a larger applet (650x700)
Scoring
Scores are assessed at the end of each turn. Each tile has a small number engraved on
its face next to the letter. This score may be multiplied by two or three, depending on
the value (color) of the square on which it was placed. The entire sum for a word may
also be multiplied by two or three if any letter in the word covers the appropriate
square. If a word comes in contact with any other tiles to form additional words, they
are counted separately. If a player uses all seven tiles in a single turn, an additional 50
points are awarded. At the end of the game, the player with the highest score wins.
Figure 32-5 shows an example of a board after a few turns have been taken. Patrick
started with SIRE, worth eight points. That came from the four one-point tiles and the
double-word score on the center tile. Next, Herb played HIRE, using the I from SIRE.
This was worth seven points, the sum of the four tiles involved. Notice that Herb got
credit for reusing Patrick’s I but not the double-word score underneath it. At the point
shown in Figure 32-5, Patrick has played GREAT and is about to click the Done button
to complete his turn. Notice that the tiles in play are brighter than those that have
already been played (see Figure 32-6).
At any time during play, the players may converse by typing in the text entry area
at the top of the applet (see Figure 32-7). These messages will appear one at a time in
the other player’s browser’s status line, typically at the bottom of the browser (see
Figure 32-8).
1074 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-5. Scrabblet early in a game
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1075
A
P
P
LY
IN
G
JA
V
A
Figure 32-6. Herb is about to place the D to make HEATED
Figure 32-7. Patrick is complaining about being stuck with the Q without the U
One last word about game play before we get into the source code. The way to win
at this game is to come up with words that score in one direction and also make words
in the other direction. These secondary words tend to be short, two-letter words, but
they add up. In Figure 32-9, Patrick places the Y in DEITY, which will score 21 points
because he gets a face value of 9 doubled to 18, plus he gets to count the word AD,
which runs vertically, for 3 points. Remember that all of the words played with each
turn need to be real words. Eventually, this game will need either an undo for disputed
words or an automatic dictionary checker to resolve conflicts.
The Source Code
Now that you know how to play the game, it is time to examine the source code for the
game. Since several of the classes are quite long, we will sprinkle comments throughout
the code rather than leaving the code till the end.
The APPLET Tag
The APPLET tag for this game is simple. Just name the main class and set the size.
That’s it. There aren’t any <param> tags for Scrabblet. Remember, the bigger you
1076 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-8. Herb replies. Notice Patrick’s last message at the bottom
make the applet, the nicer the board looks. The aspect ratio should be a little taller than
it is wide.
<applet code=Scrabblet.class width=400 height=450>
</applet>
Scrabblet.java
The main applet class is found in Scrabblet.java. At almost 300 lines, this is a fairly
complicated applet class, even though most of the game logic is left to the Board class,
found later in this chapter.
We start with the usual collection of import statements, loading almost every
standard Java package. Then we declare Scrabblet to be a subclass of Applet that
implements ActionListener.
import java.io.*;
import java.net.*;
import java.awt.*;
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1077
A
P
P
LY
IN
G
JA
V
A
Figure 32-9. Patrick scores in two directions!
import java.awt.event.*;
import java.applet.*;
public class Scrabblet extends Applet implements ActionListener {
Next comes the declaration of a large collection of instance variables. The server
is our connection to the web server running our game server. This machine’s name
is stored in serverName. The bag represents the shared bag of letters for our game.
Our opponent has his or her own copy of the bag, which is initialized with the same
random sequence of tiles so the two bags stay in synch. The board is our copy of the
playing board. Our opponent also has a copy of the board, and the game keeps them
in synch after each turn.
If the network server can’t be accessed, the single flag is set, and the applet plays
the game in single-player mode. The boolean ourturn is true whenever it is our turn to
play. If a player can’t find a valid word, the player can pass by clicking on Done twice
in a row without having any tiles on the board. The seen_pass variable is used to mark
if the first Done has been clicked on.
To manage the synchronization of the remote player’s board, we keep a copy of the
tiles selected in theirs. Seeing what the other person has in his or her tray is cheating,
so no hacking this applet to display the contents of theirs! The two strings, name and
others_name, hold our name and our opponent’s name, respectively.
private ServerConnection server;
private String serverName;
private Bag bag;
private Board board;
private boolean single = false;
private boolean ourturn;
private boolean seen_pass = false;
private Letter theirs[] = new Letter[7];
private String name;
private String others_name;
Next, we declare eight variables used to manage the user interface. These are all
AWT components that must be manipulated by the applet in some way. topPanel
holds the prompt and the namefield for getting the user’s name at start-up. The done
button is used to signify that you are done with your turn. The chat TextField is used
to enter chat messages. idList is used to display available opponents. The challenge
button is used to attach us to our opponent. The ican Canvas holds the name and
copyright notice at start-up.
1078 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
private Panel topPanel;
private Label prompt;
private TextField namefield;
private Button done;
private TextField chat;
private List idList;
private Button challenge;
private Canvas ican;
init( )
The init( ) method is called once and simply sets up the BorderLayout, figures out
what Internet host the applet came from, and creates the splash screen canvas.
public void init() {
setLayout(new BorderLayout());
serverName = getCodeBase().getHost();
if (serverName.equals(""))
serverName = "localhost";
ican = new IntroCanvas();
}
start( )
The start( ) method is called whenever the browser redisplays the page in which the
applet is found. The large try block at the beginning is used to catch the case where the
network connection fails. If we succeed in making a new ServerConnection and we’ve
never run start( ) before, we then set up the screen to prompt for the user’s name.
While we are there, we put the splash screen, ican, in the center of the window. In the
case where name is not null, that means the user left the page and has now returned.
We presume we’ve already got the user’s name and jump right to nameEntered( ),
the method that is called when the user types return in the name entry field. The
validate( ) at the end makes sure all of the AWT components are updated properly.
If an exception was thrown, we presume that the net connection failed and go into
single-player mode. The call to start_game( ) gets things rolling.
public void start() {
try {
showStatus("Connecting to " + serverName);
server = new ServerConnection(this, serverName);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1079
A
P
P
LY
IN
G
JA
V
A
server.start();
showStatus("Connected: " + serverName);
if (name == null) {
prompt = new Label("Enter your name here:");
namefield = new TextField(20);
namefield.addActionListener(this);
topPanel = new Panel();
topPanel.setBackground(new Color(255, 255, 200));
topPanel.add(prompt);
topPanel.add(namefield);
add("North", topPanel);
add("Center", ican);
} else {
if (chat != null) {
remove(chat);
remove(board);
remove(done);
}
nameEntered(name);
}
validate();
} catch (Exception e) {
single = true;
start_Game((int)(0x7fffffff * Math.random()));
}
}
stop( )
The stop( ) method is called whenever the user leaves the page with the applet. Here,
we just tell the server that we’ve left. We re-create the network connection in start( ) if
the user returns to the page later.
public void stop() {
if (!single)
server.quit();
}
1080 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
add( )
The add( ) method is called by the ServerConnection whenever a new player enters
the game. We add the player’s name to our List object. Pay special attention to the
formatting of the string in add( ). We use that later to extract certain IDs from the list.
void add(String id, String hostname, String name) {
delete(id); // in case it is already there.
idList.add("(" + id + ")  " + name + "@" + hostname);
showStatus("Choose a player from the list");
}
delete( )
The delete( ) method is called when a player no longer wants to be identified as
available for play. This happens when a player quits or decides to play with someone
else. Here, we hunt down the id string in our list by extracting the values inside
parentheses. If there are no more names on the list (and we aren’t playing the game
already: bag == null), then we display a special message telling the user to hang out
until someone comes to make a challenge.
void delete(String id) {
for (int i = 0; i < idList.getItemCount(); i++) {
String s = idList.getItem(i);
s = s.substring(s.indexOf("(") + 1, s.indexOf(")"));
if (s.equals(id)) {
idList.remove(i);
break;
}
}
if (idList.getItemCount() == 0 && bag == null)
showStatus("Wait for other players to arrive.");
}
getName( )
The getName( ) method is very similar to delete( ), except it simply extracts the name
part of the item and returns it. If the id is not found, then null is returned.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1081
A
P
P
LY
IN
G
JA
V
A
private String getName(String id) {
for (int i = 0; i < idList.getItemCount(); i++) {
String s = idList.getItem(i);
String id1 = s.substring(s.indexOf("(") + 1, s.indexOf(")"));
if (id1.equals(id)) {
return s.substring(s.indexOf(" ") + 3, s.indexOf("@"));
}
}
return null;
}
challenge( )
The challenge( ) method is called by the ServerConnection whenever another player
challenges us to a game. We could have made this method more complicated, so that it
would prompt the user to accept or refuse the challenge, but instead the challenge is
automatically accepted. Notice that the random seed we use to start the game is passed
back to the other player in the accept( ) method. This is used by both sides to initialize
the random state of the tile bag to ensure a synchronous game. We call server.delete( )
to ensure that we are no longer solicited by other players wanting to play against us.
Notice also that we cede the starting turn to the challenger by setting ourturn to false.
// we've been challenged to a game by "id".
void challenge(String id) {
ourturn = false;
int seed = (int)(0x7fffffff * Math.random());
others_name = getName(id);   // who was it?
showStatus("challenged by " + others_name);
// put some confirmation here...
server.accept(id, seed);
server.delete();
start_Game(seed);
}
accept( )
accept( ) is the method called on the remote side in response to the server.accept( )
call just mentioned. Just as the other player deleted himself or herself from the list of
1082 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
available players, so must we call server.delete( ). We take the first turn by setting
ourturn to true.
// our challenge was accepted.
void accept(String id, int seed) {
ourturn = true;
others_name = getName(id);
server.delete();
start_Game(seed);
}
chat( )
The chat( ) method is called by the server whenever the opponent types in his or her
chat window. In this implementation, the method simply shows the chat message in
the browser’s status message. In the future, it might be nice to log these into a
TextArea.
void chat(String id, String s) {
showStatus(others_name + ": " + s);
}
move( )
The move( ) method is called once for each tile your opponent plays. It looks through
the letters saved in theirs to find the one used. If the square is already occupied, the tile
is returned to the player’s tray. Otherwise, the opponent’s letter is moved onto the
board permanently. Next, the tile is replaced in theirs by bag.takeOut( ). If the bag is
empty, a status message appears. The board is repainted to show the new tiles on it.
Note that no scoring is done based on the placement of these tiles. The applet waits
until turn( ) is called to give the score.
// the other guy moved, and placed 'letter' at (x, y).
void move(String letter, int x, int y) {
for (int i = 0; i < 7; i++) {
if (theirs[i] != null && theirs[i].getSymbol().equals(letter)) {
Letter already = board.getLetter(x, y);
if (already != null) {
board.moveLetter(already, 15, 15); // on the tray.
}
board.moveLetter(theirs[i], x, y);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1083
A
P
P
LY
IN
G
JA
V
A
board.commitLetter(theirs[i]);
theirs[i] = bag.takeOut();
if (theirs[i] == null)
showStatus("No more letters");
break;
}
}
board.repaint();
}
turn( )
The turn( ) method is called after all of the opponent’s tiles are moved. The remote
instance of Scrabblet computes the score and sends it to us, so our copy doesn’t have
to redo it. Then the score is reported in the status line, and the setEnabled method
allows us to take a turn. othersTurn( ) tells the board about the score. The board will
reflect the new score at this point.
void turn(int score, String words) {
showStatus(others_name + " played: " + words + " worth " +
score);
done.setEnabled(true);
board.othersTurn(score);
}
quit( )
When the other side quits cleanly, quit( ) is called. It removes the AWT components of
the game and jumps right back into nameEntered( ), described next, to get connected
back into the player list.
void quit(String id) {
showStatus(others_name + " just quit.");
remove(chat);
remove(board);
remove(done);
nameEntered(name);
}
1084 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
nameEntered( )
The nameEntered( ) method is called from actionPerformed( ) whenever ENTER is
pressed in the original prompt for the user’s name. Any AWT components that might
be in the way are removed, and then a new List object, idList, is created to store the
names of the other players. The method also adds a button at the top named challenge,
then notifies the server that we are here by calling setName( ).
private void nameEntered(String s) {
if (s.equals(""))
return;
name = s;
if (ican != null)
remove(ican);
if (idList != null)
remove(idList);
if (challenge != null)
remove(challenge);
idList = new List(10, false);
add("Center", idList);
challenge = new Button("Challenge");
challenge.addActionListener(this);
add("North", challenge);
validate();
server.setName(name);
showStatus("Wait for other players to arrive.");
if (topPanel != null)
remove(topPanel);
}
wepick( ) and theypick( )
The methods wepick( ) and theypick( ) are simply used to start off the game by
picking the seven tiles for each player. It is important that the caller do these in the
right order on each side of the challenge, depending on who goes first. The call to
bag.takeOut( ) gets a single letter permanently out of the shared bag. The call to
board.addLetter( ) places the tile on our tray. For the other side, theypick( ) simply
saves the letters in theirs.
private void wepick() {
for (int i = 0; i < 7; i++) {
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1085
A
P
P
LY
IN
G
JA
V
A
Letter l = bag.takeOut();
board.addLetter(l);
}
}
private void theypick() {
for (int i = 0; i < 7; i++) {
Letter l = bag.takeOut();
theirs[i] = l;
}
}
start_Game( )
In single-player mode, start_Game( ) pops up the splash screen in a Frame window.
It then creates a playing board, passing in no parameters to the constructor, which
indicates single-player mode.
In head-to-head mode, we remove the selection list components and add the chat
window to the applet. We then add the board and Done button to the applet. Next, we
create the bag, and if it is ourturn, wepick( ) is first, then theypick( ). In the case where
we don’t have the first turn, we disable the board and the Done button, and theypick( )
is first. We then force the board to repaint, which initializes it.
private void start_Game(int seed) {
if (single) {
Frame popup = new Frame("Scrabblet");
popup.setSize(400, 300);
popup.add("Center", ican);
popup.setResizable(false);
popup.show();
board = new Board();
showStatus("no server found, playing solo");
ourturn = true;
} else {
remove(idList);
remove(challenge);
board = new Board(name, others_name);
chat = new TextField();
chat.addActionListener(this);
add("North", chat);
1086 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
showStatus("playing against " + others_name);
}
add("Center", board);
done = new Button("Done");
done.addActionListener(this);
add("South", done);
validate();
bag = new Bag(seed);
if (ourturn) {
wepick();
if (!single)
theypick();
} else {
done.setEnabled(false);
theypick();
wepick();
}
board.repaint();
}
challenge_them( )
The challenge_them( ) method is called when the challenge button is clicked. It simply
takes the player you had selected in the idList and sends him or her a challenge( )
message. It removes the list and button to be ready for the game to start.
private void challenge_them() {
String s = idList.getSelectedItem();
if (s == null) {
showStatus("Choose a player from the list then press Challenge");
} else {
remove(challenge);
remove(idList);
String destid = s.substring(s.indexOf('(')+1,
s.indexOf(')'));
showStatus("challenging: " + destid);
server.challenge(destid);  // accept will get called if
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1087
A
P
P
LY
IN
G
JA
V
A
// they accept.
validate();
}
}
our_turn( )
When the Done button is clicked, our_turn( ) is called. First, it checks to see if we’ve
placed tiles in valid locations by calling board.findwords( ) and storing the result in
word. If word is null, then something is amiss with the tiles, and the method shows
that in the status line. If word is ““, then it knows that there were no tiles in play at the
time. In single-player mode, this is ignored. In competition mode, if we click Done
twice in a row without any tiles in play, we will pass our turn to our opponent.
If you have played tiles and they are in legal positions, you have finished your turn,
so ourturn( ) commits the letters to the board. Notice that commit( ) takes the server as
a parameter. It will use this to tell the remote side about the position of each new letter.
Then the method replaces the letters you used. In multiplayer mode, we disable
ourselves and call server.turn( ) to tell the other player it is his or her turn.
private void our_turn() {
String word = board.findwords();
if (word == null) {
showStatus("Illegal letter positions");
} else {
if ("".equals(word)) {
if (single)
return;
if (seen_pass) {
done.setEnabled(false);
server.turn("pass", 0);
showStatus("You passed");
seen_pass = false;
} else {
showStatus("Press done again to pass");
seen_pass = true;
return;
}
} else {
seen_pass = false;
}
showStatus(word);
1088 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
board.commit(server);
for (int i = 0; i < 7; i++) {
if (board.getTray(i) == null) {
Letter l = bag.takeOut();
if (l == null)
showStatus("No more letters");
else
board.addLetter(l);
}
}
if (!single) {
done.setEnabled(false);
server.turn(word, board.getTurnScore());
}
board.repaint();
}
}
actionPerformed( )
The actionPerformed( ) method is used to grab input from the various components the
applet uses. It handles the Challenge and Done buttons, as well as the name entry field
and the chat entry field.
public void actionPerformed(ActionEvent ae) {
Object source = ae.getSource();
if(source == chat) {
server.chat(chat.getText());
chat.setText("");
}
else if(source == challenge) {
challenge_them();
}
else if(source == done) {
our_turn();
}
else if(source == namefield) {
TextComponent tc = (TextComponent)source;
nameEntered(tc.getText());
}
}
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1089
A
P
P
LY
IN
G
JA
V
A
IntroCanvas.java
The IntroCanvas subclass of Canvas is very simple. It just overrides paint( ) to draw
the name of the applet and a brief copyright notice. It creates some custom colors and
fonts. The display strings are held in static variables simply for clarity.
import java.awt.*;
import java.awt.event.*;
class IntroCanvas extends Canvas {
private Color pink = new Color(255, 200, 200);
private Color blue = new Color(150, 200, 255);
private Color yellow = new Color(250, 220, 100);
private int w, h;
private int edge = 16;
private static final String title = "Scrabblet";
private static final String name =
"Copyright 1999 - Patrick Naughton";
private static final String book =
"Chapter 32 from 'Java: The Complete Reference'";
private Font namefont, titlefont, bookfont;
IntroCanvas() {
setBackground(yellow);
titlefont = new Font("SansSerif", Font.BOLD, 58);
namefont = new Font("SansSerif", Font.BOLD, 18);
bookfont = new Font("SansSerif", Font.PLAIN, 12);
addMouseListener(new MyMouseAdapter());
}
d( )
The private method d( ) is a convenience method that paints centered text with an
optional isometric offset. This is used to give the main title a highlight/shadow effect
by drawing a white string up and to the left by 1, a black string down and to the right
by 1, and then drawing the string one last time in pink, not offset at all.
private void d(Graphics g, String s, Color c, Font f, int y,
int off) {
g.setFont(f);
FontMetrics fm = g.getFontMetrics();
g.setColor(c);
1090 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
g.drawString(s, (w - fm.stringWidth(s)) / 2 + off, y + off);
}
public void paint(Graphics g) {
Dimension d = getSize();
w = d.width;
h = d.height;
g.setColor(blue);
g.fill3DRect(edge, edge, w - 2 * edge, h - 2 * edge, true);
d(g, title, Color.black, titlefont, h / 2, 1);
d(g, title, Color.white, titlefont, h / 2, -1);
d(g, title, pink, titlefont, h / 2, 0);
d(g, name, Color.black, namefont, h * 3 / 4, 0);
d(g, book, Color.black, bookfont, h * 7 / 8, 0);
}
mousePressed( )
In the following code fragment, notice that MyMouseAdapter is an inner class that
extends MouseAdapter. It overrides the mousePressed( ) method to cause this canvas’
parent to hide( ) if it is clicked on. This is only useful in single-player mode to dismiss
the pop-up frame.
class MyMouseAdapter extends MouseAdapter {
public void mousePressed(MouseEvent me) {
((Frame)getParent()).setVisible(false);
}
}
}
Board.java
The Board class encapsulates most of the game logic as well as the look and feel of the
board. It is the biggest class in the game, weighing in at over 500 lines of code. There
are several private variables that store the game state. The 15×15 array of Letters
named board is used to store the tiles on each square of the board. The tray array holds
the Letters that are currently on our tray. Remember that the Scrabblet applet class
holds the seven Letters from our opponent. The Point objects orig and here are used to
remember letter positions. The name and others_name variables are used simply to
display names for the scoreboard. In single-player mode, both will be null. The two
players’ scores are stored in total_score and others_score, while our last turn’s result is
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1091
A
P
P
LY
IN
G
JA
V
A
stored in turn_score. The two constructors set up the names of the players, or leave
them blank in single-player mode.
import java.awt.*;
import java.awt.event.*;
class Board extends Canvas {
private Letter board[][] = new Letter[15][15];
private Letter tray[] = new Letter[7];
private Point orig = new Point(0,0);
private Point here = new Point(0,0);
private String name;
private int total_score = 0;
private int turn_score = 0;
private int others_score = 0;
private String others_name = null;
Board(String our_name, String other_name) {
name = our_name;
others_name = other_name;
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
Board() {
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
othersTurn( ), getTurnScore( ), and getTray( )
These three methods are used to control the access to several private variables.
First, othersTurn( ) is called by the applet when the other player finishes a turn. It
increments the player’s score and repaints that area of the board to reflect the change.
The getTurnScore( ) method simply returns the saved last turn’s score, after making
sure the scoreboard is painted with the correct value. The applet uses this method to
pass the score to our opponent, where it will eventually call othersTurn( ) on the
remote machine. The getTray( ) method simply provides a read-only access to the
private tray array.
1092 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
void othersTurn(int score) {
others_score += score;
paintScore();
repaint();
}
int getTurnScore() {
paintScore();
return turn_score;
}
Letter getTray(int i) {
return tray[i];
}
addLetter( )
The addLetter( ) method is used to place a letter on the tray. The letter is placed in the
first slot that is empty. If the method can’t find an empty slot, it returns false.
synchronized boolean addLetter(Letter l) {
for (int i = 0; i < 7; i++) {
if (tray[i] == null) {
tray[i] = l;
moveLetter(l, i, 15);
return true;
}
}
return false;
}
existingLetterAt( )
The private method existingLetterAt( ) is used to check a board position to see if it has
a letter in it that is not currently in play. This is used by findwords( ) next to make sure
that at least one letter in a turn is touching an already existing letter.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1093
A
P
P
LY
IN
G
JA
V
A
private boolean existingLetterAt(int x, int y) {
Letter l = null;
return (x >= 0 && x <= 14 && y >= 0 && y <= 14
&& (l = board[y][x]) != null && l.recall() == null);
}
findwords( )
findwords( ) is a very large method used to examine the state of the board for a legal
turn. If the rules for letter placement are broken, then null is returned. If no tiles were
in play, then ““ is returned. If all of the tiles played in this turn are legal, then the list of
words they formed is returned as a string containing the space-separated words. The
instance variables turn_score and total_score are updated to reflect the value of the
words that were just played.
First findwords( ) counts the tiles at play, ntiles, storing them in a separate array
called atplay. Next, it looks at the first two tiles (if more than one was played) to
determine if they are vertically or horizontally oriented. Then it inspects all of the other
tiles at play, to make sure they are along the same line. If any of the tiles is out of that
row or column, the method returns null.
synchronized String findwords() {
String res = "";
turn_score = 0;
int ntiles = 0;
Letter atplay[] = new Letter[7];
for (int i = 0; i < 7; i++) {
if (tray[i] != null && tray[i].recall() != null) {
atplay[ntiles++] = tray[i];
}
}
if (ntiles == 0)
return res;
boolean horizontal = true; // if there's one tile,
// call it horizontal
boolean vertical = false;
if (ntiles > 1) {
int x = atplay[0].x;
int y = atplay[0].y;
horizontal = atplay[1].y == y;
1094 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
vertical = atplay[1].x == x;
if (!horizontal && !vertical) // diagonal...
return null;
for (int i = 2; i < ntiles; i++) {
if (horizontal && atplay[i].y != y
|| vertical && atplay[i].x != x)
return null;
}
}
Next, it looks at each tile to be sure that at least one of them is touching an existing
tile on one of its four sides. A special case is made for the beginning of the game: if the
center tile is covered and more than one tile is played, it is legal.
// make sure that at least one played tile is
// touching at least one existing tile.
boolean attached = false;
for (int i = 0; i < ntiles; i++) {
Point p = atplay[i].recall();
int x = p.x;
int y = p.y;
if ((x == 7 && y == 7 && ntiles > 1) ||
existingLetterAt(x-1, y) || existingLetterAt(x+1, y) ||
existingLetterAt(x, y-1) || existingLetterAt(x, y+1)) {
attached = true;
break;
}
}
if (!attached) {
return null;
}
This next loop iterates over every letter in the main word, (i == –1), then comes
back again for each letter (i == 0..ntiles), which might also create a word orthogonal to
the main direction, which is managed via horizontal.
// we use -1 to mean check the major direction first
// then 0..ntiles checks for words orthogonal to it.
for (int i = -1; i < ntiles; i++) {
Point p = atplay[i==-1?0:i].recall(); // where is it?
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1095
A
P
P
LY
IN
G
JA
V
A
int x = p.x;
int y = p.y;
int xinc, yinc;
if (horizontal) {
xinc = 1;
yinc = 0;
} else {
xinc = 0;
yinc = 1;
}
int mult = 1;
String word = "";
int word_score = 0;
The method then picks each tile and moves left or up from it to find the first tile
in each word. Once at the beginning of the word, it moves right or down from it,
inspecting every letter. It counts the letters in letters_seen. For each letter, it determines
the point contribution based on the bonus multiplier beneath it. If the square is played
for the first time, the multiplier value is applied; otherwise the tile is counted at face
value. This score is accumulated in word_score.
// here we back up to the top/left-most letter
while (x >= xinc && y >= yinc &&
board[y-yinc][x-xinc] != null) {
x -= xinc;
y -= yinc;
}
int n = 0;
int letters_seen = 0; // letters we've just played.
Letter l;
while (x < 15 && y < 15 && (l = board[y][x]) != null) {
word += l.getSymbol();
int lscore = l.getPoints();
if (l.recall() != null) {  // one we just played...
Color t = tiles[y < 8 ? y : 14 - y][x < 8 ? x : 14 - x];
if (t == w3)
mult *= 3;
else if (t == w2)
1096 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
mult *= 2;
else if (t == l3)
lscore *= 3;
else if (t == l2)
lscore *= 2;
if (i == -1) {
letters_seen++;
}
}
word_score += lscore;
n++;
x += xinc;
y += yinc;
}
word_score *= mult;
One last error check is done on the main word only. Since the loop ends whenever
it hits a blank square or the edge of the board, it should cover all of the freshly played
tiles, as well as some previously played ones. If it sees fewer tiles, then there must have
been a gap in them, which is an illegal position, so it returns null. If that test is passed,
it checks to see if all seven tiles were played, awarding a 50-point bonus if they were.
After inspecting the main word, findwords( ) inverts the sense of horizontal and looks
for orthogonal words on the subsequent passes.
if (i == -1) {     // first pass...
// if we didn't see all the letters, then there was a gap,
// which is an illegal tile position.
if (letters_seen != ntiles) {
return null;
}
if (ntiles == 7) {
turn_score += 50;
}
// after the first pass, switch to looking the other way.
horizontal = !horizontal;
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1097
A
P
P
LY
IN
G
JA
V
A
As findwords( ) walks across the word, it needs to make sure that it only scores
letters that form at least two-letter words. In this case, it adds the word_score to the
turn_score and appends this word to the result string. Once all of the letters have been
inspected, it totals the score and returns.
if (n < 2)  // don't count single letters twice.
continue;
turn_score += word_score;
res += word + " ";
}
total_score += turn_score;
return res;
}
commit( ) and commitLetter( )
The commit( ) and commitLetter( ) methods commit the letters that were tentatively
placed on the board. These letters are removed from the tray and painted in a darker
color on the board. As each letter is committed, commit( ) notifies the server of the
position of each letter by calling move( ) so that the opponent’s board can be updated.
synchronized void commit(ServerConnection s) {
for (int i = 0 ; i < 7 ; i++) {
Point p;
if (tray[i] != null && (p = tray[i].recall()) != null) {
if (s != null)  // there's a server connection
s.move(tray[i].getSymbol(), p.x, p.y);
commitLetter(tray[i]);  // marks this as not in play.
tray[i] = null;
}
}
}
void commitLetter(Letter l) {
if (l != null && l.recall() != null) {
l.paint(offGraphics, Letter.DIM);
l.remember(null);   // marks this as not in play.
}
}
1098 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
update( ) and paint( )
Many private variables are declared here to provide easy access to the dimensions of
the board. This code also declares two offscreen buffers, one to be used as the image of
the board and all of the permanently set tiles and another to use as a double buffer for
the display. The update( ) method simply calls paint( ) to avoid flicker. The paint( )
method makes a quick call to checksize( ) to make sure all of the buffers have been
created, then checks to see if we are dragging a letter around by means of pick != null.
If so, then paint( ) makes a copy of the offscreen graphics context and clips it to the
bounds of the letter it is painting, x0, y0, w0, h0. Next, it clips the onscreen graphics
context to the same rectangle. This will minimize the number of pixels it will have to
move for each move of the mouse.
To paint, we copy the background image, offscreen, then call paint on each
letter in the tray with the setting of NORMAL. We paint the letter we are dragging
around in the BRIGHT mode. Finally, we copy the double buffer image,
offscreen2, to the screen.
private Letter pick;  // the letter being dragged around.
private int dx, dy;   // offset to topleft corner of pick.
private int lw, lh;   // letter width and height.
private int tm, lm;   // top and left margin.
private int lt;       // line thickness (between tiles).
private int aw, ah;   // letter area size.
private Dimension offscreensize;
private Image offscreen;
private Graphics offGraphics;
private Image offscreen2;
private Graphics offGraphics2;
public void update(Graphics g) {
paint(g);
}
public synchronized void paint(Graphics g) {
Dimension d = checksize();
Graphics gc = offGraphics2;
if (pick != null) {
gc = gc.create();
gc.clipRect(x0, y0, w0, h0);
g.clipRect(x0, y0, w0, h0);
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1099
A
P
P
LY
IN
G
JA
V
A
gc.drawImage(offscreen, 0, 0, null);
for (int i = 0 ; i < 7 ; i++) {
Letter l = tray[i];
if (l != null && l != pick)
l.paint(gc, Letter.NORMAL);
}
if (pick != null)
pick.paint(gc, Letter.BRIGHT);
g.drawImage(offscreen2, 0, 0, null);
}
LetterHit( )
LetterHit( ) returns the letter that is under the point x,y and returns null if no letter
is there.
Letter LetterHit(int x, int y) {
for (int i = 0; i < 7; i++) {
if (tray[i] != null && tray[i].hit(x, y)) {
return tray[i];
}
}
return null;
}
unplay( )
This simple method removes a letter from play that was placed on the board but was
not yet committed.
private void unplay(Letter let) {
Point p = let.recall();
if (p != null) {
board[p.y][p.x] = null;
let.remember(null);
}
}
1100 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
moveToTray( )
The moveToTray( ) method is just a simple convenience to compute the screen position
of a letter in a given tray slot.
private void moveToTray(Letter l, int i) {
int x = lm + (lw + lt) * i;
int y = tm + ah - 2 * lt;
l.move(x, y);
}
dropOnTray( )
The dropOnTray( ) method is used whenever we drop a letter over the tray area or off
the board anywhere. This allows us to shuffle the contents of the tray as well as simply
return tiles from the board.
private void dropOnTray(Letter l, int x) {
unplay(l); // unhook where we were.
// find out what slot this letter WAS in.
int oldx = 0;
for (int i = 0 ; i < 7 ; i++) {
if (tray[i] == l) {
oldx = i;
break;
}
}
// if the slot we dropped on was empty,
// find the rightmost occupied slot.
if (tray[x] == null) {
for (int i = 6 ; i >= 0 ; i--) {
if (tray[i] != null) {
x = i;
break;
}
}
}
// if the slot we dropped on was from a tile already
// played on the board, just swap slots with it.
if (tray[x].recall() != null) {
tray[oldx] = tray[x];
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1101
A
P
P
LY
IN
G
JA
V
A
} else {
// we are just rearranging a tile already on the tray.
if (oldx < x) {   // shuffle left.
for (int i = oldx ; i < x ; i++) {
tray[i] = tray[i+1];
if (tray[i].recall() == null)
moveToTray(tray[i], i);
}
} else {          // shuffle right.
for (int i = oldx ; i > x ; i--) {
tray[i] = tray[i-1];
if (tray[i].recall() == null)
moveToTray(tray[i], i);
}
}
}
tray[x] = l;
moveToTray(l, x);
}
getLetter( )
getLetter( ) is a simple read-only wrapper on the board array.
Letter getLetter(int x, int y) {
return board[y][x];
}
moveLetter( )
The moveLetter( ) method handles the cases where we want to move tiles to board
positions or set them on the tray. If the x,y position is out of range for the board, then
the tray is used. When a letter is moved to the board, it must be a blank slot, otherwise
the letter is sent back to the value stored in orig.
void moveLetter(Letter l, int x, int y) {
if (y > 14 || x > 14 || y < 0 || x < 0) {
// if we are off the board.
if (x > 6)
x = 6;
if (x < 0)
1102 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
x = 0;
dropOnTray(l, x);
} else {
if (board[y][x] != null) {
x = orig.x;
y = orig.y;
} else {
here.x = x;
here.y = y;
unplay(l);
board[y][x] = l;
l.remember(here);
// turn it back into pixels
x = lm + (lw + lt) * x;
y = tm + (lh + lt) * y;
}
l.move(x, y);
}
}
checksize( )
This method has a misleading name. checksize( ) does a lot more than verify the size of
the applet, but it is convenient to do this kind of initialization once, when we confirm
the size of the applet. This method contains the drawing code for the main board
pattern. It paints all of the squares, including the colors and the bonus score text.
private Color bg = new Color(175, 185, 175);
private Color w3 = new Color(255, 50, 100);
private Color w2 = new Color(255, 200, 200);
private Color l3 = new Color(75, 75, 255);
private Color l2 = new Color(150, 200, 255);
private Color tiles[][] = {
{w3, bg, bg, l2, bg, bg, bg, w3},
{bg, w2, bg, bg, bg, l3, bg, bg},
{bg, bg, w2, bg, bg, bg, l2, bg},
{l2, bg, bg, w2, bg, bg, bg, l2},
{bg, bg, bg, bg, w2, bg, bg, bg},
{bg, l3, bg, bg, bg, l3, bg, bg},
{bg, bg, l2, bg, bg, bg, l2, bg},
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1103
A
P
P
LY
IN
G
JA
V
A
{w3, bg, bg, l2, bg, bg, bg, w2}
};
private Dimension checksize() {
Dimension d = getSize();
int w = d.width;
int h = d.height;
if (w < 1 || h < 1)
return d;
if ((offscreen == null) ||
(w != offscreensize.width) ||
(h != offscreensize.height)) {
System.out.println("updating board: " + w + " x " + h + "\r");
offscreen = createImage(w, h);
offscreensize = d;
offGraphics = offscreen.getGraphics();
offscreen2 = createImage(w, h);
offGraphics2 = offscreen2.getGraphics();
offGraphics.setColor(Color.white);
offGraphics.fillRect(0,0,w,h);
// lt is the thickness of the white lines between tiles.
// gaps is the sum of all the whitespace.
// lw, lh are the dimensions of the tiles.
// aw, ah are the dimensions of the entire board
// lm, tm are the left and top margin to center aw, ah in the applet.
lt = 1 + w / 400;
int gaps = lt * 20;
lw = (w - gaps) / 15;
lh = (h - gaps - lt * 2) / 16; // compensating for tray height;
aw = lw * 15 + gaps;
ah = lh * 15 + gaps;
lm = (w - aw) / 2 + lt;
tm = (h - ah - (lt * 2 + lh)) / 2 + lt;
1104 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
offGraphics.setColor(Color.black);
offGraphics.fillRect(lm,tm,aw-2*lt,ah-2*lt);
lm += lt;
tm += lt;
offGraphics.setColor(Color.white);
offGraphics.fillRect(lm,tm,aw-4*lt,ah-4*lt);
lm += lt;
tm += lt;
int sfh = (lh > 30) ? lh / 4 : lh / 2;
Font font = new Font("SansSerif", Font.PLAIN, sfh);
offGraphics.setFont(font);
for (int j = 0, y = tm; j < 15; j++, y += lh + lt) {
for (int i = 0, x = lm; i < 15; i++, x += lw + lt) {
Color c = tiles[j < 8 ? j : 14 - j][i < 8 ? i : 14 - i];
offGraphics.setColor(c);
offGraphics.fillRect(x, y, lw, lh);
offGraphics.setColor(Color.black);
if (lh > 30) {
String td = (c == w2 || c == l2) ? "DOUBLE" :
(c == w3 || c == l3) ? "TRIPLE" : null;
String wl = (c == l2 || c == l3) ? "LETTER" :
(c == w2 || c == w3) ? "WORD" : null;
if (td != null) {
center(offGraphics, td, x, y + 2 + sfh, lw);
center(offGraphics, wl, x, y + 2 * (2 + sfh), lw);
center(offGraphics, "SCORE", x, y + 3 * (2 + sfh), lw);
}
} else {
String td = (c == w2 || c == l2) ? "2" :
(c == w3 || c == l3) ? "3" : null;
String wl = (c == l2 || c == l3) ? "L" :
(c == w2 || c == w3) ? "W" : null;
if (td != null) {
center(offGraphics, td + wl, x,
y + (lh - sfh) * 4 / 10 + sfh, lw);
}
}
}
}
Color c = new Color(255, 255, 200);
offGraphics.setColor(c);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1105
A
P
P
LY
IN
G
JA
V
A
offGraphics.fillRect(lm, tm + ah - 3 * lt, 7 * (lw + lt), lh +
2 * lt);
Letter.resize(lw, lh);
// if we already have some letters, place them.
for (int i = 0; i < 7; i++) {
if (tray[i] != null) {
moveToTray(tray[i], i);
}
}
paintScore();
}
return d;
}
center( )
center( ) is a convenience routine that checksize( ) uses to center the “Double Letter
Score” text.
private void center(Graphics g, String s, int x, int y, int w) {
x += (w - g.getFontMetrics().stringWidth(s)) / 2;
g.drawString(s, x, y);
}
paintScore( )
The paintScore( ) method paints the two players’ scores or just the one score in
single-player mode.
private void paintScore() {
int x = lm + (lw + lt) * 7 + lm;
int y = tm + ah - 3 * lt;
int h = lh + 2 * lt;
Font font = new Font("TimesRoman", Font.PLAIN, h/2);
offGraphics.setFont(font);
FontMetrics fm = offGraphics.getFontMetrics();
offGraphics.setColor(Color.white);
offGraphics.fillRect(x, y, aw, h);
offGraphics.setColor(Color.black);
1106 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
if (others_name == null) {
int y0 = (h - fm.getHeight()) / 2 + fm.getAscent();
offGraphics.drawString("Score: " + total_score, x, y + y0);
} else {
h/=2;
int y0 = (h - fm.getHeight()) / 2 + fm.getAscent();
offGraphics.drawString(name + ": " + total_score, x, y + y0);
offGraphics.drawString(others_name + ": " + others_score,
x, y + h + y0);
}
}
private int x0, y0, w0, h0;
selectLetter( )
The selectLetter( ) method checks the mouse position to see if the cursor is over a letter.
If so, it stores that in pick and computes how far the mouse was from the upper-left
corner of the letter, which is stored in dx, dy. It also remembers the original position of
this letter in orig.
private void selectLetter(int x, int y) {
pick = LetterHit(x, y);
if(pick != null) {
dx = pick.x - x;
dy = pick.y - y;
orig.x = pick.x;
orig.y = pick.y;
}
repaint();
}
dropLetter( )
In dropLetter( ), the user has dropped the letter if he or she was carrying one. It
determines which square on the board the letter was over when it was dropped. It then
calls moveLetter( ) to attempt to move the letter to that square.
private void dropLetter(int x, int y) {
if(pick != null) {
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1107
A
P
P
LY
IN
G
JA
V
A
// find the center of the tile
x += dx + lw / 2;
y += dy + lh / 2;
// find the tile index
x = (x - lm) / (lw + lt);
y = (y - tm) / (lh + lt);
moveLetter(pick, x, y);
pick = null;
repaint();
}
}
dragLetter( )
The dragLetter( ) method is handled differently than the other mouse-related events.
This is mainly due to performance considerations. The goal is to have as smooth an
interaction with the user as possible. dragLetter( ) goes to some length to compute the
bounding box of where the tile was before this drag plus where it is now. It then
directly calls paint(getGraphics( )). This is nonstandard Java applet programming, but
it performs much more reliably.
private void dragLetter(int x, int y) {
if (pick != null) {
int ox = pick.x;
int oy = pick.y;
pick.move(x + dx, y + dy);
x0 = Math.min(ox, pick.x);
y0 = Math.min(oy, pick.y);
w0 = pick.w + Math.abs(ox - pick.x);
h0 = pick.h + Math.abs(oy - pick.y);
paint(getGraphics());
}
}
mousePressed( )
In the following code fragment, notice that MyMouseAdapter is an inner class that
extends MouseAdapter. It overrides the mousePressed( ) and mouseReleased( )
methods.
1108 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The mousePressed( ) method invokes the selectLetter( ) method to do the
necessary processing. The x and y coordinates of the current mouse position are
obtained from the argument supplied to the mousePressed( ) method.
class MyMouseAdapter extends MouseAdapter {
public void mousePressed(MouseEvent me) {
selectLetter(me.getX(), me.getY());
}
mouseReleased( )
The mouseReleased( ) method invokes the dropLetter( ) method to do the necessary
processing. The x and y coordinates of the current mouse position are obtained from
the argument supplied to the mouseReleased( ) method.
public void mouseReleased(MouseEvent me) {
dropLetter(me.getX(), me.getY());
}
}
mouseDragged( )
In the following code fragment, notice that MyMouseMotionAdapter is an inner class
that extends MouseMotionAdapter. It overrides the mouseDragged( ) method.
The mouseDragged( ) method invokes the dragLetter( ) method to do the necessary
processing. The x and y coordinates of the current mouse position are obtained from
the argument supplied to the mouseDragged( ) method.
class MyMouseMotionAdapter extends MouseMotionAdapter {
public synchronized void mouseDragged(MouseEvent me) {
dragLetter(me.getX(), me.getY());
}
}
}
Bag.java
The Bag class is very clean compared with Board. It is a simple abstraction for the bag
of letters. When you create a Bag, you pass in a random seed, which allows you to
create two bags that are random but the same by passing in the same random seed. The
random number generator is stored in rand. There are two somewhat strange arrays of
integers, named letter_counts and letter_points. Both arrays are 27 slots long. They
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1109
A
P
P
LY
IN
G
JA
V
A
represent the blank tile in slot 0, and A through Z in 1 through 26. The letter_counts
array says how many of each letter are in a full bag. For example, letter_counts[1] is 9,
which says there are nine A tiles in the bag. Similarly, the letter_points array maps
each letter to its point value. The A tiles are worth only 1 point, and the lone Z is worth
10. There are 100 letters stored in the array called letters. The number of letters actually
left in the bag during game play is stored in n.
import java.util.Random;
class Bag {
private Random rand;
private int letter_counts[] = {
2, 9, 2, 2, 4, 12, 2, 3, 2, 9, 1, 1, 4, 2,
6, 8, 2, 1, 6, 4, 6, 4, 2, 2, 1, 2, 1
};
private int letter_points[] = {
0, 1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3,
1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10
};
private Letter letters[] = new Letter[100];
private int n = 0;
Bag( )
The Bag constructor takes the seed and makes a Random object out of it. It then scans
through the letter_counts array, making the right number of new Letter objects, being
careful to replace the blank tile with an asterisk. It then calls putBack( ) for each letter,
to put them in the bag.
Bag(int seed) {
rand = new Random(seed);
for (int i = 0; i < letter_counts.length; i++) {
for (int j = 0; j < letter_counts[i]; j++) {
Letter l = new Letter(i == 0 ? '*' : (char)('A' + i - 1),
letter_points[i]);
putBack(l);
}
}
}
1110 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
takeOut( )
This next method is slightly clever and a little inefficient, but in a noncritical way.
takeOut( ) picks a random number between 0 and n –1. It then extracts the letter at
that offset from the letters array. It closes the hole over that slot in letters using
System.arraycopy( ). Then it decrements n and returns the letter.
synchronized Letter takeOut() {
if (n == 0)
return null;
int i = (int)(rand.nextDouble() * n);
Letter l = letters[i];
if (i != n - 1)
System.arraycopy(letters, i + 1, letters, i, n - i - 1);
n--;
return l;
}
putBack( )
The putBack( ) method is used by the constructor to put the tiles in the bag originally.
It could also be used by a future game enhancement that would let players trade in
tiles they were unhappy with in exchange for losing a turn. It simply puts the letter
back at the end of the array.
synchronized void putBack(Letter l) {
letters[n++] = l;
}
}
Letter.java
The Letter class is fairly clean in that it doesn’t know anything about the game or the
board. It merely encapsulates the position and visual rendering of a single letter. It uses
several static variables to hold information about fonts and sizes. This is done so that
the applet doesn’t end up with 100 fonts in memory at once. This has the side effect
that a browser page cannot contain two instances of the Scrabblet applet if they each
have different sizes. The second one to initialize will overwrite the values in these
static variables.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1111
A
P
P
LY
IN
G
JA
V
A
The w and h variables hold the constant width and height of every letter. The font
and smfont variables are the AWT font objects for the big letter and the smaller point
value. The ints y0 and ys0 store the offset of the baseline of the letter and the points,
respectively. A few constants are provided to be passed back into paint( ) to describe
which color state to paint in: NORMAL, DIM, and BRIGHT mode.
import java.awt.*;
class Letter {
static int w, h;
private static Font font, smfont;
private static int y0, ys0;
private static int lasth = -1;
static final int NORMAL = 0;
static final int DIM = 1;
static final int BRIGHT = 2;
colors[ ], mix( ), gain( ), and clamp( )
The colors array is initialized statically with nine color objects—three sets of three
colors. The mix( ) method is used to take a set of RGB values like 250, 220, 100 and turn
them into three colors, which can be used to provide 3-D–like highlights and lowlights.
The mix( ) method calls on gain( ) to boost or decimate the brightness of a given color
and calls on clamp( ) to make sure it remains in the legal range.
private static Color colors[][] = {
mix(250, 220, 100),   // normal
mix(200, 150, 80),    // dim
mix(255, 230, 150)    // bright
};
private static Color mix(int r, int g, int b)[] {
Color arr[] = new Color[3];
arr[NORMAL] = new Color(r, g, b);
arr[DIM] = gain(arr[0], .71);
arr[BRIGHT] = gain(arr[0], 1.31);
return arr;
}
private static int clamp(double d) {
return (d < 0) ? 0 : ((d > 255) ? 255 : (int) d);
}
1112 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
private static Color gain(Color c, double f) {
return new Color(
clamp(c.getRed() * f),
clamp(c.getGreen() * f),
clamp(c.getBlue() * f));
}
Instance Variables
The valid flag is used to make sure that all of the sizing variables are set up exactly
once, the first time this Letter is painted. There are several variables cached here to
keep from having to do lots of computation each time the applet paints—such as, x0,
w0, xs0, ws0, and gap—which are all explained in the following comments. The tile
Point object is used to remember which square on the 15×15 board this Letter is on. If
this variable is null, then the Letter is not on the board. The x,y pair is used to exactly
locate the Letter.
private boolean valid = false;
// quantized tile position of Letter. (just stored here).
private Point tile = null;
int x, y;               // position of Letter.
private int x0;         // offset of symbol on tile.
private int w0;         // width in pixels of symbol.
private int xs0;        // offset of points on tile.
private int ws0;        // width in pixels of points.
private int gap = 1;    // pixels between symbol and points.
Letter( ), getSymbol( ), and getPoints( )
The symbol is a string that holds the letter displayed, and points is the point value of
this letter. These are both initialized by the only constructor and returned by the
wrapper methods getSymbol( ) and getPoints( ), respectively.
private String symbol;
private int points;
Letter(char s, int p) {
symbol = "" + s;
points = p;
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1113
A
P
P
LY
IN
G
JA
V
A
String getSymbol() {
return symbol;
}
int getPoints() {
return points;
}
move( ), remember( ), and recall( )
The move( ) method is used to tell this tile where to draw. The remember( ) method,
however, is more complicated. It can be called with a null, which means that this tile
should “forget” where it was. This indicates that the letter is not in play. Otherwise, it
tells which coordinate on the board this letter is occupying. This state is inspected by a
call to recall( ).
void move(int x, int y) {
this.x = x;
this.y = y;
}
void remember(Point t) {
if (t == null) {
tile = t;
} else {
tile = new Point(t.x, t.y);
}
}
Point recall() {
return tile;
}
resize( )
The resize( ) method is called once by the board in order to tell every letter how big to
be. Remember, w and h are static, so this affects all Letter instances at once.
static void resize(int w0, int h0) {
w = w0;
h = h0;
}
1114 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
hit( )
The hit( ) method returns true if the xp,yp pair passed in falls inside the bounds of
this Letter.
boolean hit(int xp, int yp) {
return (xp >= x && xp < x + w && yp >= y && yp < y + h);
}
validate( )
The validate( ) method is used to load the fonts to find out how big the letters are,
to decide where to paint them. This information is cached in the private variables
discussed earlier. The results of these calculations are used next in paint( ).
private int font_ascent;
void validate(Graphics g) {
FontMetrics fm;
if (h != lasth) {
font = new Font("SansSerif", Font.BOLD, (int)(h * .6));
g.setFont(font);
fm = g.getFontMetrics();
font_ascent = fm.getAscent();
y0 = (h - font_ascent) * 4 / 10 + font_ascent;
smfont = new Font("SansSerif", Font.BOLD, (int)(h * .3));
g.setFont(smfont);
fm = g.getFontMetrics();
ys0 = y0 + fm.getAscent() / 2;
lasth = h;
}
if (!valid) {
valid = true;
g.setFont(font);
fm = g.getFontMetrics();
w0 = fm.stringWidth(symbol);
g.setFont(smfont);
fm = g.getFontMetrics();
ws0 = fm.stringWidth("" + points);
int slop = w - (w0 + gap + ws0);
x0 = slop / 2;
if (x0 < 1)
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1115
A
P
P
LY
IN
G
JA
V
A
x0 = 1;
xs0 = x0 + w0 + gap;
if (points > 9)
xs0--;
}
}
paint( )
The paint( ) method is called by the board. It passes in an integer, i, which is one of
NORMAL, BRIGHT, or DIM from this class. That is used as an index into the colors
array to select the base color. A sequence of rectangles is filled to create the appearance
of a 3-D highlighted and shadowed button. If points is greater than zero, indicating a
nonblank letter, then the main letter is drawn, and its point value is drawn next to it.
void paint(Graphics g, int i) {
Color c[] = colors[i];
validate(g);
g.setColor(c[NORMAL]);
g.fillRect(x, y, w, h);
g.setColor(c[BRIGHT]);
g.fillRect(x, y, w - 1, 1);
g.fillRect(x, y + 1, 1, h - 2);
g.setColor(Color.black);
g.fillRect(x, y + h - 1, w, 1);
g.fillRect(x + w - 1, y, 1, h - 1);
g.setColor(c[DIM]);
g.fillRect(x + 1, y + h - 2, w - 2, 1);
g.fillRect(x + w - 2, y + 1, 1, h - 3);
g.setColor(Color.black);
if (points > 0) {
g.setFont(font);
g.drawString(symbol, x + x0, y + y0);
g.setFont(smfont);
g.drawString("" + points, x + xs0, y + ys0);
}
}
}
1116 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
ServerConnection.java
The last class in the client side of this applet is ServerConnection, which encapsulates
the communication with the server and our opponent. There are several variables
declared at the beginning of the class. The socket port number to attach to on the server
is 6564. CRLF is the Internet constant string representing end-of-line. The I/O streams
from and to the server are in and out, respectively. The unique ID by which this
connection is known on the server is stored in id. The ID that we are connected to as
an opponent is stored in toid. The Scrabblet applet we are connecting for is scrabblet.
import java.io.*;
import java.net.*;
import java.util.*;
class ServerConnection implements Runnable {
private static final int port = 6564;
private static final String CRLF = "\r\n";
private BufferedReader in;
private PrintWriter out;
private String id, toid = null;
private Scrabblet scrabblet;
ServerConnection( )
The ServerConnection constructor takes the name of an Internet site to attach to and
attempts to open a socket to the right port on that host. If that succeeds, it wraps an
InputStreamReader and a BufferedReader around the input and a PrintWriter around
the output. If the connection fails, an exception is thrown to the caller.
public ServerConnection(Scrabblet sc, String site) throws
IOException {
scrabblet = sc;
Socket server = new Socket(site, port);
in = new BufferedReader(new
InputStreamReader(server.getInputStream()));
out = new PrintWriter(server.getOutputStream(), true);
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1117
A
P
P
LY
IN
G
JA
V
A
readline( )
The readline( ) method is merely a convenience function that converts the IOException
from a readLine( ) into a simple null return.
private String readline() {
try {
return in.readLine();
} catch (IOException e) {
return null;
}
}
setName( ) and delete( )
The setName( ) method tells the server to associate this name with us, and the delete( )
method is used to remove us from any lists the server is keeping.
void setName(String s) {
out.println("name " + s);
}
void delete() {
out.println("delete " + id);
}
setTo( ) and send( )
The setTo( ) method binds the ID of the opponent. Future send( ) calls will go to this
player.
void setTo(String to) {
toid = to;
}
void send(String s) {
if (toid != null)
out.println("to " + toid + " " + s);
}
1118 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
challenge( ), accept( ), chat( ), move( ), turn( ), and quit( )
The following short methods send one-line messages from this client to the server,
which will in turn send those messages on to our opponent. The challenge message is
used to initiate starting a game, and accept is sent in response to a challenge. For each
letter that moves, the move message is sent, and then the turn message is sent at the
end of each turn. If the client quits or leaves the page with the applet on it, it sends the
quit message.
void challenge(String destid) {
setTo(destid);
send("challenge " + id);
}
void accept(String destid, int seed) {
setTo(destid);
send("accept " + id + " " + seed);
}
void chat(String s) {
send("chat " + id + " " + s);
}
void move(String letter, int x, int y) {
send("move " + letter + " " + x + " " + y);
}
void turn(String words, int score) {
send("turn " + score + " " + words);
}
void quit() {
send("quit " + id);  // tell other player
out.println("quit"); // unhook
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1119
A
P
P
LY
IN
G
JA
V
A
start( )
The next method simply starts the thread that manages the client side of the network.
// reading from server...
private Thread t;
void start() {
t = new Thread(this);
t.start();
}
Keywords
The static variables and static block shown here are used to initialize the keys
Hashtable with a mapping between the strings in keystrings and their position in
the array—for example, keys.get(“move”) == MOVE. The lookup( ) method takes
care of unpacking the Integer objects into the right int, with –1 meaning the keyword
was not found.
private static final int ID = 1;
private static final int ADD = 2;
private static final int DELETE = 3;
private static final int MOVE = 4;
private static final int CHAT = 5;
private static final int QUIT = 6;
private static final int TURN = 7;
private static final int ACCEPT = 8;
private static final int CHALLENGE = 9;
private static Hashtable keys = new Hashtable();
private static String keystrings[] = {
"", "id", "add", "delete", "move", "chat",
"quit", "turn", "accept", "challenge"
};
static {
1120 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
for (int i = 0; i < keystrings.length; i++)
keys.put(keystrings[i], new Integer(i));
}
private int lookup(String s) {
Integer i = (Integer) keys.get(s);
return i == null ? -1 : i.intValue();
}
run( )
run( ) is the main loop of the game’s connection to the server. It goes into a blocking
call to readline( ) that will return with a String whenever a line of text comes from the
server. It uses a StringTokenizer to break the line into words. The switch statement
dispatches us to the right code, based on the first word in the input line. Each of the
keywords in the protocol parses the input line differently, and most of them make
method calls back into the Scrabblet class to do their work.
public void run() {
String s;
StringTokenizer st;
while ((s = readline()) != null) {
st = new StringTokenizer(s);
String keyword = st.nextToken();
switch (lookup(keyword)) {
default:
System.out.println("bogus keyword: " + keyword + "\r");
break;
case ID:
id = st.nextToken();
break;
case ADD: {
String id = st.nextToken();
String hostname = st.nextToken();
String name = st.nextToken(CRLF);
scrabblet.add(id, hostname, name);
}
break;
case DELETE:
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1121
A
P
P
LY
IN
G
JA
V
A
scrabblet.delete(st.nextToken());
break;
case MOVE: {
String ch = st.nextToken();
int x = Integer.parseInt(st.nextToken());
int y = Integer.parseInt(st.nextToken());
scrabblet.move(ch, x, y);
}
break;
case CHAT: {
String from = st.nextToken();
scrabblet.chat(from, st.nextToken(CRLF));
}
break;
case QUIT: {
String from = st.nextToken();
scrabblet.quit(from);
}
break;
case TURN: {
int score = Integer.parseInt(st.nextToken());
scrabblet.turn(score, st.nextToken(CRLF));
}
break;
case ACCEPT: {
String from = st.nextToken();
int seed = Integer.parseInt(st.nextToken());
scrabblet.accept(from, seed);
}
break;
case CHALLENGE: {
String from = st.nextToken();
scrabblet.challenge(from);
}
break;
}
}
}
}
1122 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The Server Code
These last two classes are not part of this applet. Rather, they must be installed and
run separately on the web server that the applet classes are to be loaded from. This
will require the security rights to install and run so-called daemon processes on the
web site, which not many people have. Fortunately, most users of this game will not
be setting up their own servers; more likely, they will just play games connected to
existing ones.
Server.java
Server is the main class for the server side of Scrabblet. Once this is installed on the
web server, you have to run it using the command-line Java interpreter for that system,
as shown here:
C:\java\Scrabblet> java Server
Once running, Server will respond with the following message:
Server listening on port 6564
The Server class starts out by declaring a few variables. The port has to be the same
number, 6564, as we saw in ServerConnection. The idcon Hashtable is used to store
all of the connections to all of the clients. We use a hash table rather than an array to
manage frequent insertion and deletion, which require lots of array copying. The id is
incremented for each new connection. This corresponds to the id instance variable we
saw earlier in the client.
import java.net.*;
import java.io.*;
import java.util.*;
public class Server implements Runnable {
private int port = 6564;
private Hashtable idcon = new Hashtable();
private int id = 0;
static final String CRLF = "\r\n";
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1123
A
P
P
LY
IN
G
JA
V
A
addConnection( )
The addConnection( ) method is called every time a new client connects to our applet.
This method creates a new instance of ClientConnection, described next, to manage
the client. It passes in a reference to this Server, the socket the client connected with,
and the current value of id. Finally, it increments the id to have it ready for the next
connection.
synchronized void addConnection(Socket s) {
ClientConnection con = new ClientConnection(this, s, id);
// we will wait for the ClientConnection to do a clean
// handshake setting up its "name" before calling
// set() below, which makes this connection "live."
id++;
}
set( )
The set( ) method is called from ClientConnection in response to the client telling
us its “name.” set( ) tracks all of the connections in the idcon hash table, and first it
removes this id from the table so that it won’t get duplicates if the client sends its
name twice. The method calls setBusy(false) to signify that this connection is available
to play a game. Then it walks through all of the other connections by enumerating the
keys of the idcon hash table. For all nonbusy connections (those players waiting for
an opponent), set( ) sends an “add” protocol message so they will all know about this
connection.
synchronized void set(String the_id, ClientConnection con) {
idcon.remove(the_id) ;  // make sure we're not in there twice.
con.setBusy(false);
// tell this one about the other clients.
Enumeration e = idcon.keys();
while (e.hasMoreElements()) {
String id = (String)e.nextElement();
ClientConnection other = (ClientConnection) idcon.get(id);
if (!other.isBusy())
con.write("add " + other + CRLF);
}
idcon.put(the_id, con);
broadcast(the_id, "add " + con);
}
1124 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
sendto( )
sendto( ) is called in response to a “to” protocol message. It writes whatever is in the
body string directly to the connection identified by dest.
synchronized void sendto(String dest, String body) {
ClientConnection con = (ClientConnection)idcon.get(dest);
if (con != null) {
con.write(body + CRLF);
}
}
broadcast( )
The broadcast( ) method is used to send a single message, in body, to every single
connection except the one identified in exclude (typically, the sender).
synchronized void broadcast(String exclude, String body) {
Enumeration e = idcon.keys();
while (e.hasMoreElements()) {
String id = (String)e.nextElement();
if (!exclude.equals(id)) {
ClientConnection con = (ClientConnection) idcon.get(id);
con.write(body + CRLF);
}
}
}
delete( )
The delete( ) method is used to tell all of the connected clients to forget they ever heard
of the_id. This is used by clients that are engaged in a game to remove themselves from
other players’ eligibility lists.
synchronized void delete(String the_id) {
broadcast(the_id, "delete " + the_id);
}
kill( )
The kill( ) method is called whenever a client explicitly quits, sending the “quit”
message, or when a client simply dies if the browser quits.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1125
A
P
P
LY
IN
G
JA
V
A
synchronized void kill(ClientConnection c) {
if (idcon.remove(c.getId()) == c) {
delete(c.getId());
}
}
run( )
The run( ) method is the main loop of the server. It creates a new socket on port 6564
and goes into an infinite loop accepting socket connections from clients. It calls
addConnection( ) with each socket that it accepts.
public void run() {
try {
ServerSocket acceptSocket = new ServerSocket(port);
System.out.println("Server listening on port " + port);
while (true) {
Socket s = acceptSocket.accept();
addConnection(s);
}
} catch (IOException e) {
System.out.println("accept loop IOException: " + e);
}
}
main( )
main( ) is, of course, the method run by the Java command-line interpreter. It creates a
new instance of Server and launches a new Thread to run it.
public static void main(String args[]) {
new Thread(new Server()).start();
try {
Thread.currentThread().join();
} catch (InterruptedException e) { }
}
}
1126 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
ClientConnection.java
This class is the mirror image of ServerConnection in the applet. One of these is
created for each client. Its job is to manage all of the I/O to and from a client. The
private instance variables hold all of the states about this client. The Socket is stored in
sock. The buffered reader and output streams are stored in in and out. The host name
of the client machine is kept in host. A reference to the Server instance that created this
client is held in server. The name of the player on this client is stored in name, while
the player’s automatically assigned ID number is held in id. The busy Boolean variable
stores whether or not this client is actively engaged in a game.
import java.net.*;
import java.io.*;
import java.util.*;
class ClientConnection implements Runnable {
private Socket sock;
private BufferedReader in;
private OutputStream out;
private String host;
private Server server;
private static final String CRLF = "\r\n";
private String name = null;    // for humans
private String id;
private boolean busy = false;
ClientConnection( )
The constructor saves the reference to the server and socket and remembers the unique
ID. We wrap an InputStreamReader and a BufferedReader around the input so that it
can call readLine( ) on it. Then it writes the id back to the client to let it know what
number it is. Finally, it creates and starts a new Thread to handle this connection.
public ClientConnection(Server srv, Socket s, int i) {
try {
server = srv;
sock = s;
in = new BufferedReader(new
InputStreamReader(s.getInputStream()));
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1127
A
P
P
LY
IN
G
JA
V
A
out = s.getOutputStream();
host = s.getInetAddress().getHostName();
id = "" + i;
// tell the new one who it is...
write("id " + id + CRLF);
new Thread(this).start();
} catch (IOException e) {
System.out.println("failed ClientConnection " + e);
}
}
toString( )
We override toString( ) so that we can have a clean representation of this connection
for logging.
public String toString() {
return id + " " + host + " " + name;
}
getHost( ), getId( ), isBusy( ), and setBusy( )
We wrap host, id, and busy in public methods to allow read-only access.
public String getHost() {
return host;
}
public String getId() {
return id;
}
public boolean isBusy() {
return busy;
}
public void setBusy(boolean b) {
busy = b;
}
1128 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
close( )
The close( ) method is called if the client explicitly quits or if we get an exception
reading from the socket. We call kill( ) in the server, which removes us from any lists.
Then we close the socket, which also closes both the input and output streams.
public void close() {
server.kill(this);
try {
sock.close();   // closes in and out too.
} catch (IOException e) { }
}
write( )
To write a string to a stream, we have to convert it to an array of bytes, using
getBytes( ).
public void write(String s) {
byte buf[];
buf = s.getBytes();
try {
out.write(buf, 0, buf.length);
} catch (IOException e) {
close();
}
}
readline( )
The readline( ) method merely converts the IOException from readLine( ) into a null
return value.
private String readline() {
try {
return in.readLine();
} catch (IOException e) {
return null;
}
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1129
A
P
P
LY
IN
G
JA
V
A
Keywords
This section is very similar to the same part of the ServerConnection class, which
represents the other end of the wire. The static variables and static block shown here
are used to initialize the keys Hashtable with a mapping between the strings in
keystrings and their position in the array—for example, keys.get(“quit”) == QUIT.
The lookup( ) method takes care of unpacking the Integer objects into the right int,
with –1 meaning the keyword was not found.
static private final int NAME = 1;
static private final int QUIT = 2;
static private final int TO = 3;
static private final int DELETE = 4;
static private Hashtable keys = new Hashtable();
static private String keystrings[] = {
"", "name", "quit", "to", "delete"
};
static {
for (int i = 0; i < keystrings.length; i++)
keys.put(keystrings[i], new Integer(i));
}
private int lookup(String s) {
Integer i = (Integer) keys.get(s);
return i == null ? -1 : i.intValue();
}
run( )
run( ) has the loop that manages all of the communication with this client. It uses a
StringTokenizer to parse the input lines, keying off of the first word in each line. The
lookup( ) method just shown is used to look up these first words in the keys hash
table. We then switch, based on the integer value of the keyword. The NAME
message comes from clients when they first gain a human identity. We call set( ) in
the server to get this connection set up. The QUIT message is sent when the client
wants to end its server session. The TO message contains a destination ID and a
message body to be sent to that client. We call sendto( ) in the server to pass the
message along. The last message is DELETE, which is sent by clients that want to
continue being connected but no longer want to have their names listed as available
to play. run( ) sets the busy flag and calls delete( ) in the server, which notifies the
clients that we don’t want to be called.
1130 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public void run() {
String s;
StringTokenizer st;
while ((s = readline()) != null) {
st = new StringTokenizer(s);
String keyword = st.nextToken();
switch (lookup(keyword)) {
default:
System.out.println("bogus keyword: " + keyword + "\r");
break;
case NAME:
name = st.nextToken() +
(st.hasMoreTokens() ? " " + st.nextToken(CRLF) : "");
System.out.println("[" + new Date() + "] " + this + "\r");
server.set(id, this);
break;
case QUIT:
close();
return;
case TO:
String dest = st.nextToken();
String body = st.nextToken(CRLF);
server.sendto(dest, body);
break;
case DELETE:
busy = true;
server.delete(id);
break;
}
}
close();
}
}
Enhancing Scrabblet
This applet represents a complete client/server, multiplayer board game. In the future,
the code in Server and ServerConnection could be extended in many ways. It could be
used to support other turn-based games. It could track and maintain a high-score list
for each game. It could be dynamically extensible to understand new protocol verbs.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1131
A
P
P
LY
IN
G
JA
V
A
One such example for the game described in this chapter would be to have a lookup
function that checked a series of submitted words against a dictionary stored on the
server. The server could then be the arbiter for such disputes as whether xyzy is a valid
word. You could also construct a word robot, which would reside on the server but act
like another player and use the dictionary to generate the best word placement from its
current set of seven letters. It could even use a list of pithy quotes to throw into the chat
window after each move. You might want to try making some of these enhancements
yourself.
This applet is intended for entertainment and educational purposes. Any similarity
to any and all commercial products is merely coincidental.
1132 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Appendix A
Using Java’s
Documentation
Comments
1133
As explained in Part I, Java supports three types of comments. The first two arethe // and the /* */. The third type is called a documentation comment. It beginswith the character sequence /**. It ends with */. Documentation comments allow
you to embed information about your program into the program itself. You can then
use the javadoc utility program to extract the information and put it into an HTML file.
Documentation comments make it convenient to document your programs. You have
almost certainly seen documentation generated with javadoc, because that is the way
the Java API library was documented by Sun.
The javadoc Tags
The javadoc utility recognizes the following tags:
Tag Meaning
@author Identifies the author of a class.
@deprecated Specifies that a class or member is deprecated.
{@docRoot} Specifies the path to the root directory of the current
documentation (added by Java 2, version 1.3).
@exception Identifies an exception thrown by a method.
{@inheritDoc} Inherits a comment from the immediate superclass. (Added by
Java 2, version 1.4, but not currently implemented.)
{@link} Inserts an in-line link to another topic.
{@linkplain} Inserts an in-line link to another topic, but the link is displayed
in a plain-text font. (Added by Java 2, version 1.4.)
@param Documents a method’s parameter.
@return Documents a method’s return value.
@see Specifies a link to another topic.
@serial Documents a default serializable field.
@serialData Documents the data written by the writeObject( )
or writeExternal( ) methods.
@serialField Documents an ObjectStreamField component.
@since States the release when a specific change was introduced.
@throws Same as @exception.
{@value} Displays the value of a constant, which must be a static field.
(Added by Java 2, version 1.4.)
@version Specifies the version of a class.
1134 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
As you can see, all document tags begin with an at sign (@). You may also use
other, standard HTML tags in a documentation comment. However, some tags, such as
headings, should not be used, because they disrupt the look of the HTML file produced
by javadoc.
You can use documentation comments to document classes, interfaces, fields,
constructors, and methods. In all cases, the documentation comment must immediately
precede the item being documented. When you are documenting a variable, the
documentation tags you can use are @see, @since, @serial, @serialField, {@value},
and @deprecated. For classes, you can use @see, @author, @since, @deprecated, and
@version. Methods can be documented with @see, @return, @param, @since,
@deprecated, @throws, @serialData, {@inheritDoc}, and @exception. A {@link},
{@docRoot}, or {@linkplain} tag can be used anywhere. Each tag is examined next.
@author
The @author tag documents the author of a class. It has the following syntax:
@author description
Here, description will usually be the name of the person who wrote the class. The
@author tag can be used only in documentation for a class. You may need to specify
the -author option when executing javadoc in order for the @author field to be
included in the HTML documentation.
@deprecated
The @deprecated tag specifies that a class or a member is deprecated. It is recommended
that you include @see or {@link} tags to inform the programmer about available
alternatives. The syntax is the following:
@deprecated description
Here, description is the message that describes the deprecation. Information specified by
the @deprecated tag is recognized by the compiler and is included in the .class file that
is generated. Therefore, the programmer can be given this information when compiling
Java source files. The @deprecated tag can be used in documentation for variables,
methods, and classes.
{@docRoot}
{@docRoot} specifies the path to the root directory of the current documentation.
@exception
The @exception tag describes an exception to a method. It has the following syntax:
@exception exception-name explanation
A p p e n d i x A : U s i n g J a v a ’ s D o c u m e n t a t i o n C o m m e n t s 1135
Here, the fully qualified name of the exception is specified by exception-name;
explanation is a string that describes how the exception can occur. The @exception
tag can only be used in documentation for a method.
{@inheritDoc}
Inherits a comment from the immediate surperclass. (Not currently implemented by
Java 2, version 1.4)
{@link}
The {@link} tag provides an in-line link to additional information. It has the following
syntax:
{@link name text}
Here, name is the name of a class or method to which a link is added, and text is the
string that is displayed.
{@linkplain}
Inserts an in-line link to another topic. The link is displayed in plain-text font. Otherwise,
it is similar to {@link}.
@param
The @param tag documents a parameter to a method. It has the following syntax:
@param parameter-name explanation
Here, parameter-name specifies the name of a parameter to a method. The meaning of
that parameter is described by explanation. The @param tag can be used only in
documentation for a method.
@return
The @return tag describes the return value of a method. It has the following syntax:
@return explanation
Here, explanation describes the type and meaning of the value returned by a method.
The @return tag can be used only in documentation for a method.
@see
The @see tag provides a reference to additional information. Its most commonly used
forms are shown here.
1136 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
@see anchor
@see pkg.class#member text
In the first form, anchor is a link to an absolute or relative URL. In the second form,
pkg.class#member specifies the name of the item, and text is the text displayed for that
item. The text parameter is optional, and if not used, then the item specified by
pkg.class#member is displayed. The member name, too, is optional. Thus, you can
specify a reference to a package, class, or interface in addition to a reference to a
specific method or field. The name can be fully qualified or partially qualified.
However, the dot that precedes the member name (if it exists) must be replaced by
a hash character.
@serial
The @serial tag defines the comment for a default serializable field. It has the
following syntax:
@serial description
Here, description is the comment for that field.
@serialData
The @serialData tag documents the data written by the writeObject( ) and writeExternal( )
methods. It has the following syntax:
@serialData description
Here, description is the comment for that data.
@serialField
The @serialField tag provides comments for an ObjectStreamField component. It has
the following syntax:
@serialField name type description
Here, name is the name of the field, type is its type, and description is the comment for
that field.
@since
The @since tag states that a class or member was introduced in a specific release. It has
the following syntax:
@since release
A p p e n d i x A : U s i n g J a v a ’ s D o c u m e n t a t i o n C o m m e n t s 1137
Here, release is a string that designates the release or version in which this feature
became available. The @since tag can be used in documentation for variables, methods,
and classes.
@throws
The @throws tag has the same meaning as the @exception tag.
{@value}
Displays the value of a constant, which must be a static field.
@version
The @version tag specifies the version of a class. It has the following syntax:
@version info
Here, info is a string that contains version information, typically a version number,
such as 2.2. The @version tag can be used only in documentation for a class. You may
need to specify the -version option when executing javadoc in order for the @version
field to be included in the HTML documentation.
The General Form of a Documentation
Comment
After the beginning /**, the first line or lines become the main description of your class,
variable, or method. After that, you can include one or more of the various @ tags. Each
@ tag must start at the beginning of a new line or follow an asterisk (*) that is at the
start of a line. Multiple tags of the same type should be grouped together. For example,
if you have three @see tags, put them one after the other.
Here is an example of a documentation comment for a class:
/**
* This class draws a bar chart.
* @author Herbert Schildt
* @version 3.2
*/
What javadoc Outputs
The javadoc program takes as input your Java program’s source file and outputs
several HTML files that contain the program’s documentation. Information about each
1138 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
class will be in its own HTML file. javadoc will also output an index and a hierarchy
tree. Other HTML files can be generated. Since different implementations of javadoc
may work differently, you will need to check the instructions that accompany your
Java development system for details specific to your version.
An Example that Uses Documentation
Comments
Following is a sample program that uses documentation comments. Notice the way
each comment immediately precedes the item that it describes. After being processed
by javadoc, the documentation about the SquareNum class will be found in
SquareNum.html.
import java.io.*;
/**
* This class demonstrates documentation comments.
* @author Herbert Schildt
* @version 1.2
*/
public class SquareNum {
/**
* This method returns the square of num.
* This is a multiline description.  You can use
* as many lines as you like.
* @param num The value to be squared.
* @return num squared.
*/
public double square(double num) {
return num * num;
}
/**
* This method inputs a number from the user.
* @return The value input as a double.
* @exception IOException On input error.
* @see IOException
*/
public double getNumber() throws IOException {
// create a BufferedReader using System.in
InputStreamReader isr = new InputStreamReader(System.in);
A p p e n d i x A : U s i n g J a v a ’ s D o c u m e n t a t i o n C o m m e n t s 1139
BufferedReader inData = new BufferedReader(isr);
String str;
str = inData.readLine();
return (new Double(str)).doubleValue();
}
/**
* This method demonstrates square().
* @param args Unused.
* @return Nothing.
* @exception IOException On input error.
* @see IOException
*/
public static void main(String args[])
throws IOException
{
SquareNum ob = new SquareNum();
double val;
System.out.println("Enter value to be squared: ");
val = ob.getNumber();
val = ob.square(val);
System.out.println("Squared value is " + val);
}
}
1140 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Index
& (bitwise AND), 80, 82
& (Boolean logical AND), 92, 94
&& (short-circuit AND), 92
* (multiplication), 31, 74
* (regular expression quantifier),
861
* (used in import statement), 233
@ tags (javadoc), 1134–1138
| (bitwise OR), 80, 82
| (Boolean logical OR), 92
|| (short-circuit OR), 92
[ ], 38, 861, 866
^ (bitwise exclusive OR), 80, 82, 83
^ (Boolean logical exclusive OR), 92
:,  123
, (comma), 38, 116–117
{ }, 27, 28, 35, 38, 63, 254
=, 31, 94–95
= = (relational operator), 90, 91
versus equals( ), 359
= = (Boolean operator), 92
!, 92
!=, 90, 91, 92
/, 74
/* */, 27
/** */, 38, 1134
//, 27–28
<, 91
<<, 80, 84–86
<=, 91
–, 74
– –, 35, 74, 78–80
%, 74, 76
( ), 38, 96–98
. (dot operator), 132, 140, 177–178
. (regular expression wildcard
character), 861, 865
. (separator), 38, 232, 233
+ (addition), 74
+ (concatenation operator), 31, 185,
352–353, 372, 373
+ (regular expression quantifier),
861, 864–865
++, 34–35, 74, 78–80
? (regular expression quantifier),
861, 865–866
?:, 92, 95–96
>, 90
>>, 80, 86–87
>>>, 80, 87–89
>=, 91
; (semicolon), 29, 38, 110
~, 80, 82
A
abs( ), 159
abstract type modifier, 216, 220
Abstract Window Toolkit (AWT),
314, 329, 331, 628, 632, 688, 736
and applet architecture,
631–632
classes, table of, 688–691
components, extending,
790–797
creating stand-alone
windows with, 702–704
AbstractButton class, 927
AbstractCollection class, 448
AbstractList class, 448
AbstractMap class, 466, 467
AbstractSequentialList class, 448
AbstractSet class, 449
accept( ), 543, 545, 602
Access control, 172–176
example program, 229–232
and packages, 224, 227–228
Access specifiers, 28, 172, 227–228
Accessibility API, 948
acos( ), 420
ActionEvent class, 657, 658–659,
739, 752, 777
ActionListener interface, 669, 670,
739, 752, 777
actionPerformed( ), 670, 739
Adapter classes, 680–682
add( ), 443, 445, 446, 447, 454, 455,
692, 736–737, 748, 751, 767, 772,
777
addAll( ), 443, 445, 446
1141
addCookie( ), 965, 967, 975
addElement( ), 486, 488
addFirst( ), 453
addImage( ), 811
addLast( ), 453, 454
addMouseListener( ), 676
addMouseMotionListener( ), 676
addTypeListener( ), 655–656
AdjustmentEvent class, 657,
659–660, 756
AdjustmentListener interface, 669,
670, 756
adjustmentValueChanged( ), 670
after( ), 512, 514
Algorithms, collection, 441,
475–480
ALIGN, 644
allocate( ), 850, 851–852
ALT, 643
AND operator
bitwise (&), 80, 82
Boolean logical (&), 92, 94
short-circuit (&&), 92, 93–94
Animation, cell, 837–841
Apache Software Foundation, 951
append( ), 372–373, 762
Applet, 10, 328–331
architecture, 632
basics, 628–629
colors, setting and
obtaining, 636–638
executing, 330–331
and the Internet, 10
and main( ), 29, 131, 329, 331
outputting to console, 652
passing parameters to,
644–649
request for repaint, 638–641
skeleton, 632–635
and socket connections, 595
string output to, 636
versus application, 10
viewer, 330–331
Applet class, 329, 628–652, 692
methods, table of, 629–631
applet package, 314, 328
applet tag, 16
APPLET tag, HTML, 330–331,
628–629
full syntax for, 643–644
AppletContext interface, 628,
649–651, 1048
methods, table of, 650
AppletStub interface, 628, 652
appletviewer, 330, 628
status window, using, 642
Application builder tools, 887–888
Application versus applet, 10
AreaAveragingScaleFilter class, 821
areFieldsSet, 514
Arguments, 138, 143
command-line, 188
passing, 165–167
Arithmetic operators, 74–80
ArithmeticException, 252, 253, 265
Array(s), 28, 61–70
boundary checks, 64
copying, 408, 411
declaration syntax,
alternative, 70
dynamic, 449–451, 485
initializing, 63–64, 68–69
length instance variable of,
179–181
multidimensional, 64–70
one-dimensional, 61–64
of strings, 187
and strings, 52, 70
arraycopy( ), 408, 411
ArrayIndexOutOfBoundsExceptio
n, 256, 265, 482, 483
ArrayList class, 448, 449–452, 462
Arrays class, 480–484
ArrayStoreException, 265
ASCII character set, 47, 48, 51
and the Internet, 350, 356
asin( ), 420
asList( ), 480
Assembly language, 4, 5
assert( ), 16, 39, 340–343
Assertion, 340–344
AssertionError, 340
Assignment operator(s)
=, 31, 94–95
arithmetic (op=), 74, 76–78
bitwise, 80, 89–90
Boolean, 92
atan( ), 420
atan2( ), 420
AudioClip interface, 628, 651
available( ), 548
AWT. See Abstract Window Toolkit
AWTEvent class, 656–657
bit mask constants, 791
B
B, 4, 5
BASIC, 5
BCPL, 5
Bean Builder, 888, 911–920
Bean Developer Kit (BDK), 888–891
BeanBox, 888
BeanDescriptor class, 907, 909–911
BeanInfo interface, 903–904, 907,
910–911
Beans, Java. See Java Beans
before( ), 512, 514
Bell curve, 525
Berkeley Software Distribution
(BSD), 588
Berners-Lee, Tim, 597
Beyond Photography, The Digital
Darkroom (Holzmann), 816
binarySearch( ), 481
BitSet class, 508–511
methods, table of, 508–510
Bitwise operators, 80–90
Blocks, code. See Code blocks
Boolean
literals, 51
logical operators, 92–94
Boolean class, 401
methods, table of, 401
boolean data type, 42, 48–49
and relational operators, 91
BorderLayout class, 766–768
Borenstein, Nat, 602
break statement, 100, 104, 105–107,
120–124
as form of goto, 122–124
Buffer class, 847–850
methods, table of, 848
Buffer(s), NIO, 847–850
BufferedInputStream class, 316,
555–557
BufferedOutputStream class, 316,
557
BufferedReader class, 318–319, 320,
321, 569–570
BufferedWriter class, 570–571
Buffering, double, 807–811
Button class, 739
extending, 792
Buttons, Swing, 927–934
Byte class, 387, 396, 397
methods defined by, table
of, 387–389
byte data type, 42, 43, 44, 50
ByteArrayInputStream class,
552–553
ByteArrayOutputStream class,
553–554
ByteBuffer class, 848–850, 851, 852
get( ) and put( ) methods,
table of, 849
Bytecode, 11–12, 14, 26, 422
byteValue( ), 381
1142 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C
C, history of, 4–6
and Java, 4, 6, 8, 13
C Programming Language, The
(Kernighan and Ritchie), 5
C++
code, converting to Java,
985–1003
features not in Java, 982–983
history of, 6–7
and Java, 4, 7, 8, 9, 13
Java features not in, 984–985
C# and Java, 9
Calendar class, 514–518, 524
methods defined by, table
of, 515–517
Call-by-reference, 165, 166–167
Call-by-value, 165–166, 167
cancel( ), 532, 533
Canvas class, 693
capacity( ), 369–370
capacityIncrement Vector data
member, 485–486
CardLayout class, 772–775
Case-sensitivity and Java, 26, 28, 37
case statement, 104, 105, 107, 108
Casts, 57–59, 60
using instanceof with,
332–335
catch block(s), 250, 253–254
displaying exception
description within,
254–255
using multiple, 255–257
CGI (Common Gateway
Interface), 950
Channel(s), 550, 551, 562, 596, 602,
847, 850–851
char data type, 42, 47–48, 74
Character(s), 42, 47–48
changing case of, 367–368
classes (regular
expressions), 861, 866
escape sequences, table of, 51
extracting, 355–356
literals, 51
Character class, 397–401
methods, table of, 399–400
Character.Subset class, 380, 401
Character.Unicode class, 380, 401
CharArrayReader class, 566–567
CharArrayWriter class, 567–568
charAt( ), 186–187, 355, 371
CharBuffer class, 436
Charsets, 851
CharSequence interface, 345, 380,
436, 860
charValue( ), 397
Check boxes, 743–747
Swing, 930–932
checkAll( ), 812
Checkbox class, 743
extending, 793
CheckboxGroup class, 745–747
extending, 794
CheckboxMenuItem class, 775, 777
checkID( ), 812
Choice class, 748
extending, 795
Choice controls, 748–750
Class(es), 130–154
abstract, 216–219, 220, 239
access levels of, 228
adapter, 680–682
and code, 26, 228
in collections, storing
user-defined, 460–462
constructor. See
Constructor
definition of, 20
final, 220
general form of, 130–131
inner, 181–184, 682–685
and interfaces, 235, 236–237
libraries, 25, 39
member. See Member, class
name and source file
name, 26
nested, 181
packages as containers for,
224, 227
public, 228
scope, 54
Class class, 416–419, 869, 872
methods, table of, 416–417
.class file, 26, 133
class keyword, 27, 130
ClassCastException, 265, 400, 443,
445, 447, 463, 465, 471, 475, 481,
482, 483
ClassLoader class, 419
methods, table of, 419
ClassNotFoundException, 266
CLASSPATH, 226, 227
clear( ), 443, 445
Client/server model, 589
clone( ), 221, 412–415
Cloneable interface, 380,
412–415, 508
CloneNotSupportedException,
266, 412
close( ), 314, 325
COBOL, 5
CODE, 643
Code blocks, 35–37
CODEBASE, 643
Collection(s), 440–504
algorithms, 475–480
classes, 448–457
framework overview,
441–442
interfaces, 440, 441–448
and legacy classes and
interfaces, 484
modifiable vs unmodifiable,
442–443
storing user-defined classes
in, 460–462
and synchronization, 475, 484
when to use, 504
Collection interface, 442, 443–445
methods defined by, table
of, 443–444
Collections class, 441, 475–480
algorithms defined by, table
of, 476–479
Collection-view, 442, 464
Color class, 712–715
constants 636
ColorsBeanInfo class, 903
Combo boxes, Swing, 934–936
Comment, 27–28
documentation, 38,
1134–1140
Common Gateway interface
(CGI), 950
Comparable interface, 380, 436,
512, 514, 542
Comparator(s), 471–475
Comparator interface, 442, 471–472
compare( ), 471, 472–475
compareTo( ), 359–361, 400–401,
436, 514, 542
compareToIgnoreCase( ), 361
Compilation unit, 25
compile( ), 859–860
Compiler, Java, 26
Compiler class, 423
Component class, 629, 654, 691,
736, 801
componentAdded( ), 670
ComponentEvent class, 657, 660
componentHidden( ), 670
ComponentListener interface, 669,
670
componentMoved( ), 670
componentRemoved( ), 670
I n d e x 1143
componentResized( ), 670
componentShown( ), 670
concat( ), 364
Constants, 37
Constructor(s), 145–149
in class hierarchy, order of
calling, 207–208
default, 136, 147
object parameters for,
163–165
overloading, 159–162
parameterized, 147–149
and super, 197–202, 206
Constructor class, 869–870
Container class, 629, 692, 763
ContainerEvent class, 657, 660
ContainerListener interface,
669, 670
contains( ), 443, 445, 455
containsAll( ), 443, 445
Content pane, 923
contentEquals( ), 368
Context switching, 311
rules for, 275–276
continue statement, 100, 124–126
Control statements, 100–127
Controls, 736–775
fundamentals, 736–737
Convolution filters, 824, 831–837
Cookie class, 963, 967–968
methods, table of, 968–969
Cookies, example servlet using,
975–977
cos( ), 420
countStackFrames( ), 424
createImage( ), 801
CropImageFilter class, 821–823
Currency class, 534–535
methods, table of, 535
currentThread( ), 278
currentTimeMillis( ), 408, 410–411
D
Data type(s)
casting, 57–59, 60
class as, 130, 131
conversion, automatic, 42,
57, 157–159
conversion into string
representation, 353–354,
366–367, 397
promotion of, 44, 59–61
simple, 42–43
wrappers for simple,
380–398
DatagramPacket class, 624
Datagrams, 623–626
server/client example,
624–626
DatagramSocket class, 624, 626
DataInput interface, 561
DataInputStream class, 316
DataOutput interface, 561
DataOutputStream class, 316
Date class, 512–514
methods, table of, 512–513
object comparisons, 514
DateFormat class, 524, 878–879
Decrement operator (– –), 35, 74,
78–80
default statement, 104
DefaultMutableTreeNode class, 942
Delegation event model, 654–656
and Beans, 896–897
event listeners, 654, 656,
669–672
event sources, 654, 655–656,
668–669
using, 673–680
delete operator, 150
delete( ), 374–375, 541
deleteCharAt( ), 374–375
deleteOnExit( ), 541
destroy( ), 407, 632, 634, 635, 951,
955, 956
Destructors versus finalize( ), 151,
1003–1007
Dialog boxes, 782–790
file, 788–790
Dialog class, 783
Dictionary class, 492–494
abstract methods, table
of, 493
digit( ), 400
Dimension class, 689, 694, 711
Directories as File objects, 539,
542–543
creating, 545
dispose( ), 783
DLL, 339, 340
do-while loop, 111–114
Document/view, 531
Domain Naming Service (DNS), 591
DOS and Java, 25
Dot operator (.), 132, 140, 177–178
Double buffering, 807–811
Double class, 381–382, 386
methods, table of, 384–385
double data type, 42, 46–47, 50
doubleValue( ), 381
Drag-and-Drop API, 948
drawArc( ), 709–710
drawImage( ), 802, 809
drawLine( ), 705–706
drawOval( ), 708
drawPolygon( ), 710–711
drawRect( ), 706
drawRoundRect( ), 706–707
drawString( ), 329, 628, 636, 724
Dynamic link library (DLL), 339, 340
Dynamic method dispatch,
211–216
DynamicBillboard applet,
1012–1046
E
E (double constant), 420
Early binding, 220
echoCharIsSet( ), 759
Edit control, 758
elementAt( ), 486, 488
elementCount Vector data
member, 485–486
elementData[ ] Vector data
member, 485–486
elements( ), 493
else, 100–104
empty( ), 490, 491
EMPTY_LIST static variable, 479
EMPTY_MAP static variable, 479
EMPTY_SET static variable, 479
EmptyStackException, 490, 492
enableEvents( ), 790–791
Encapsulation, 19–20, 24–25,
151–152
and access control, 172
end( ), 860
Endian format, 44
endsWith( ), 358
ensureCapacity( ), 370, 451
entrySet( ), 463, 464, 466, 468
enumerate( ), 427, 432
Enumeration interface, 484–485
program demonstrating,
488–490
Environment properties, list of, 412
eolIsSignificant( ), 575
equals( ),  186–187, 221, 357, 401,
443, 445, 471, 472, 482, 494, 513,
514, 594
versus = =, 349
equalsIgnoreCase( ), 357
err, 318, 407
Error class, 251, 261, 270
Errors, run-time, 13, 14, 250
Event, definition of, 655
1144 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Event handling, 654–685
and adapter classes, 680–682
event classes, 656–668
by extending AWT
components, 655, 790–797
See also Delegation event
model
EventListener interface, 440
EventListenerProxy class, 441
EventObject class, 656, 657
EventSetDescriptor class, 908,
910–911
Exception class, 251, 267–269, 270
Exception handling, 13, 14, 114,
120, 250–271, 328
block, general form of,
250–251
and chained exceptions, 16,
250, 269–271
and creating custom
exceptions, 267–269
and default exception
handler, 251–252
Exceptions, built-in run-time, 250,
251, 265
checked, table of, 266
constructors for, 261
unchecked
RuntimeException, table
of, 265–266
exec( ), 402, 403, 406–407
exists( ), 540
exitValue( ), 407
exp( ), 420
Expressions, regular. See Regular
expressions
extends, 190, 246
Externalizable interface, 578
F
false, 39, 48, 51, 91
FALSE, 401
Field class, 869–870
fields, 514
File(s)
I/O, 324–328, 539–545
pointer, 561
source, 25–26, 131, 224
File class, 539–545
methods, demonstration of
some, 540–541
FileChannel class, 850–851
FileDialog class, 788–789
FileFilter interface, 539, 545
FileInputStream class, 316, 324,
325, 548–550
FilenameFilter interface, 539,
543–544
FileNotFoundException, 325, 548,
550, 563
FileOutputStream, 316, 324, 325,
326, 550–551
FileReader class, 562–565
FileWriter class, 565–566
fill( ), 482–483
fillArc( ), 709–710
fillOval( ), 708
fillPolygon( ), 710–711
fillRect( ), 706
fillRoundRect( ), 706–707
FilteredImageSource class, 815, 821
FilterInputStream class, 555
FilterOutputStream class, 555
final
to prevent class
inheritance, 220
to prevent method
overriding, 219–220
variables, 178–179
finalize( ), 150–151, 221
versus C++ destructors,
1003–1007
finally block, 250, 263–264
find( ), 860, 863–864, 865
Firewall, 10, 1070
first( ), 447, 772–773
firstElement( ), 486, 488
firstKey( ), 465
Float class, 381–382, 386
methods, table of, 382–383
float data type, 42, 46, 50
Floating-point(s), 42, 45–47
literals, 50
floatValue( ), 381
FlowLayout class, 764–766
flush( ), 557, 570
FocusEvent class, 657, 661
focusGained( ), 670
FocusListener interface, 669, 670
focusLost( ), 670
Font class, 717–718, 720
methods, table of, 718
FontMetrics class, 724–733
methods, table of, 724–725
Fonts, 717–733
creating and selecting,
720–722
determining available,
719–720
information, obtaining,
722–723
terminology to describe, 724
for loop, 33–35, 36, 114–119
variations, 117–119
forDigit( ), 400
format( ), 878–879
forName( ), 869
FORTRAN, 5, 6
Frame class, 691, 693
Frame window (s), 693–704
creating stand-alone,
702–704
handling events in, 697–702
within applet, creating,
695–697
Frank, Ed, 7
freeMemory( ), 404, 405–406
G
Garbage collection, 150, 151, 405, 437
gc( ), 404, 405–406
GenericServlet class, 953, 955, 960
get( ), 445, 446, 454, 464, 493
and buffers, 849–850
getActionCommand( ), 658, 740, 752
getAddress( ), 594, 624
getAdjustable( ), 659
getAdjustmentType( ), 659, 756
getAlignment( ), 738
getAllByName( ), 593
getAllFonts( ), 719
getAppletContext( ), 650
getAscent( ), 724, 725
getAttribute, 966, 978
getAttributeNames( ), 966, 978
getAudioClip( ), 651
getAvailableFontFamilyNames( ),
719
getBackground( ), 637
getBlue( ), 713–714
getByName( ), 593
getBytes( ), 356, 550
getCause( ), 267, 270
getChannel( ), 550, 551, 562, 596,
602, 850, 851, 853
getChars( ), 355–356, 371–372, 565
getChild( ), 661
getClass( ), 221, 416, 418–419, 872
getClickCount( ), 665
getCodeBase( ), 648–649
getColor( ), 714
getComponent( ), 660
getConstructors( ), 869
getContainer( ), 661
getCookies( ), 963, 976
getData( ), 624
getDateInstance( ), 878
getDateTimeInstance( ), 880
I n d e x 1145
getDeclaredMethods( ), 872
getDefault( ), 524
getDescent( ), 725
getDirectionality( ), 401
getDirectory( ), 789
getDisplayCountry( ), 524
getDisplayLanguage( ), 524
getDisplayName( ), 524
getDocumentBase( ), 648–649, 803
getEchoChar( ), 759
getEventSetDescriptors( ), 903
GetField inner class, 581
GetFieldID( ), 339
getFields( ), 869
getFile( ), 789
getFirst( ), 453
getFont( ), 722
getFontList( ), 720
getForeground( ), 637
getGraphics( ), 639, 705
getGreen( ), 713–714
getHeight( ), 725–726
getHostAddress( ), 594
getHostName( ), 594
getID( ), 657
getImage( ), 801–802, 803, 805
getInetAddress( ), 595
getInputStream( ), 407, 595
getInsets( ), 768–769
getInstance( ), 516, 519
GetIntField( ), 339
getItem( ), 663, 748, 752, 777
getItemCount( ), 748, 752
getItemSelectable( ), 663, 752
getKey( ), 468
getKeyChar( ), 664
getKeyCode( ), 664
getLabel( ), 739, 743, 776
getLast( ), 453
getLeading( ), 725
getLength( ), 624
getLocalGraphicsEnvironment( ),
719
getLocalHost( ), 593
getLocalPort( ), 595
getMaximum( ), 755
getMessage( ), 261, 267
getMethodDescriptors( ), 903
getMethods( ), 869
getMinimum( ), 755
getMinimumSize( ), 764
getModifiers( ), 658–659, 662, 872
getModifiersEx( ), 662
getN( ), 894, 895, 896
getName( ), 277, 279, 540, 873, 968,
971, 976
getNewState( ), 668
GetObjectClass( ), 339
getOldState( ), 668
getOppositeComponent( ), 661
getOppositeWindow( ), 668
getOutputStream( ), 407, 595
getParameter( ), 645, 646, 803
getParent( ), 540
getPoint( ), 665
getPort( ), 595, 624
getPreferredSize( ), 764
getPriority( ), 277, 290
getProperties( ), 408, 498
getProperty( ), 409, 412, 499, 500, 501
getPropertyDescriptors( ), 903
getRed( ), 713–714
getRGB( ), 714
getRuntime( ), 403, 404
getScrollAmount( ), 666
getScrollType( ), 666
getSelectedCheckbox( ), 746
getSelectedIndex( ), 748, 751
getSelectedIndexes( ), 751
getSelectedItem( ), 748, 751
getSelectedItems( ), 751
getSelectedText( ), 759
getServletConfig( ), 956
getServletInfo( ), 956
getSession( ), 971, 978
getSize( ), 694, 711
getSource( ), 656, 741
getStackTrace( ), 267, 435
getState( ), 743, 777
getStateChange( ), 663, 752
getSuperclass( ), 417, 418–419
getText( ), 738, 758
getTime( ), 513, 514
getTimeInstance( ), 879–880
getValue( ), 468, 660, 755, 968,
971, 976
getWheelRotation( ), 666
getWhen( ), 659
getWindow( ), 668
getWriter( ), 954
getX( ), 665
getY( ), 665
GIF image format, 800
Gosling, James, 7, 8
Goto statement, using labeled
break as form of, 122–124
grabPixels( ), 818, 819
Graphics class, 329, 636, 705
drawing methods, 705–711
Graphics
context, 705
sizing, 711–712
GraphicsEnvironment class, 719
GregorianCalendar class, 514,
519–520, 524
GridLayout class, 770–772
group( ), 860
GZIP file format, 536
H
hashCode( ), 221, 401, 494
Hashing, 455
HashMap class, 466, 467–468
HashSet( ), 449, 454–456
Hashtable class, 494–498
and iterators, 497
legacy methods, table of,
495–496
hasMoreElements( ), 485, 506, 507
hasMoreTokens( ), 506, 507
hasNext( ), 459
Header file, creating, 337–338
headMap( ), 465
headSet( ), 447
HEIGHT, 644
Hexadecimals, 50
as character values, 51
Hierarchical abstraction and
classification, 18–19
and inheritance, 20, 190
Histogram, 819
Hoare, C.A.R., 276
Holzmann, Gerard J., 816
HSB color model, 713
HSBtoRGB( ), 713
HSPACE, 644
HTML (Hypertext Markup
Language), 597, 950
file, 330
HTTP, 597, 950
GET requests, handling,
971–973
POST requests, handling,
971, 973–974
server example, caching
proxy, 602–623
server example transaction,
589–590
socket, 589
and URLConnection class,
599–601
HttpServlet class, 963, 969, 971
methods, table of, 969–970
HttpServletRequest interface, 962,
963, 978
methods, table of, 963–964
1146 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
HttpServletResponse interface,
962, 965, 978
methods, table of, 965–966
HttpSession interface, 962, 966
methods, table of, 966–967
HttpSessionBindingEvent class,
963, 971
HttpSessionBindingListener
interface, 962, 967
HttpSessionEvent class, 963, 970–971
I
Icon interface, 924
Icon, rollover, 927
Identifiers, 27, 37
IdentityHashMap class, 466, 471
IEEEremainder( ), 422
if statement, 31–33, 35, 100–104, 170
and boolean variables, 101
nested, 102
switch statement versus, 108
if-else-if ladder, 102–104
IllegalAccessException, 262, 266
IllegalArgumentException, 265,
482, 483
IllegalMonitorStateException, 265
IllegalStateException, 265, 860, 966
IllegalThreadStateException, 265
Image class, 800, 801
ImageConsumer interface, 800,
817–820
ImageFilter class, 821–837
ImageIcon class, 923–924
ImageMenu applet, 1048–1056
ImageObserver interface, 800, 802,
803–807
ImageProducer interface, 800, 801,
815–817
imageUpdate( ), 803, 804–805, 807
flags, table of, 804
Images, 800–841
animation of, 837–841
creating, loading,
displaying, 801–803
double buffering and,
807–811
implements clause, 236
import statement, 232–233
in, 318, 407
Increment operator (++), 34–35, 74,
78–80
indexOf( ), 361–363, 376–377, 445,
446, 486, 488
IndexOutOfBoundsException, 265
Inet4Address class, 592, 626
Inet6Address class, 592, 626
InetAddress class, 592–594, 626
Infinity (IEEE floating-point
specification value), 385
InheritableThreadLocal class,
380, 432
Inheritance, 20–22, 24–25, 176,
190–221
final and, 220
and interfaces, 235,
246–247
multilevel, 203–207
multiple superclass, 192,
1001–1003
init( ), 632, 634, 637, 951, 955, 956
initCause( ), 267, 270
Inline method calls, 220
Inner classes, 181–184, 682–685
InputEvent class, 657, 661–662
InputStream class, 315, 316, 318,
545, 546, 548
methods, table of, 546–547
objects, concatenating,
559–560
InputStreamReader class, 319
insert( ), 373, 762
Insets class, 768–770
Instance of a class, 20, 130
See also Object(s)
Instance variables
accessing, 132, 138, 140, 143
definition of, 20, 131
hiding, 149–150
static, 176–178
as unique to their object,
131, 133
using super to access
hidden, 202–203
instanceof operator, 332–335, 462
InstantiationException, 266
int, 30, 42, 43, 44
and integer literals, 50
Integer(s), 42, 43–45, 81
literals, 50
Integer class, 387, 396, 397
methods, table of, 391–393
Interface(s), 224, 235–247
converting C++ abstract
classes to Java, 995–999
general form of, 235–236
implementing, 236–239
inheritance of, 246–247
reference variables,
237–239, 243
variables, 236, 243–245
interface keyword, 224, 235
Internet, 4, 7, 8, 9, 11
addresses, obtaining, 594
addressing, 590–591
and portability, 10, 11
and security, 10–11,
1070–1071
Internet Protocol (IP)
addresses, 590–591
definition of, 588–589
InterNIC (Internet root server),
594, 596
Interpreter, Java, 26
and main( ), 28, 29
InterruptedException, 266, 278
Introspection, 894–897
Introspector class, 908, 909–911
I/O, 314–328, 538–585
channel-based, 16, 847
classes, list of, 538
console, 29, 114, 314, 318–324
error handling, 328
file, 324–328, 539–545
interfaces, list of, 539
new. See New I/O (NIO)
streams. See Streams
io package. See java.io package
IOException, 319, 325, 326, 546,
547, 548, 558, 562, 565, 571, 578,
580, 581, 595, 599, 601, 851
isAbsolute( ), 541
isAlive( ), 277, 286–289
isAltDown( ), 662
isAltGraphDown( ), 662
isControlDown( ), 662
isDirectory( ), 542
isEditable( ), 759
isEmpty( ), 444, 445, 493
isEnabled( ), 776
isFile( ), 541
isHidden( ), 541
isInfinite( ),  386
isLeapYear( ), 519
isMetaDown( ), 662
isMulticastAddress( ), 594
isN( ), 895
isNaN( ), 386
isPopupTrigger( ), 665
isSet, 514
isShiftDown( ), 662
isTemporary( ), 661
isTimeSet, 514
ItemEvent class, 657, 662–663, 744,
748, 777
ItemListener interface, 669, 671,
743, 748, 777
ItemSelectable interface, 663
I n d e x 1147
itemStateChanged( ), 671, 744, 748
Iteration statements, 109–119
Iterator interface, 441, 442, 457–460
methods, table of, 458
iterator( ), 444, 445, 457, 459
J
Jakarta Project, 951
JAR files, 536, 891–894
JApplet class, 923
Java
API packages, table of core,
844–846
and C, 4, 6, 13
and C++, 4, 7, 8, 9, 13
and C#, 9
design features, 12–15
and DOS and
Windows 3.1, 26
history of, 4, 7–9, 15–16
and the Internet, 4, 7, 11, 15
as interpreted language,
11, 14
keywords, 38–39
as strongly typed
language, 42
versions of, 15
and Windows 95/98 and
Windows NT, 26
and the World Wide Web, 7,
8, 13
Java 2 SDK (Software
Development Kit), 25
Java 2D API, 733, 948
Java Archive (JAR) files, 536,
891–894
Java Beans, 418, 437, 869, 886–920
advantages of, 887
API, 906–911
and constrained properties,
905
customizers, 906
introspection, 894–897
using the BDK to develop,
897–901
using Bean Builder to
develop, 911–920
using bound property of,
902–903
.java file, 25
Java Foundation Classes (JFC), 948
java (Java interpreter), 26
Java Native Interface (JNI), 336
java package, 234
Java Virtual Machine (JVM), 11, 12,
14, 403
java.applet package, 628
java.awt package, 628, 656, 688
classes, tables of, 688–691
java.awt.Dimension class, 869
java.awt.event package, 654, 656,
669, 680
classes, table of, 657–658
java.awt.image package, 800,
840–841
java.beans package, 906–911
classes, table of, 907–909
interfaces, tables of, 907
java.io package, 314, 538–539
java.io.IOException, 114
java.lang package, 234, 318, 380–437
java.lang.image, 818
java.lang.ref package, 437
java.lang.reflect package, 437, 844,
845, 869
classes, table of, 870
java.net package, 588
classes and interfaces, list
of, 592
java.nio package, 436, 538, 550, 551,
562, 596, 602, 844, 845, 847
java.nio.channels package, 845,
847, 850, 851
java.nio.channles.spi package, 845,
847
java.nio.charset package, 846, 847,
851
java.nio.charset.spi package, 846,
847
java.rmi package, 844, 846, 874
java.text package, 844, 846, 878
java.util package, 440–441, 506, 656
java.util.jar package, 506, 536
java.util.regex package, 846, 859
java.util.zip package, 506, 536, 892
javac (Java compiler), 26
javadoc utility program, 1134,
1138–1139
javah.exe, 337, 339
JavaSoft, 888
javax.imageio package, 841
javax.servlet package, 953, 954–960
interfaces and classes, list
of, 955
javax.servlet.http package, 954,
962–971
interfaces and classes, list
of, 962–963
javax.swing package, 923
javax.swing.tree package, 923
JButton class, 927–929
JCheckBox class, 930–932
JComboBox class, 934–936
JComponent class, 924
JFrame class, 913
JLabel class, 914, 924–925
jni.h, 339
jni_md.h, 339
join( ), 277, 286–289
Joy, Bill, 7, 588
JPanel class, 940
JPEG image format, 800
JRadioButton class, 932–934
JscrollBar class, 915
JScrollPane class, 939–940
JSlider class, 914, 915
JTabbedPane class, 936–939
JTable class, 946–948
JTextCompenent class, 925–926
JTextField class, 926
JToggleButton class, 930, 932
JTree class, 941–942
Jump statements, 119–127
Just In Time (JIT) compiler, 12
K
Kernighan, Brian, 5
KeyAdapter class, 681
Keyboard events, handling, 676–680
KeyEvent class, 658, 663–664
KeyListener interface, 669, 671, 676
keyPressed( ), 671, 676, 678
keyReleased( ), 671, 676
keys( ), 493
keySet( ), 464
keyTyped( ), 671, 676, 678
Keywords, table of Java, 39
L
Label, 123, 125
Swing, 924
Label class, 737–739
last( ), 447, 772, 773
lastElement( ), 487, 488
lastIndexOf( ), 361–363, 376–377,
445, 446, 487, 488
lastKey( ), 465
Late binding, 220
LaVallée, David, 1048, 1058
Lavatron applet, 1058–1067
Layout managers, 763–775
LayoutManager interface, 763–764
length( ), 186–187, 351, 369–370
1148 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
length instance variable of arrays,
179–181
Lexer, 506
Libraries, class, 25, 39
Lindholm, Tim, 7
LinkedHashMap class, 466, 470–471
LinkedHashSet class, 449, 456
LinkedList class, 448, 452–454
list( ) and directories, 539, 542–544
List class, 751
extending, 795–796
List controls, 751–754
List interface, 442, 445–447
methods, table of, 446
listFiles( ), 544–545
ListIterator interface, 442, 457–460
methods, table of, 458
ListResourceBundle class, 441
Literals, 37, 50–52
regular expression, 861
load( ), 404, 499, 502–504
loadLibrary( ), 337, 404
Locale class, 523–524, 878, 880
log( ), 420, 960
Logical operators, Boolean, 92–94
long, 42, 43, 45
literal, 50
Long class, 387, 396, 397
methods, table of, 393–395
lookup( ), 875
loop( ), 651
Loops
do-while, 111–114
for. See for loop
infinite, 118–119
nested, 119
and polling, event, 275, 297
while, 109–111
M
main( ), 28, 29, 131, 176
and applets, 329, 331
and command-line
arguments, 188
main (default name of main
thread), 279
MalformedURLException, 597
Manifest files, 892
Map interface, 463–464
methods, table of, 463–464
map( ), 851, 853–854, 856
Map.Entry interface, 466
methods, table of, 466
MappedByteBuffer class, 848, 854
Maps, 441, 462–471
mark( ), 546, 548, 552, 556, 557, 559,
569
markSupported( ), 556, 559, 569
Matcher class, 859, 860–861
matcher( ), 860
matches( ), 368, 860, 862–863,
868–869
Math class, 53, 159, 420–422
rounding methods, table of,
421
max( ), 476, 480
MAX_PRIORITY, 289, 423–424
MAX_RADIX, 398
MAX_VALUE, 382, 387, 398
MediaTracker class, 811–815
Member, class, 20, 158
access, table of, 228
Member interface, 869
Memory
allocation using new, 62, 63,
134–136
management, 13–14
and Runtime class, 405–406
MemoryImageSource class, 815–817
Menu applet, Image-based,
1048–1056
Menu bars and menus, 775–782
Menu class, 775, 776
MenuBar class, 775, 776, 777
MenuItem class, 775, 776, 777
Messaging system, 276–277
Method(s), 20, 131, 138–145
abstract, 216–219
calling, 140, 142
dispatch, dynamic, 211–216
factory, 593
final, 219–220
general form, 138
interface, 236, 237
native, 335–340
overloading, 156–162
overriding, 208–216
and parameters, 138, 142–145
passing object to, 166–167
recursive, 169–172
returning object from,
168–169
returning a value from,
140–142
scope defined by, 54–56
static, 176–178
synchronized, 276, 292–295
and throws clause, 261–262
Method class, 869–870, 872
MIME types, 602, 950
min( ), 477, 480
minimumLayoutSize( ), 764
MIN_PRIORITY, 289, 423–424
MIN_RADIX, 398
MIN_VALUE, 382, 387, 398
mkdir( ), 545
mkdirs( ), 545
Modifier class, 872
methods, table of, 872
Modulus operator (%), 74–76
Molecule Bean, 889–890
Monitor, 276, 292
Mouse events, handling, 673–676
MouseAdapter class, 680, 681
mouseClicked( ), 671, 680
mouseDragged( ), 671, 680
mouseEntered( ), 671
MouseEvent class, 658, 664–665
mouseExited( ), 671
MouseListener interface, 669,
671, 673
MouseMotionAdapter class,
680, 681
MouseMotionListener interface,
656, 669, 671, 673
mouseMoved( ), 671, 680
mousePressed( ), 671
mouseReleased( ), 671
MouseWheelEvent class, 658,
665–666
MouseWheelListener interface,
669, 672, 673
mouseWheelMoved( ), 672
Multitasking, 274, 276
Multithreaded programming, 14,
274–311
context switching rules for,
275–276
effectively using, 311
Observable class, Observer
interface and, 531
and synchronization. See
Synchronization
and threads. See Thread(s)
versus single-threaded
system, 275
MutableTreeNode interface, 942
Mutex, 292
N
NAME, 644
Name-space collisions
instance variables and local
variables, 149–150
packages and, 224
Naming class, 875
I n d e x 1149
NaN, 382, 385
native modifier, 336, 339
Naughton, Patrick, 7
Negative numbers in Java,
representation of, 81
NEGATIVE_INFINITY, 382
NegativeArraySizeException, 265
.Net Framework, 9
Networking, 588–626
new, 62, 63, 134–136, 145, 147,
260, 261
New I/O (NIO), 844, 847–859
copying a file using, 857–859
reading a file using, 851–855
writing to a file using,
855–857
next( ), 459, 772, 773
nextBoolean( ), 525
nextBytes( ), 525
nextDouble( ), 245, 525
nextElement( ), 485, 506, 507
nextFloat( ), 525
nextGaussian( ), 525
nextInt( ), 525
nextLong( ), 525
nextToken( ), 506, 507, 575
NIO. See New I/O (NIO)
NORM_PRIORITY, 289, 423–424
NoSuchElementException, 447,
463, 465
NoSuchFieldException, 266
NoSuchMethodException, 266
NOT operator
bitwise unary (~), 80, 82
Boolean logical unary (!), 92
notepad, 406–407
notify( ), 221, 297–298, 300–302
notifyAll( ), 221, 297–298
notifyObservers( ), 527, 528
null, 39
Null statement, 110
NullPointerException, 261, 266,
447, 463, 465
Number class, 381
NumberFormatException, 266
O
Oak, 7, 15
Object(s), 20, 130, 136
bitwise copy (clone) of,
412–415
creating, 132, 134–136
initialization with
constructor, 145, 147
to method, passing, 166–167
as parameters, 162–165
returning, 168–169
serialization of. See
Serialization
type at run time,
determining, 332–335
Object class, 220–221, 323, 412
methods, table of, 413
Object reference variables
assigning, 137
declaring, 134–136
and dynamic method
dispatch, 211–212
interface, 237–239
to superclass reference
variable, assigning
subclass, 196–197
OBJECT tag, 643
Object-oriented programming
(OOP), 6, 18–25
model in Java, 13
ObjectInput interface, 580
methods defined by, table
of, 580–581
ObjectInputStream class, 581
methods defined by, table
of, 581–583
ObjectOutput interface, 578
methods defined by, table
of, 578
ObjectOutputStream class, 579
methods defined by, table
of, 579–580
Observable class, 527–531
methods, table of, 527
Observer interface, 527, 528
Octals, 50
as character values, 51
openConnection( ), 598–599
Operator(s)
arithmetic, 74–80
assignment, 31, 94–95
bitwise, 80–90
Boolean logical, 92–94
parentheses and, 96–98
precedence, table of, 97
relational, 48, 90–91
ternary, 95–96
OR operator (|)
bitwise, 80, 82
Boolean, 92
OR operator, short-circuit (||), 92,
93–94
OurButton Bean, 890, 891
out output stream, 29, 318, 407
OutputStream class, 315, 316, 322,
323, 545, 547–548
methods, table of, 547
Overloading  methods, 156–162,
210–211
Overriding, method, 208–211
and dynamic method
dispatch, 211–216
using final to prevent,
219–220
P
Package(s), 172, 224–235, 247
access to classes contained
in, 227–228
core Java API, table of,
844–846
defining, 225
importing, 232–235
Package class, 380, 432–434
methods, table of, 433–434
package statement, 225, 232
paint( ), 329, 632, 634–635, 637, 638,
639, 705, 803
Paint mode, setting, 715–717
Panel class, 629, 691, 692, 772
PARAM NAME, 644
Parameters, 28, 138, 142–145
applets and, 645–648
objects as, 162–165
and overloaded
constructors, 160
and overloaded
methods, 156
reference, C++ versus Java,
991–994
parseByte( ), 396
parseInt( ), 396
parseLong( ), 396
parseShort( ), 396
Parsing, 506
Pascal, 5
Pattern class, 859–860
Payne, Jonathan, 7
peek( ), 490, 491
Persistence (Java Beans), 905–896
PI (double constant), 420
PixelGrabber class, 818–820
play( ), 651
Pointers, 71, 136, 982, 985–991
Polling, 275, 297
Polymorphism, 22–25
and dynamic method
dispatch, 211–216
and interfaces, 235,
238–239, 243
and overloaded methods,
156, 159
pop( ), 490, 491
1150 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
PopupMenu class, 782
Port, 589
Portability problem, 8, 10, 11, 14
and data types, 43
and native methods, 340
POSITIVE_INFINITY, 382
pow( ), 421
preferredLayoutSize( ), 764
previous( ), 772, 773
print( ), 31, 322, 323, 354, 561, 572
println( ), 29, 31, 322, 323, 354, 561,
572
PrintStream class, 316, 318, 322, 561
PrintWriter class, 317, 323, 572
private access specifier, 28, 172, 228
and inheritance, 192–193
Process class, 402
methods, table of, 402
Process-based versus thread-based
multitasking, 274
processActionEvent( ), 791,
792, 796
processAdjustmentEvent( ),
791, 797
processComponentEvent( ), 791
processFocusEvent( ), 791
processItemEvent( ), 791, 793,
795, 796
processKeyEvent( ), 791
processMouseEvent( ), 791
processMouseMotionEvent( ), 791
processMouseWheelEvent( ), 791
processTextEvent( ), 791
Programming
multithreaded. See
Multithreaded
programming
object-oriented. See
Object-oriented
programming
structured, 6
Properties, environment, 412
Properties class, 498–504
legacy methods, table
of, 499
PropertyChangeEvent, 902,
905, 908
PropertyDescriptor class, 903, 909,
910–911
PropertyResourceBundle class, 441
protected access specifier, 151,
172, 228
public access specifier, 28, 172, 228
push( ), 490, 491
Push buttons, 739–743
Pushback, 558
PushbackInputStream, 316, 558–559
PushbackReader class, 317, 571–572
put( ), 464, 468, 471, 493
and buffers, 849–850, 856
putAll( ), 464, 471
PutField inner class, 579
R
Radio buttons, 745
Swing, 932–934
random( ), 422
Random class, 245, 422, 524–526
methods, table of, 525
RandomAccess interface, 442, 462
RandomAccessFile class, 316,
561–562
read( ), 315, 319, 325–326, 328, 556,
558, 571. 850, 852
and end-of-file condition,
328
Reader class, 315, 319, 545, 562
methods defined by, table
of, 563
readLine( ), 320, 396, 581, 960
readObject( ), 580, 581
rebind( ), 875
Recursion, 169–172
Reference parameters, C++ versus
Java, 991–994
Reflection, 437, 869–872
regionMatches( ), 358
Regular expressions, 844, 859–869
syntax, 861
wildcards and quantifiers,
861, 864–866
Relational operators, 48, 90–91
Remote interface, 874
Remote method invocation (RMI),
15, 577, 844, 874–878
RemoteException, 874
remove( ), 444, 445, 455, 493, 737
removeAll( ), 444, 445, 737
removeAttribute( ), 967, 978
removeEldestEntry( ), 471
removeElement( ), 487, 488
removeElementAt( ), 487, 488
removeFirst( ), 453
removeLast( ), 453
removeTypeListener( ), 656
renameTo( ), 541
repaint( ), 638–639
demonstration program,
639–641
replace( ), 364–365, 375
replaceAll( ), 368, 861, 867
replaceFirst( ), 368
replaceRange( ), 762
ReplicateScaleFilter class, 821
requestFocus( ), 677
reset( ), 547, 548, 552, 554, 556,
559, 569
resetSyntax( ), 574
ResourceBundle class, 441
resume( ), 15, 305–308, 424, 426
retainAll( ), 444, 445
return statement, 126–127, 138
reverse( ), 373–374
reverseOrder( ), 477, 479
rewind( ), 853, 856
RGB color model, default, 815–816
RGBImageFilter class, 821, 823–837
RGBtoHSB( ), 713
Richards, Martin, 5
Ritchie, Dennis, 5, 588
RMI compiler (rmic), 876–877
rmiregistry (RMI registry), 877
run( ), 277, 280, 423, 531, 532
overriding, 282, 284, 531
using flag variable with,
308–310
runFinalizersOnExit( ), 403, 408
Runnable interface, 277, 380,
423, 531
implementing, 280–282, 284
Run-time
system, Java, 11
type information, 15,
333, 418
Runtime class, 402, 403–407
executing other programs
and, 406–407
memory management and,
405–406
methods, table of, 403–404
RuntimeException class, 251, 261,
265, 270
RuntimePermission class, 380, 434
S
save( ), 498
scanf( ) C function, 318
schedule( ), 532, 533
Scientific notation, 50
Scope(s) in Java, 54–56
Scrabblet applet, 1070–1132
Scroll bars, 754–758
Scroll panes, 939–941
Scrollbar class, 755
extending, 797
search( ), 490, 491
I n d e x 1151
Security problem, 10–11, 1070–1071
and native methods, 340
and servlets, 950–951, 979
SecurityException, 266, 403, 408
SecurityManager class, 434
seek( ), 561
select( ), 748, 752, 759
Selection statements, 100–108
Selectors, 851
Semaphore, 292
SequenceInputStream class, 316,
559–560
Serializable interface, 577
Serialization, 577–585
example program, 583–585
and static variables, 577
and transient variables, 577
Server, 589
proxy, 590
ServerSocket class, 595, 601–602
service( ), 951, 953, 955, 956
Servlet(s), 950–979
advantages of, 950–951
example of simple, 953–954
life cycle of, 951
parameters, reading,
960–962
and security, 950–951, 979
and session tracking,
977–979
using Tomcat to develop,
951–952
Servlet interface, 955–956
methods, table of, 956
ServletConfig interface, 955, 956
ServletContext interface, 955–957
methods, table of, 957
ServletException class, 955, 960
ServletInputStream class, 955, 960
ServletOutputStream class,
955, 960
ServletRequest interface, 953, 955,
957, 960
methods, table of, 958–959
ServletResponse interface, 953,
955, 957
methods, table of, 959
Session tracking, 977–979
Set interface, 442, 447
Set-view, obtaining, 497
set( ), 445, 446, 454
setAlignment( ), 738
setAttribute( ), 967, 978
setBackground( ), 636, 713
setBlockIncrement( ), 755
setBounds( ), 692, 764
setChanged( ), 527
setCharAt( ), 371
setColor( ), 714
setContentType( ), 953
setDefault( ), 524
setEchoCharacter( ), 759
setEditable( ), 759
setEnabled( ), 776
setFont( ), 720
setForeground( ), 636, 713
SetIntField( ), 339
setLabel( ), 739, 743, 776
setLastModified( ), 542
setLayout( ), 763–764
setLength( ), 370–371, 562
setLocation( ), 692
setMaxAge( ), 969, 977
setN( ), 894, 895, 896
setName( ), 278, 279
setPaintMode( ), 715
setPriority( ), 289
setReadOnly( ), 542
setSelectedCheckbox( ), 746
setSize( ), 692, 694, 695
setState( ), 743, 777
setText( ), 738, 758
setTitle( ), 704
setUnitIncrement( ), 755
setValue( ), 755
setValues( ), 755
setVisible( ), 694, 695
setXORMode( ), 715
Sheridan, Mike, 7
Shift operators, bitwise, 80, 84–89
Short class, 387, 396, 397
methods defined by, table
of, 389–390
short data type, 42, 43, 44, 50
show( ), 772, 773
showDocument( ), 649, 650–651,
1048, 1056
showStatus( ), 642, 681
shuffle( ), 477, 479
Sign extension, 87
SimpleBeanInfo class, 903, 909
SimpleDateFormat class, 524,
880–882
SimpleTimeZone class, 522–523
sin( ), 420
SingleThreadModel interface,
955, 957
size( ), 444, 445, 455, 493, 851
Skeletons (RMI), 876–877
skip( ), 548, 556, 558
sleep( ), 277, 278, 279
slice( ), 850
Socket(s)
example program of
client/server, 602–623
overview, 588–589
reserved, 589–590
TCP/IP client, 594–597
TCP/IP server, 601
Socket class, 595–596
SocketChannel class, 850
sort( ), 482
SortedMap interface, 465
methods, table of, 465
SortedSet interface, 442, 447–448
methods, table of, 447–448
Source code, 25–26
split( ), 368, 867–868
sqrt( ), 53, 421
Stack, definition of, 152
Stack class, 490–492
methods, table of, 491
Stack trace, 252, 435
StackTraceElement class, 435
methods, table of,  435
Standard Template Library (STL),
442
start( ), 277, 280, 282, 632, 634, 637,
860, 864
startsWith( ), 358–359
Statements, 29
null, 110
Statements, control
iteration, 100, 109–119
jump, 100, 119–127
selection, 100–108
static, 28, 176–178
stop( ), 15, 308, 632, 634, 635, 651
store( ), 498, 499, 502–504
Stream(s)
benefits, 585
buffered, 555–559
classes, byte, 315, 316,
545–562
classes, character, 315, 317,
545, 562–577
definition of, 314, 538
filtered, 555
predefined, 318
StreamTokenizer class, 574–577
strictfp, 39, 335
StrictMath class, 422
String(s)
arrays of, 187, 188
changing case of characters
in, 367
comparison, 356–361
1152 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
concatenating, 185–186,
352–353. 364, 372–373
creating, 348–351
extracting characters from,
355–356
length, obtaining,
186–187, 351
literals, 52, 351
modifying, 363–366
as objects, 52, 70–71,
181–182, 348
parsing formatted input, 506
reading, 320–322
representations of numbers,
converting, 392–393, 396
searching, 361–363
String class, 28, 185, 348
constructors, 348–350
StringBuffer class, 185, 348, 361,
369–377
StringBufferInputStream class, 539
StringIndexOutOfBounds
exception, 266
StringTokenizer class, 506–508
methods, table of, 507
stringWidth( ), 725, 726
Stroustrup, Bjarne, 7
Stubs (RMI), 876–877
Subclass, 190, 192
subList( ), 446, 447
subMap( ), 465
subSequence( ), 368, 376
subSet( ), 447, 448
substring( ), 363–364, 375
Sun Microsystems, 7, 588
super, 176, 197–203
and superclass constructors,
197–202, 206
and instance variables,
202–203
Superclass, 190, 192
suspend( ), 15, 305–307, 308,
424, 426
Swing, 922–948
and Bean Builder, 891
component classes, list of
some, 922
switch statement, 104–108
Synchronization, 276, 292–297
and collections, 475
and deadlock, 302–304
race condition and, 294
via synchronized block,
295–297
via synchronized method,
292–295
synchronized modifier, 292
used with method, 292,
295
used with object, 295–297
synchronizedList( ), 475, 478
synchronizedSet( ), 475, 478
System class, 29, 318, 407
methods, table of, 408–410
System.err standard error
stream, 318
System.in standard input stream,
318, 319
System.in.read( ), 114
System.out standard output
stream, 318, 322, 323, 324
T
Tabbed panes, 936–939
Tables, Swing, 946–948
tailMap( ), 465
tailSet( ), 447, 448
tan( ), 420
TCP/IP, 15, 588, 1070
client sockets, 594–597
disadvantages of, 623
reserved sockets, 589–590
server sockets, 601–602
See also Transmission
Control Protocol (TCP)
Temple, Robert, 1012
Ternary operator (?:), 92, 95–96
Text fields, 758–761
Swing, 925–926
Text formatting, 878–882
Text output, managing, 723–733
TextArea class, 761–763
textChanged( ), 672
TextComponent class, 758, 761
TextEvent class, 658, 666–667
TextField class, 758, 759
TextListener interface, 669, 672
this, 149–150, 176
Thompson, Ken, 5, 588
Thread(s)
creating, 280–286
daemon, 532
and deadlock, 302–304, 308
definition of, 274
group, 279, 426–432
main, 277, 282, 286
messaging, 276–277, 297–302
possible states of, 275
priorities, 275–276,
289–292, 423
resuming, 305–310, 426
stopping, 305–310
suspending, 277, 278, 279,
305–310, 426
synchronization. See
Synchronization
Thread class, 15, 277,
423–426, 531
constructors, 280, 284, 423
extending, 282–284
methods, table of, 424–426
ThreadGroup class, 426–432
methods, table of, 427–428
ThreadLocal class, 380, 432
throw, 250, 260–261
Throwable class, 251, 254, 267,
269–270, 434
methods defined by, table
of, 267
obtaining object of, 260–261
throws, 250, 261–262, 265
TickTock Bean, 902–903
Time. See Date class
Timer class, 531–534
TimerTask class, 531–534
Timestamps, 659
TimeZone class, 521–522
methods defined by, table
of, 521–522
toArray( ), 444, 445, 451–452
toBinaryString( ), 397
toCharArray( ), 356
toDegrees( ), 422
toHexString( ), 397
Tokens, 506
toLowerCase( ), 367
Tomcat, 951–952
toOctalString( ), 397
Toolkit class, 720
toRadians( ), 422
toString( ), 221, 254, 268, 323,
353–354, 366, 387, 456, 510,
511, 656
totalMemory( ), 404, 405–406
toUpperCase( ), 367
transient modifier, 331–332
translatePoint( ), 665
Transmission Control
Protocol (TCP)
definition of, 589
and stream-based I/O, 592
See also TCP/IP
TreeExpansionEvent class, 942
TreeExpansionListener
interface, 942
TreeMap class, 466, 468–470, 504
TreeNode class, 942
I n d e x 1153
Trees, Swing, 941–946
TreeSet class, 449, 455, 456–457, 504
TreePath class, 942
trim( ), 365–366
trimToSize( ), 451
true, 39, 48, 51, 91
TRUE, 401
True and false in Java, 51, 91
try block(s),  250, 253–254
nested, 257–259
Two's complement, 81
TYPE, 382, 387, 398, 401, 402
Type
casting, 57–59, 60
checking, 42
conversion, automatic, 42,
57, 157–159
promotion, 44, 59–61
Types, data. See Data types
U
UDP protocol, 589, 591–592, 624
UnavailableException class, 955,
960
unhand( ) macro, 342
UnicastRemoteObject, 874
Unicode, 47, 48, 51, 315, 350, 356,
401, 562
Uniform Resource Identifier
(URI), 626
UNIX, 5, 588
UnknownHostException,
593, 595
unmodifiable, 475
unread( ), 558, 571
UnsupportedOperationException,
266, 442–443, 445, 463, 475
update( ), 527, 528, 638, 639, 705
overriding, 635
URI class, 592, 626
URL (Uniform Resource
Locator), 597
specification format, 597
URL class, 597–599, 601
URLConnection class, 599–601
User Datagram Protocol (UDP),
589, 591–592, 624
V
valueBound( ), 967
valueOf( ), 353, 366–367
values( ), 464
valueUnbound( ), 967
van Hoff, Arthur, 7
Variable(s), 52–56
declaration, 30–31, 52–53
definition of, 29, 52
dynamic initialization of, 53
final, 178–179
instance. See Instance
variables
interface, 236
object reference. See Object
reference variables
scope and lifetime of, 54–56
Vector class, 462, 485–490
methods, table of, 486–488
Virtual functions (C++), 213
Virtual machine, Java, 400
void, 28, 138
Void class, 401
volatile modifier, 291–292, 331, 332
VSPACE 644
W
wait( ), 221, 297–298, 300–302
waitFor( ), 407
Warth, Chris, 7
wc( ), 572–577
WeakHashMap class, 466, 467
Web browser
executing applet in, 330,
331, 628
handling older, 644
using status window of, 642
Web server and servlets, 950, 951
while loop, 109–111
Whitespace, 37
from string, removing, 365
whitespaceChars( ), 575
Whois, 596–597
WIDTH, 644
Window
displaying information in,
704–705
frame. See Frame window
fundamentals, 691–693
status, using, 642
Window class, 693, 783
windowActivated( ), 672
windowClosed( ), 672
windowClosing( ), 672, 694, 695
windowDeactivated( ), 672
windowDeiconified( ), 672
WindowEvent class, 658, 667–668
WindowFocusListener interface,
669, 672
windowGainedFocus( ), 672
windowIconified( ), 672
WindowListener interface, 669,
672, 694
windowLostFocus( ), 672
windowOpened( ), 672
Windows 3.1 and Java, 26
Windows 95/98 and Windows NT
and Java, 26
wordChars( ), 575
World Wide Web, 7, 8, 597
wrap( ), 850
Wrappers, simple type, 380–401
write( ), 315, 322–323, 326–328, 850,
855–856
Writer class, 315, 545, 562
methods defined by, table
of, 564
writeObject( ), 578
writeTo( ), 554
X
XOR (exclusive OR) operator (^)
bitwise, 80, 82, 83
Boolean, 92
Y
Yellin, Frank, 7
Z
Zero crossing, 81
ZIP file format, 536
ZLIB file format, 536
1154 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
INTERNATIONAL CONTACT INFORMATION
AUSTRALIA
McGraw-Hill Book Company Australia Pty. Ltd.
TEL +61-2-9415-9899
FAX +61-2-9415-5687
http://www.mcgraw-hill.com.au
books-it_sydney@mcgraw-hill.com
CANADA
McGraw-Hill Ryerson Ltd.
TEL +905-430-5000
FAX +905-430-5020
http://www.mcgrawhill.ca
GREECE, MIDDLE EAST,
NORTHERN AFRICA
McGraw-Hill Hellas
TEL +30-1-656-0990-3-4
FAX +30-1-654-5525
MEXICO (Also serving Latin America)
McGraw-Hill Interamericana Editores S.A. de C.V.
TEL +525-117-1583
FAX +525-117-1589
http://www.mcgraw-hill.com.mx
fernando_castellanos@mcgraw-hill.com
SINGAPORE (Serving Asia)
McGraw-Hill Book Company
TEL +65-863-1580
FAX +65-862-3354
http://www.mcgraw-hill.com.sg
mghasia@mcgraw-hill.com
SOUTH AFRICA
McGraw-Hill South Africa
TEL +27-11-622-7512
FAX +27-11-622-9045
robyn_swanepoel@mcgraw-hill.com
UNITED KINGDOM & EUROPE
(Excluding Southern Europe)
McGraw-Hill Education Europe
TEL +44-1-628-502500
FAX +44-1-628-770224
http://www.mcgraw-hill.co.uk
computing_neurope@mcgraw-hill.com
ALL OTHER INQUIRIES Contact:
Osborne/McGraw-Hill
TEL +1-510-549-6600
FAX +1-510-883-7600
http://www.osborne.com
omg_international@mcgraw-hill.com
Herbert Schildt
0-07-213485-2
Chris H. Pappas & William 
H. Murray, III
0-07-212958-1
Jeffery R. Shapiro
0-07-213381-3
Complete References
For the answers to everything related to your technology, drill as deeply as you 
please into our Complete Reference series. Written by topical authorities, these 
comprehensive resources offer a full range of knowledge, including extensive product
information, theory, step-by-step tutorials, sample projects, and helpful appendixes.
Herbert Schildt
0-07-213084-9
Arthur Griffith
0-07-222405-3
Ron Ben-Natan & Ori Sasson
0-07-222394-4
For more information on these and other Osborne books, visit our Web site at www.osborne.com
