Chapter 24
New I/O, Regular
Expressions, and
Other Packages
843
When Java 1.0 was released, it included a set of eight packages, called the coreAPI. These are the packages described in the preceding chapters and are theones that you will use most often in your day-to-day programming. Each
subsequent release added to the core API. Today, the Java API contains a large number
of packages. Many of the new packages support areas of specialization that are beyond
the scope of this book. However, five packages warrant an examination here: java.nio,
java.util.regex, java.lang.reflect, java.rmi, and java.text. They support the new I/O
system, regular expression processing, reflection, Remote Method Invocation (RMI),
and text formatting, respectively. Two of these, the new I/O APIs and regular expression
processing, were added by Java 2, version 1.4.
The new I/O APIs offer a different way to look at and handle certain types of
I/O operations. The regular expression package lets you perform sophisticated pattern
matching operations.  This chapter provides an in-depth discussion of both of these
packages along with extensive examples. Reflection is the ability of software to analyze
itself. It is an essential part of the Java Beans technology that is covered in Chapter 25.
Examples are provided here to introduce the concept. Remote Method Invocation
(RMI) allows you to build Java applications that are distributed among several machines.
This chapter provides a simple client/server example that uses RMI. The text formatting
capabilities of java.text have many uses. The one examined here formats date and
time strings.
The Core Java API Packages
Table 24-1 lists all of the Java Core API packages defined by Java 2 and summarizes
their functions.
844 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Package Primary Function
java.applet Supports construction of applets.
java.awt Provides capabilities for graphical
user interfaces.
java.awt.color Supports color spaces and profiles.
java.awt.datatransfer Transfers data to and from the
system clipboard.
java.awt.dnd Supports drag-and-drop operations.
Table 24-1. The Core Java API Packages
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 845
TH
E
JA
V
A
LIB
R
A
R
Y
Package Primary Function
java.awt.event Handles events.
java.awt.font Represents various types of fonts.
java.awt.geom Allows you to work with
geometric shapes.
java.awt.im Allows input of Japanese, Chinese, and
Korean characters to text editing components.
java.awt.im.spi Supports alternative input devices. (Added by
Java 2, v1.3)
java.awt.image Processes images.
java.awt.image.renderable Supports rendering-independent images.
java.awt.print Supports general print capabilities.
java.beans Allows you to build software components.
java.beans.beancontext Provides an execution environment
for beans.
java.io Inputs and outputs data.
java.lang Provides core functionality.
java.lang.ref Enables some interaction with the
garbage collector.
java.lang.reflect Analyzes code at run time.
java.math Handles large integers and
decimal numbers.
java.net Supports networking.
java.nio Top-level package for the new Java I/O
classes. Encapsulates buffers. (Added by Java
2, v1.4)
java.nio.channels Encapsulates channels, which are used by the
new I/O system. (Added by Java 2, v1.4)
java.nio.channels.spi Supports service providers for channels.
(Added by Java 2, v1.4)
Table 24-1. The Core Java API Packages (continued)
846 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Package Primary Function
java.nio.charset Encapsulates character sets, which are used by
the new I/O system. (Added by Java 2, v1.4)
java.nio.charset.spi Supports service providers for charsets. (Added
by Java 2, v1.4)
java.rmi Provides remote method invocation.
java.rmi.activation Activates persistent objects.
java.rmi.dgc Manages distributed garbage collection.
java.rmi.registry Maps names to remote object references.
java.rmi.server Supports remote method invocation.
java.security Handles certificates, keys, digests, signatures,
and other security functions.
java.security.acl Manages access control lists.
java.security.cert Parses and manages certificates.
java.security.interfaces Defines interfaces for DSA (Digital Signature
Algorithm) keys.
java.security.spec Specifies keys and algorithm parameters.
java.sql Communicates with a SQL (Structured Query
Language) database.
java.text Formats, searches, and manipulates text.
java.util Contains common utilities.
java.util.jar Creates and reads JAR files.
java.util.logging Supports logging of information related to a
program’s execution. (Added by Java 2, v1.4)
java.util.prefs Encapsulates information relating to user
preferences. (Added by Java 2, v1.4)
java.util.regex Supports regular expression processing.
(Added by Java 2, v1.4)
java.util.zip Reads and writes compressed and
uncompressed ZIP files.
Table 24-1. The Core Java API Packages (continued)
The New I/O Packages
Java 2, version 1.4 added a new way to handle I/O operations. Called the new I/O APIs,
it is one of the more interesting additions that Sun included in the 1.4 release because it
supports a channel-based approach to I/O operations. The new I/O classes are
contained in the five packages shown here.
Package Purpose
java.nio Top-level package for the new I/O system.
Encapsulates various types of buffers which contain
data operated upon by the new I/O system.
java.nio.channels Supports channels, which are essentially open I/O
connections.
java.nio.channels.spi Supports service providers for channels.
java.nio.charset Encapsulates character sets. Also supports encoders
and decoders that convert characters to bytes and
bytes to characters, respectively.
java.nio.charset.spi Supports service providers for character sets.
Before we begin, it is important to emphasize that the new I/O subsystem (NIO) is not
intended to replace the I/O classes found in java.io, which are discussed in Chapter 17.
Instead, the NIO classes supplement the standard I/O system, giving you an alternative
approach, which can be beneficial in some circumstances.
NIO Fundamentals
The new I/O system is built on two foundational items: buffers and channels. A buffer
holds data. A channel represents an open connection to an I/O device, such as a file or
a socket. In general, to use the new I/O system, you obtain a channel to an I/O device
and a buffer to hold data. You then operate on the buffer, inputting or outputting data
as needed. The following sections examine buffers and channels in more detail.
Buffers
Buffers are defined in the java.nio package. All buffers are subclasses of the Buffer
class, which defines the core functionality common to all buffers: current position,
limit, and capacity. The current position is the index within the buffer at which the next
read or write operation will take place. The current position is advanced by most read
or write operations. The limit is the index of the end of the buffer. The capacity is the
number of elements that the buffer can hold. Buffer also supports mark and reset.
Buffer defines several methods, which are shown in Table 24-2.
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 847
TH
E
JA
V
A
LIB
R
A
R
Y
From Buffer are derived the following specific buffer classes, which hold the type
of data that their names imply.
ByteBuffer CharBuffer DoubleBuffer FloatBuffer
IntBuffer LongBuffer MappedByteBuffer ShortBuffer
MappedByteBuffer is a subclass of ByteBuffer that is used to map a file to a buffer.
848 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Method Description
final int capacity( ) Returns the number of elements that the
invoking buffer is capable of holding.
final Buffer clear( ) Clears the invoking buffer and returns a
reference to the buffer.
final Buffer flip( ) Sets the invoking buffer’s limit to the current
position and resets the current position to 0.
Returns a reference to the buffer.
final boolean hasRemaining( ) Returns true if there are elements remaining in
the invoking buffer. Returns false otherwise.
abstract boolean isReadOnly( ) Returns true if the invoking buffer is
read-only. Returns false otherwise.
final int limit( ) Returns the invoking buffer’s limit.
final Buffer limit(int n) Sets the invoking buffer’s limit to n. Returns a
reference to the buffer.
final Buffer mark( ) Sets the mark and returns a reference to the
invoking buffer.
final int position( ) Returns the current position.
final Buffer position(int n) Sets the invoking buffer’s current position to
n. Returns a reference to the buffer.
final Buffer reset( ) Resets the current position of the invoking
buffer to the previously set mark. Returns a
reference to the buffer.
final Buffer rewind( ) Sets the position of the invoking buffer to 0.
Returns a reference to the buffer.
Table 24-2. The methods defined by Buffer
All buffers support various get( ) and put( ) methods, which allow you to get data
from a buffer or put data into a buffer. For example, Table 24-3 shows the get( ) and
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 849
TH
E
JA
V
A
LIB
R
A
R
Y
Method Description
abstract byte get( ) Returns the byte at the current position.
ByteBuffer get(byte vals[ ] ) Copies the invoking buffer into the array
referred to by vals. Returns a reference to
the buffer.
ByteBuffer get(byte vals[ ], int start,
int num)
Copies num elements from the invoking
buffer into the array referred to by vals,
beginning at the index specified by start.
Returns a reference to the buffer. If there
are not num elements remaining in the
buffer, a BufferUnderflowException is
thrown.
abstract byte get(int idx) Returns the byte at the index specified by
idx within the invoking buffer.
abstract ByteBuffer put(byte b) Copies b into the invoking buffer at the
current position. Returns a reference to
the buffer.
final ByteBuffer put(byte vals[ ] ) Copies all elements of vals into the
invoking buffer, beginning at the current
position. Returns a reference to the buffer.
ByteBuffer put(byte vals[ ], int start,
int num)
Copies num elements from vals,
beginning at start, into the invoking
buffer. Returns a reference to the buffer. If
the buffer cannot hold all of the elements,
a BufferOverflowException is thrown.
ByteBuffer put(ByteBuffer bb) Copies the elements in bb to the invoking
buffer, beginning at the current position.
If the buffer cannot hold all of the
elements, a BufferOverflowException is
thrown. Returns a reference to the buffer.
abstract ByteBuffer put(int idx, byte b) Copies b into the invoking buffer at the
location specified by idx. Returns a
reference to the buffer.
Table 24-3. The get( ) and put( ) methods defined for ByteBuffer
put( ) methods defined by ByteBuffer. (The other buffer classes have similar methods.)
All buffer classes also support methods that perform various buffer operations. For
example, you can allocate a buffer manually using allocate( ). You can wrap an array
inside a buffer using wrap( ). You can create a subsequence of a buffer using slice( ).
Channels
Channels are defined in java.nio.channels. A channel represents an open connection to an
I/O source or destination. You obtain a channel by calling getChannel( ) on an object that
supports channels. Java 2, version 1.4 added getChannel( ) to the following I/O classes.
FileInputStream FileOutputStream RandomAccessFile
Socket ServerSocket DatagramSocket
Thus, to obtain a channel, you first obtain an object of one of these classes and then call
getChannel( ) on that object.
The specific type of channel returned depends upon the type of object getChannel( )
is called on. For example, when called on a FileInputStream, FileOuputStream, or
RandomAccessFile, getChannel( ) returns a channel of type FileChannel. When called
on a Socket, getChannel( ) returns a SocketChannel.
Channels such as FileChannel and SocketChannel support various read( ) and
write( ) methods that enable you to perform I/O operations through the channel. For
example, here are a few of the read( ) and write( ) methods defined for FileChannel.
All can throw an IOException.
Method Description
abstract int read(ByteBuffer bb) Reads bytes from the invoking channel into bb
until the buffer is full, or there is no more input.
Returns the number of bytes actually read.
abstract int read(ByteBuffer bb,
long start)
Beginning at the file location specified by start,
reads bytes from the invoking channel into
bb until the buffer is full, or there is no more
input. The current position is unchanged.
Returns the number of bytes actually read,
or –1 if start is beyond the end of the file.
abstract int write(ByteBuffer bb) Writes the contents of bb to the invoking
channel, starting at the current position.
Returns the number of bytes written.
abstract int write(ByteBuffer bb,
long start)
Beginning at the file location specified by
start, writes the contents of bb to the invoking
channel. The current position is unchanged.
Returns the number of bytes written.
850 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
All channels support additional methods that give you access to and control over the
channel. For example, FileChannel supports methods to get or set the current position,
transfer information between file channels, obtain the current size of the channel, and
lock the channel, among others. FileChannel also provides the map( ) method, which
lets you map a file to a buffer.
Charsets and Selectors
Two other entities used by NIO are charsets and selectors. A charset defines the way
that bytes are mapped to characters. You can encode a sequence of characters into
bytes using an encoder. You can decode a sequence of bytes into characters using a
decoder. Charsets, encoders, and decoders are supported by classes defined in the
java.nio.charset package. Because default encoders and decoders are provided, you
will not often need to work explicitly with charsets.
A selector supports key-based, non-blocking, multiplexed I/O. In other words,
selectors enable you to perform I/O through multiple channels. Selectors are
supported by classes defined in the java.nio.channels package. Selectors are most
applicable to socket-backed channels.
We will not use charsets or selectors in this chapter, but you might find them
useful in your own applications.
Using the New I/O System
Because the most common I/O device is the disk file, the rest of this section examines
how to access a disk file using the new I/O system. Because all file channel operations
are byte-based, the type of buffers that we will be using are of type ByteBuffer.
Reading a File
There are several ways to read data from a file using the new I/O system. We will look
at two. The first reads a file by manually allocating a buffer and then performing an
explicit read operation. The second uses a mapped file, which automates the process.
To read a file using a channel and a manually allocated buffer, follow this procedure.
First open the file for input using FileInputStream. Then, obtain a channel to this file
by calling getChannel( ). It has this general form:
FileChannel getChannel( )
It returns a FileChannel object, which encapsulates the channel for file operations. Once
a file channel has been opened, obtain the size of the file by calling size( ), shown here:
long size( ) throws IOException
It returns the current size, in bytes, of the channel, which reflects the underlying file.
Next, call allocate( ) to allocate a buffer large enough to hold the file’s contents. Because
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 851
TH
E
JA
V
A
LIB
R
A
R
Y
file channels operate on byte buffers you will use the allocate( ) method defined by
ByteBuffer. It has this general form.
static ByteBuffer allocate(int cap)
Here, cap specifies the capacity of the buffer. A reference to the buffer is returned. After
you have created the buffer, call read( ) on the channel, passing a reference to the buffer.
The following program shows how to read a text file called test.txt through a
channel using explicit input operations.
// Use the new I/O system to read a text file.
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
public class ExplicitChannelRead {
public static void main(String args[])
FileInputStream fIn;
FileChannel fChan;
long fSize;
ByteBuffer mBuf;
try
// First, open a file for input.
fIn = new FileInputStream("test.txt");
// Next, obtain a channel to that file.
fChan = fIn.getChannel();
// Now, get the file's size.
fSize = fChan.size();
// Allocate a buffer of the necessary size.
mBuf = ByteBuffer.allocate((int)fSize);
// Read the file into the buffer.
fChan.read(mBuf);
// Rewind the buffer so that it can be read.
mBuf.rewind();
// Read bytes from the buffer.
for(int i=0; i < fSize; i++)
852 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
System.out.print((char)mBuf.get());
System.out.println();
fChan.close(); // close channel
fIn.close();   // close file
} catch (IOException exc) {
System.out.println(exc);
System.exit(1);
}
}
}
Here is how the program works. First, a file is opened by using the FileInputStream
constructor and a reference to that object is assigned to fIn. Next, a channel connected
to the file is obtained by calling getChannel( ) on fIn and the size of the file is obtained
by calling size( ). The program then calls the allocate( ) method of ByteBuffer to
allocate a buffer that will hold the contents of the file when it is read. A byte buffer is
used because FileChannel operates on bytes. A reference to this buffer is stored in
mBuf. The contents of the file are then read into mBuf through a call to read( ). Next,
the buffer is rewound through a call to rewind( ). This call is necessary because the
current position is at the end of the buffer after the call to read( ). It must be reset to
the start of the buffer in order for the bytes in mBuf to be read by calling get( ). Because
mBuf is a byte buffer, the values returned by get( ) are bytes. They are cast to char so
that the file can be displayed as text. (Alternatively, it is possible to create a buffer that
encodes the bytes into characters, and then read that buffer.) The program ends by
closing the channel and the file.
A second, and often easier way to read a file is to map it to a buffer. The advantage
to this approach is that the buffer automatically contains the contents of the file. No
explicit read operation is necessary. To map and read the contents of a file, follow this
general procedure. First, open the file using FileInputStream. Next, obtain a channel to
that file by calling getChannel( ) on the file object. Then, map the channel to a buffer by
calling map( ) on the FileChannel object. The map( ) method is shown here:
MappedByteBuffer map(FileChannel.MapMode how,
long pos, long size) throws IOException
The map( ) method causes the data in the file to be mapped into a buffer in memory.
The value in how determines what type of operations are allowed. It must be one of
these values.
MapMode.READ MapMode.READ_WRITE MapMode.PRIVATE
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 853
TH
E
JA
V
A
LIB
R
A
R
Y
For reading a file, use MapMode.READ. To read and write, use MapeMode.READ_
WRITE. MapMode.PRIVATE causes a private copy of the file to be made and changes
to the buffer do not affect the underlying file. The location within the file to begin
mapping is specified by pos and the number of bytes to map are specified by size. A
reference to this buffer is returned as a MappedByteBuffer, which is a subclass of
ByteBuffer. Once the file has been mapped to a buffer, you can read the file from
that buffer.
The following program reworks the first example so that it uses a mapped file.
// Use a mapped file to read a text file.
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
public class MappedChannelRead {
public static void main(String args[]) {
FileInputStream fIn;
FileChannel fChan;
long fSize;
MappedByteBuffer mBuf;
try {
// First, open an file for input.
fIn = new FileInputStream("test.txt");
// Next, obtain a channel to that file.
fChan = fIn.getChannel();
// Get the size of the file.
fSize = fChan.size();
// Now, map the file into a buffer.
mBuf = fChan.map(FileChannel.MapMode.READ_ONLY,
0, fSize);
// Read bytes from the buffer.
for(int i=0; i < fSize; i++)
System.out.print((char)mBuf.get());
fChan.close(); // close channel
fIn.close();   // close file
} catch (IOException exc) {
854 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
System.out.println(exc);
System.exit(1);
}
}
}
As before, the file is opened by using the FileInputStream constructor and a reference
to that object is assigned to fIn. A channel connected to the file is obtained by calling
getChannel( ) on fIn, and the size of the file is obtained. Then the entire file is mapped
into memory by calling map( ) and a reference to the buffer is stored in mBuf. The
bytes in mBuf are read by calling get( ).
Writing to a File
There are several ways to write to a file through a channel. Again, we will look at two.
First, you can write data to an output file through a channel, by using explicit write
operations. Second, if the file is opened for read/write operations, you can map the file
to a buffer and then write to that buffer. Changes to the buffer will automatically be
reflected in the file. Both ways are described here.
To write to a file through a channel using explicit calls to write( ), follow these
steps. First, open the file for output. Then, allocate a byte buffer, put the data you
want to write into that buffer, and then called write( ) on the channel. The following
program demonstrates this procedure. It writes the alphabet to a file called test.txt.
// Write to a file using the new I/O.
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
public class ExplicitChannelWrite {
public static void main(String args[]) {
FileOutputStream fOut;
FileChannel fChan;
ByteBuffer mBuf;
try {
fOut = new FileOutputStream("test.txt");
// Get a channel to the output file.
fChan = fOut.getChannel();
// Create a buffer.
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 855
TH
E
JA
V
A
LIB
R
A
R
Y
mBuf = ByteBuffer.allocateDirect(26);
// Write some bytes to the buffer.
for(int i=0; i<26; i++)
mBuf.put((byte)('A' + i));
// Rewind the buffer so that it can written.
mBuf.rewind();
// Write the buffer to the output file.
fChan.write(mBuf);
// close channel and file.
fChan.close();
fOut.close();
} catch (IOException exc) {
System.out.println(exc);
System.exit(1);
}
}
}
The call to rewind( ) on mBuf is necessary in order to reset the current position to zero
after data has been written to mBuf. Remember, each call to put( ) advances the current
position. Therefore, it is necessary for the current position to be reset to the start of the
buffer before calling write( ). If this is not done, write( ) will think that there is no data
in the buffer.
To write to a file using a mapped file, follow these steps. First, open the file for
read/write operations. Next, map that file to a buffer by calling map( ). Then, write
to the buffer. Because the buffer is mapped to the file, any changes to that buffer are
automatically reflected in the file. Thus, no explicit write operations to the channel
are necessary. Here is the preceding program reworked so that a mapped file is used.
Notice that the file is opened as a RandomAccessFile. This is necessary to allow the
file to be read and written.
// Write to a mapped file.
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
public class MappedChannelWrite {
856 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public static void main(String args[]) {
RandomAccessFile fOut;
FileChannel fChan;
ByteBuffer mBuf;
try {
fOut = new RandomAccessFile("test.txt", "rw");
// Next, obtain a channel to that file.
fChan = fOut.getChannel();
// Then, map the file into a buffer.
mBuf = fChan.map(FileChannel.MapMode.READ_WRITE,
0, 26);
// Write some bytes to the buffer.
for(int i=0; i<26; i++)
mBuf.put((byte)('A' + i));
// close channel and file.
fChan.close();
fOut.close();
} catch (IOException exc) {
System.out.println(exc);
System.exit(1);
}
}
}
As you can see, there are no explicit write operations to the channel, itself. Because mBuf
is mapped to the file, changes to mBuf are automatically reflected in the underlying file.
Copying a File Using the New I/O
The new I/O system simplifies some types of file operations. For example, the
following program copies a file. It does so by opening an input channel to the source
file and an output channel to the target file. It then writes the mapped input buffer
to the output file in a single operation. You might want to compare this version of the
file copy program to the one found in Chapter 12. As you will find, the part of the
program that actually copies the file is substantially shorter.
// Copy a file using NIO.
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 857
TH
E
JA
V
A
LIB
R
A
R
Y
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
public class NIOCopy {
public static void main(String args[]) {
FileInputStream fIn;
FileOutputStream fOut;
FileChannel fIChan, fOChan;
long fSize;
MappedByteBuffer mBuf;
try {
fIn = new FileInputStream(args[0]);
fOut = new FileOutputStream(args[1]);
// Get channels to the input and output files.
fIChan = fIn.getChannel();
fOChan = fOut.getChannel();
// Get the size of the file.
fSize = fIChan.size();
// Map the input file to a buffer.
mBuf = fIChan.map(FileChannel.MapMode.READ_ONLY,
0, fSize);
// Write the buffer to the output file.
fOChan.write(mBuf); // this copies the file
// Close the channels and files.
fIChan.close();
fIn.close();
fOChan.close();
fOut.close();
} catch (IOException exc) {
System.out.println(exc);
System.exit(1);
} catch (ArrayIndexOutOfBoundsException exc) {
System.out.println("Usage: Copy from to");
858 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
System.exit(1);
}
}
}
Because the input file is mapped to mBuf, it contains the entire source file. Thus, the
call to write( ) copies all of mBuf to the target file. This, of course, means that the target
file is an identical copy of the source file.
Is NIO the Future of I/O Handling?
The new I/O APIs offer an exciting new way to think about and handle some types
of file operations. Because of this it is natural to ask the question, “Is NIO the future
of I/O handling?” Unfortunately, at the time of this writing, this question cannot be
answered. Certainly, channels and buffers offer a clean way of thinking about I/O.
However, they also add another layer of abstraction. Furthermore, the traditional
stream-based approach is both well-understood, and widely used. As explained at
the outset, channel-based I/O is currently designed to supplement, not replace the
standard I/O mechanisms defined in java.io. In this role, the channel/buffer approach
used by the NIO APIs succeeds admirably. Whether the new approach will someday
supplant the traditional approach, only time and usage patterns will tell.
Regular Expression Processing
Another exciting package added by Java 2, version 1.4 is java.util.regex, which
supports regular expression processing. As the term is used here, a regular expression is
a string of characters that describes a character sequence. This general description,
called a pattern, can then be used to find matches in other character sequences. Regular
expressions can specify wildcard characters, sets of characters, and various quantifiers.
Thus, you can specify a regular expression that represents a general form that can
match several different specific character sequences.
There are two classes that support regular expression processing: Pattern and
Matcher. These classes work together. Use Pattern to define a regular expression.
Match the pattern against another sequence using Matcher.
Pattern
The Pattern class defines no constructors. Instead, a pattern is created by calling the
compile( ) factory method. One of its forms is shown here:
static Pattern compile(String pattern)
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 859
TH
E
JA
V
A
LIB
R
A
R
Y
Here, pattern is the regular expression that you want to use. The compile( ) method
transforms the string in pattern into a pattern that can be used for pattern matching by
the Matcher class. It returns a Pattern object that contains the pattern.
Once you have created a Pattern object, you will use it to create a Matcher. This is
done by calling the matcher( ) factory method defined by Pattern. It is shown here:
Matcher matcher(CharSequence str)
Here str is the character sequence that the pattern will be matched against. This is
called the input sequence. CharSequence is an interface that was added by Java 2,
version 1.4 that defines a read-only set of characters. It is implemented by the String
class, among others. Thus, you can pass a string to matcher( ).
Matcher
The Matcher class has no constructors. Instead, you create a Matcher by calling the
matcher( ) factory method defined by Pattern, as just explained. Once you have created
a Matcher, you will use its methods to perform various pattern matching operations.
The simplest pattern matching method is matches( ), which simply determines
whether the character sequence matches the pattern. It is shown here:
boolean matches( )
It returns true if the sequence and the pattern match, and false otherwise. Understand
that the entire sequence must match the pattern, not just a subsequence of it.
To determine if a subsequence of the input sequence matches the pattern, use
find( ). One version is shown here:
boolean find( )
It returns true if there is a matching subsequence and false otherwise. This method can
be called repeatedly, allowing it to find all matching subsequences. Each call to find( )
begins where the previous one left off.
You can obtain a string containing the last matching sequence by calling group( ).
One of its forms is shown here:
String group( )
The matching string is returned. If no match exists, then an IllegalStateException
is thrown.
You can obtain the index within the input sequence of the current match by calling
start( ). The index one past the end of the current match is obtained by calling end( ).
These methods are shown here:
int start( )
int end( )
860 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
You can replace all occurrences of a matching sequence with another sequence by
calling replaceAll( ), shown here:
String replaceAll(String newStr)
Here, newStr specifies the new character sequence that will replace the ones that match
the pattern. The updated input sequence is returned as a string.
Regular Expression Syntax
Before demonstrating Pattern and Matcher it is necessary to explain how to construct a
regular expression. The syntax and rules that define a regular expression are similar to
those used by Perl 5. Although no rule is complicated by itself, there are a large number
of them, and a complete discussion is beyond the scope of this chapter. However, a few
of the more commonly used constructs are described here.
In general, a regular expression is comprised of normal characters, character classes
(sets of characters), wildcard characters, and quantifiers. A normal character is matched
as-is. Thus, if a pattern consists of “xy”, then the only input sequence that will match it
is “xy”. Characters such as newline and tab are specified using the standard escape
sequences, which begin with a \. For example, a newline is specified by \n. In the language
of regular expressions, a normal character is also called a literal.
A character class is a set of characters. A character class is specified by putting the
characters in the class between brackets. For example, the class [wxyz] matches w, x, y,
or z. To specify an inverted set, precede the characters with a ^. For example, [^wxyz]
matches any character except w, x, y, or z. You can specify a range of characters using a
hypen. For example, to specify a character class that will match the digits 1 through 9
use [1-9].
The wildcard character is the . (dot) and it matches any character. Thus, a pattern that
consists of “.” will match these (and other) input seqeunces: “A”, “a”, “x”, and so on.
A quantifier determines how many times an expression is matched. The quantifiers
are shown here:
+ Match one or more.
* Match zero or more.
? Match zero or one.
For example, the pattern “x+” will match “x”, “xx”, and “xxx”, among others.
Demonstrating Pattern Matching
The best way to understand how regular expression pattern matching operates is to work
through some examples. The first, shown here, looks for a match with a literal pattern.
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 861
TH
E
JA
V
A
LIB
R
A
R
Y
// A simple pattern matching demo.
import java.util.regex.*;
class RegExpr {
public static void main(String args[]) {
Pattern pat;
Matcher mat;
boolean found;
pat = Pattern.compile("Java");
mat = pat.matcher("Java");
found = mat.matches(); // check for a match
System.out.println("Testing Java against Java.");
if(found) System.out.println("Matches");
else System.out.println("No Match");
System.out.println();
System.out.println("Testing Java against Java 2.");
mat = pat.matcher("Java 2"); // create a new matcher
found = mat.matches(); // check for a match
if(found) System.out.println("Matches");
else System.out.println("No Match");
}
}
The output from the program is shown here:
Testing Java against Java.
Matches
Testing Java against Java 2.
No Match
Let’s look closely at this program. The program begins by creating the pattern that
contains the sequence “Java”. Next, a Matcher is created for that pattern that has the
input sequence “Java”. Then, the matches( ) method is called to determine if the input
sequence matches the pattern. Because, the sequence and the pattern are the same,
862 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
matches( ) returns true. Next, a new Matcher is created with the input sequence “Java 2”
and matches( ) is called again. In this case, the pattern and the input sequence differ,
and no match is found. Remember, the matches( ) function returns true only when the
input sequence precisely matches the pattern. It will not return true just because a
subsequence matches.
You can use find( ) to determine if the input sequence contains a subsequence that
matches the pattern. Consider the following program.
// Use find() to find a subsequence.
import java.util.regex.*;
class RegExpr2 {
public static void main(String args[]) {
Pattern pat = Pattern.compile("Java");
Matcher mat = pat.matcher("Java 2");
System.out.println("Looking for Java in Java 2.");
if(mat.find()) System.out.println("subsequence found");
else System.out.println("No Match");
}
}
The output is shown here:
Looking for Java in Java 2.
subsequence found
In this case, find( ) finds the subsequence “Java”.
The find( ) method can be used to search the input sequence for repeated occurrences
of the pattern because each call to find( ) picks up where the previous one left off. For
example, the following program finds two occurrences of the pattern “test”.
// Use find() to find multiple subsequences.
import java.util.regex.*;
class RegExpr3 {
public static void main(String args[]) {
Pattern pat = Pattern.compile("test");
Matcher mat = pat.matcher("test 1 2 3 test");
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 863
TH
E
JA
V
A
LIB
R
A
R
Y
while(mat.find()) {
System.out.println("test found at index " +
mat.start());
}
}
}
The output is shown here:
test found at index 0
test found at index 11
As the output shows, two matches were found. The program uses the start( ) method to
obtain the index of each match.
Using Wildcards and Quantifiers
Although the preceding programs show the general technique for using Pattern and
Matcher, they don’t show their power. The real benefit of regular expression processing
is not seen until wildcards and quantifiers are used. To begin, consider the following
example that uses the + quantifier to match any arbitrarily long sequence of Ws.
// Use a quantifier.
import java.util.regex.*;
class RegExpr4 {
public static void main(String args[]) {
Pattern pat = Pattern.compile("W+");
Matcher mat = pat.matcher("W WW WWW");
while(mat.find())
System.out.println("Match: " + mat.group());
}
}
The output from the program is shown here:
Match: W
Match: WW
Match: WWW
864 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
As the output shows, the regular expression pattern “W+” matches any arbitrarily long
sequence of Ws.
The next program uses a wildcard to create a pattern that will match any sequence
that begins with e and ends with d. To do this, it uses the dot wildcard character along
with the + quantifier.
// Use wildcard and quantifier.
import java.util.regex.*;
class RegExpr5 {
public static void main(String args[]) {
Pattern pat = Pattern.compile("e.+d");
Matcher mat = pat.matcher("extend cup end table");
while(mat.find())
System.out.println("Match: " + mat.group());
}
}
You might be surprised by the the output produced by the program, which is
shown here:
Match: extend cup end
Only one match is found, and it is the longest sequence that begins with e and ends
with d. You might have expected two matches: extend and end. The reason that the
longer sequence is found is that by default, find( ) matches the longest sequence that
fits the pattern. This is called greedy behavior. You can specify reluctant behavior by adding
the ? quantifier to the pattern, as shown in this version of the program. It causes the
shortest matching pattern to be obtained.
// Use the ? quantifier.
import java.util.regex.*;
class RegExpr6 {
public static void main(String args[]) {
// Use reluctant matching behavior.
Pattern pat = Pattern.compile("e.+?d");
Matcher mat = pat.matcher("extend cup end table");
while(mat.find())
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 865
TH
E
JA
V
A
LIB
R
A
R
Y
System.out.println("Match: " + mat.group());
}
}
The output from the program is shown here:
Match: extend
Match: end
As the output shows, the pattern “e.+?d” will match the shortest sequence that begins
with e and ends with d. Thus, two matches are found.
Working with Classes of Characters
Sometimes you will want to match any sequence that contains one or more characters,
in any order, that are part of a set of characters. For example, to match whole words,
you want to match any sequence of the letters of the alphabet. One of the easiest ways
to do this is to use a character class, which defines a set of characters. Recall that a
character class is created by putting the characters you want to match between brackets.
For example, to match the lowercase characters a through z, use [a-z]. The following
program demonstrates this technique.
// Use a character class.
import java.util.regex.*;
class RegExpr7 {
public static void main(String args[]) {
// Match lowercase words.
Pattern pat = Pattern.compile("[a-z]+");
Matcher mat = pat.matcher("this is a test.");
while(mat.find())
System.out.println("Match: " + mat.group());
}
}
The output is shown here:
Match: this
Match: is
Match: a
Match: test
866 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Using replaceAll( )
The replaceAll( ) method supplied by Matcher lets you perform powerful search and
replace operations that use regular expressions. For example, the following program
replaces all occurrences of sequences that begin with “Jon” with “Eric”.
// Use replaceAll().
import java.util.regex.*;
class RegExpr8 {
public static void main(String args[]) {
String str = "Jon Jonathan Frank Ken Todd";
Pattern pat = Pattern.compile("Jon.*? ");
Matcher mat = pat.matcher(str);
System.out.println("Original sequence: " + str);
str = mat.replaceAll("Eric ");
System.out.println("Modified sequence: " + str);
}
}
The output is shown here:
Original sequence: Jon Jonathan Frank Ken Todd
Modified sequence: Eric Eric Frank Ken Todd
Because the regular expression “Jon.*? “ matches any string that begins with Jon
followed by zero or more characters, ending in a space, it can be used to match and
replace both Jon and Jonathan with the name Eric. Such a substitution is not possible
without pattern matching capabilities.
Using split( )
You can reduce an input sequence into its individual tokens by using the split( )
method defined by Pattern. The split( ) method is shown here:
String[ ] split(CharSequence str)
It processes the input sequence passed in str, reducing it into tokens based on the
delimiters specified by the pattern.
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 867
TH
E
JA
V
A
LIB
R
A
R
Y
For example, the following program finds tokens that are separated by spaces,
commas, periods, and exclamation points.
// Use split().
import java.util.regex.*;
class RegExpr9 {
public static void main(String args[]) {
// Match lowercase words.
Pattern pat = Pattern.compile("[ ,.!]");
String strs[] = pat.split("one two,alpha9 12!done.");
for(int i=0; i < strs.length; i++)
System.out.println("Next token: " + strs[i]);
}
}
The output is shown here:
Next token: one
Next token: two
Next token: alpha9
Next token: 12
Next token: done
As the output shows, the input sequence is reduced to its individual tokens. Notice that
the delimiters are not included.
Two Pattern-Matching Options
Although the pattern-matching techniques described in the foregoing offer the greatest
flexibility and power, there are two alternatives which you might find useful in some
circumstances. If you only need to perform a one-time pattern match, you can use the
matches( ) method defined by Pattern. It is shown here:
static boolean matches(String pattern, CharSequence str)
868 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
It returns true if pattern matches str and false otherwise. This method automatically
compiles pattern and then looks for a match. If you will be using the same pattern
repeatedly, then using matches( ) is less efficient than compiling the pattern and using
the pattern-matching methods defined by Matcher, as described previously.
You can also perform a pattern match by using the matches( ) method
implemented by String. It is shown here:
boolean matches(String pattern)
If the invoking string matches the regular expression in pattern, then matches( ) returns
true. Otherwise, it returns false.
Exploring Regular Expressions
The overview of regular expressions presented in this section only hints at their power.
Since text parsing, manipulation, and tokenization are a large part of programming,
you will likely find Java’s regular expression subsystem a powerful tool that you can
use to your advantage. It is, therefore, wise to explore the capabilities of regular
expressions. Experiment with several different types of patterns and input sequences.
Once you understand how regular expression pattern matching works, you will find
it useful in many of your programming endeavors.
Reflection
Reflection is the ability of software to analyze itself. This is provided by the
java.lang.reflect package and elements in Class. Reflection is an important capability,
needed when using components called Java Beans. It allows you to analyze a software
component and describe its capabilities dynamically, at run time rather than at compile
time. For example, by using reflection, you can determine what methods, constructors,
and fields a class supports.
The package java.lang.reflect has an interface, called Member, which defines
methods that allow you to get information about a field, constructor, or method of
a class. There are also eight classes in this package. These are listed in Table 24-4.
The following application illustrates a simple use of the Java reflection capabilities.
It prints the constructors, fields, and methods of the class java.awt.Dimension. The
program begins by using the forName( ) method of Class to get a class object for
java.awt.Dimension. Once this is obtained, getConstructors( ), getFields( ), and
getMethods( ) are used to analyze this class object. They return arrays of Constructor,
Field, and Method objects that provide the information about the object. The
Constructor, Field, and Method classes define several methods that can be used
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 869
TH
E
JA
V
A
LIB
R
A
R
Y
to obtain information about an object. You will want to explore these on your own.
However, each supports the toString( ) method. Therefore, using Constructor, Field,
and Method objects as arguments to the println( ) method is straightforward, as shown
in the program.
// Demonstrate reflection.
import java.lang.reflect.*;
public class ReflectionDemo1 {
public static void main(String args[]) {
try {
Class c = Class.forName("java.awt.Dimension");
System.out.println("Constructors:");
Constructor constructors[] = c.getConstructors();
for(int i = 0; i < constructors.length; i++) {
System.out.println(" " + constructors[i]);
}
System.out.println("Fields:");
Field fields[] = c.getFields();
for(int i = 0; i < fields.length; i++) {
System.out.println(" " + fields[i]);
870 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Class Primary Function
AccessibleObject Allows you to bypass the default access control checks.
(Added by Java 2)
Array Allows you to dynamically create and manipulate arrays.
Constructor Provides information about a constructor.
Field Provides information about a field.
Method Provides information about a method.
Modifier Provides information about class and member access
modifiers.
Proxy Supports dynamic proxy classes. (Added by Java 2, v1.3)
ReflectPermission Allows reflection of private or protected members of a class.
(Added by Java 2)
Table 24-4. Classes Defined in java.lang.reflect
}System.out.println("Methods:");
Method methods[] = c.getMethods();
for(int i = 0; i < methods.length; i++) {
System.out.println(" " + methods[i]);
}
}
catch(Exception e) {
System.out.println("Exception: " + e);
}
}
}
Here is the output from this program:
Constructors:
public java.awt.Dimension(java.awt.Dimension)
public java.awt.Dimension(int,int)
public java.awt.Dimension()
Fields:
public int java.awt.Dimension.width
public int java.awt.Dimension.height
Methods:
public int java.awt.Dimension.hashCode()
public boolean java.awt.Dimension.equals(java.lang.Object)
public java.lang.String java.awt.Dimension.toString()
public void java.awt.Dimension.setSize(java.awt.Dimension)
public void java.awt.Dimension.setSize(int,int)
public void java.awt.Dimension.setSize(double,double)
public java.awt.Dimension java.awt.Dimension.getSize()
public double java.awt.Dimension.getWidth()
public double java.awt.Dimension.getHeight()
public java.lang.Object java.awt.geom.Dimension2D.clone()
public void java.awt.geom.Dimension2D.
setSize(java.awt.geom.Dimension2D)
public final native java.lang.Class java.lang.Object.getClass()
public final void java.lang.Object.wait(long,int) throws
java.lang.InterruptedException
public final void java.lang.Object.wait()
throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws
java.lang.InterruptedException
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 871
TH
E
JA
V
A
LIB
R
A
R
Y
The next example uses Java’s reflection capabilities to obtain the public methods of
a class. The program begins by instantiating class A. The getClass( ) method is applied to
this object reference and it returns the Class object for class A. The getDeclaredMethods( )
method returns an array of Method objects that describe only the methods declared by this
class. Methods inherited from superclasses such as Object are not included.
Each element of the methods array is then processed. The getModifiers( ) method
returns an int containing flags that describe which access modifiers apply for this
element. The Modifier class provides a set of methods, shown in Table 24-5, that can be
872 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Method Description
static boolean isAbstract(int val) Returns true if val has the abstract flag set
and false otherwise.
static boolean isFinal(int val) Returns true if val has the final flag set
and false otherwise.
static boolean isInterface(int val) Returns true if val has the interface flag
set and false otherwise.
static boolean isNative(int val) Returns true if val has the native flag set
and false otherwise.
static boolean isPrivate(int val) Returns true if val has the private flag set
and false otherwise.
static boolean isProtected(int val) Returns true if val has the protected flag
set and false otherwise.
static boolean isPublic(int val) Returns true if val has the public flag set
and false otherwise.
static boolean isStatic(int val) Returns true if val has the static flag set
and false otherwise.
static boolean isStrict(int val) Returns true if val has the strict flag set
and false otherwise.
static boolean isSynchronized(int val) Returns true if val has the synchronized
flag set and false otherwise.
static boolean isTransient(int val) Returns true if val has the transient flag
set and false otherwise.
static boolean isVolatile(int val) Returns true if val has the volatile flag set
and false otherwise.
Table 24-5. Methods Defined by Modifier That Determine Access Modifiers
used to examine this value. For example, the static method isPublic( ) returns true if its
argument includes the public access modifier. Otherwise, it returns false. In the
following program, if the method supports public access, its name is obtained by the
getName( ) method and is then printed.
// Show public methods.
import java.lang.reflect.*;
public class ReflectionDemo2 {
public static void main(String args[]) {
try {
A a = new A();
Class c = a.getClass();
System.out.println("Public Methods:");
Method methods[] = c.getDeclaredMethods();
for(int i = 0; i < methods.length; i++) {
int modifiers = methods[i].getModifiers();
if(Modifier.isPublic(modifiers)) {
System.out.println(" " + methods[i].getName());
}
}
}
catch(Exception e) {
System.out.println("Exception: " + e);
}
}
}
class A {
public void a1() {
}
public void a2() {
}
protected void a3() {
}
private void a4() {
}
}
Here is the output from this program:
Public Methods:
a1
a2
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 873
TH
E
JA
V
A
LIB
R
A
R
Y
Remote Method Invocation (RMI)
Remote Method Invocation (RMI) allows a Java object that executes on one machine
to invoke a method of a Java object that executes on another machine. This is an
important feature, because it allows you to build distributed applications. While a
complete discussion of RMI is outside the scope of this book, the following example
describes the basic principles involved.
A Simple Client/Server Application Using RMI
This section provides step-by-step directions for building a simple client/server
application by using RMI. The server receives a request from a client, processes it, and
returns a result. In this example, the request specifies two numbers. The server adds
these together and returns the sum.
Step One: Enter and Compile the Source Code
This application uses four source files. The first file, AddServerIntf.java, defines the
remote interface that is provided by the server. It contains one method that accepts
two double arguments and returns their sum. All remote interfaces must extend the
Remote interface, which is part of java.rmi. Remote defines no members. Its purpose
is simply to indicate that an interface uses remote methods. All remote methods can
throw a RemoteException.
import java.rmi.*;
public interface AddServerIntf extends Remote {
double add(double d1, double d2) throws RemoteException;
}
The second source file, AddServerImpl.java, implements the remote interface.
The implementation of the add( ) method is straightforward. All remote objects must
extend UnicastRemoteObject, which provides functionality that is needed to make
objects available from remote machines.
import java.rmi.*;
import java.rmi.server.*;
public class AddServerImpl extends UnicastRemoteObject
implements AddServerIntf {
public AddServerImpl() throws RemoteException {
}
public double add(double d1, double d2) throws RemoteException {
return d1 + d2;
}
}
874 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The third source file, AddServer.java, contains the main program for the server
machine. Its primary function is to update the RMI registry on that machine. This is
done by using the rebind( ) method of the Naming class (found in java.rmi). That
method associates a name with an object reference. The first argument to the rebind( )
method is a string that names the server as “AddServer”. Its second argument is a
reference to an instance of AddServerImpl.
import java.net.*;
import java.rmi.*;
public class AddServer {
public static void main(String args[]) {
try {
AddServerImpl addServerImpl = new AddServerImpl();
Naming.rebind("AddServer", addServerImpl);
}
catch(Exception e) {
System.out.println("Exception: " + e);
}
}
}
The fourth source file, AddClient.java, implements the client side of this
distributed application. AddClient.java requires three command line arguments. The
first is the IP address or name of the server machine. The second and third arguments
are the two numbers that are to be summed.
The application begins by forming a string that follows the URL syntax. This URL
uses the rmi protocol. The string includes the IP address or name of the server and the
string “AddServer”. The program then invokes the lookup( ) method of the Naming
class. This method accepts one argument, the rmi URL, and returns a reference to an
object of type AddServerIntf. All remote method invocations can then be directed to
this object.
The program continues by displaying its arguments and then invokes the remote
add( ) method. The sum is returned from this method and is then printed.
import java.rmi.*;
public class AddClient {
public static void main(String args[]) {
try {
String addServerURL = "rmi://" + args[0] + "/AddServer";
AddServerIntf addServerIntf =
(AddServerIntf)Naming.lookup(addServerURL);
System.out.println("The first number is: " + args[1]);
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 875
TH
E
JA
V
A
LIB
R
A
R
Y
double d1 = Double.valueOf(args[1]).doubleValue();
System.out.println("The second number is: " + args[2]);
double d2 = Double.valueOf(args[2]).doubleValue();
System.out.println("The sum is: " + addServerIntf.add(d1, d2));
}
catch(Exception e) {
System.out.println("Exception: " + e);
}
}
}
After you enter all the code, use javac to compile the four source files that you created.
Step Two: Generate Stubs and Skeletons
Before you can use the client and server, you must generate the necessary stub. You
may also need to generate a skeleton. In the context of RMI, a stub is a Java object that
resides on the client machine. Its function is to present the same interfaces as the
remote server. Remote method calls initiated by the client are actually directed to the
stub. The stub works with the other parts of the RMI system to formulate a request that
is sent to the remote machine.
A remote method may accept arguments that are simple types or objects. In the
latter case, the object may have references to other objects. All of this information must
be sent to the remote machine. That is, an object passed as an argument to a remote
method call must be serialized and sent to the remote machine. Recall from Chapter 17
that the serialization facilities also recursively process all referenced objects.
Skeletons are not required by Java 2. However, they are required for the Java 1.1
RMI model. Because of this, skeletons are still required for compatibility between Java
1.1 and Java 2. A skeleton is a Java object that resides on the server machine. It works
with the other parts of the 1.1 RMI system to receive requests, perform deserialization,
and invoke the appropriate code on the server. Again, the skeleton mechanism is not
required for Java 2 code that does not require compatibility with 1.1. Because many
readers will want to generate the skeleton, one is used by this example.
If a response must be returned to the client, the process works in reverse. Note
that the serialization and deserialization facilities are also used if objects are returned
to a client.
To generate stubs and skeletons, you use a tool called the RMI compiler, which is
invoked from the command line, as shown here:
rmic AddServerImpl
876 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
This command generates two new files: AddServerImpl_Skel.class (skeleton) and
AddServerImpl_Stub.class (stub). When using rmic, be sure that CLASSPATH is set
to include the current directory. As you can see, by default, rmic generates both a stub
and a skeleton file. If you do not need the skeleton, you have the option to suppress it.
Step Three: Install Files on the Client and Server Machines
Copy AddClient.class, AddServerImpl_Stub.class, and AddServerIntf.class to a
directory on the client machine. Copy AddServerIntf.class, AddServerImpl.class,
AddServerImpl_Skel.class, AddServerImpl_Stub.class, and AddServer.class to a
directory on the server machine.
RMI has techniques for dynamic class loading, but they are not used by the example at
hand. Instead, all of the files that are used by the client and server applications must be
installed manually on those machines.
Step Four: Start the RMI Registry on the Server Machine
The Java 2 SDK provides a program called rmiregistry, which executes on the server
machine. It maps names to object references. First, check that the CLASSPATH
environment variable includes the directory in which your files are located. Then,
start the RMI Registry from the command line, as shown here:
start rmiregistry
When this command returns, you should see that a new window has been created.
You need to leave this window open until you are done experimenting with the
RMI example.
Step Five: Start the Server
The server code is started from the command line, as shown here:
java AddServer
Recall that the AddServer code instantiates AddServerImpl and registers that object
with the name “AddServer”.
Step Six: Start the Client
The AddClient software requires three arguments: the name or IP address of the server
machine and the two numbers that are to be summed together. You may invoke it from
the command line by using one of the two formats shown here:
java AddClient server1 8 9
java AddClient 11.12.13.14 8 9
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 877
TH
E
JA
V
A
LIB
R
A
R
Y
In the first line, the name of the server is provided. The second line uses its IP address
(11.12.13.14).
You can try this example without actually having a remote server. To do so, simply
install all of the programs on the same machine, start rmiregistry, start AddSever, and
then execute AddClient using this command line:
java AddClient 127.0.0.1 8 9
Here, the address 127.0.0.1 is the “loop back” address for the local machine. Using this
address allows you to exercise the entire RMI mechanism without actually having to
install the server on a remote computer.
In either case, sample output from this program is shown here:
The first number is: 8
The second number is: 9
The sum is: 17.0
Text Formatting
The package java.text allows you to format, search, and manipulate text. This section
takes a brief look at its most commonly used classes: those that format date and time
information.
DateFormat Class
DateFormat is an abstract class that provides the ability to format and parse dates and
times. The getDateInstance( ) method returns an instance of DateFormat that can
format date information. It is available in these forms:
static final DateFormat getDateInstance( )
static final DateFormat getDateInstance(int style)
static final DateFormat getDateInstance(int style, Locale locale)
The argument style is one of the following values: DEFAULT, SHORT, MEDIUM,
LONG, or FULL. These are int constants defined by DateFormat. They cause different
details about the date to be presented. The argument locale is one of the static references
defined by Locale (refer to Chapter 16 for details). If the style and/or locale is not
specified, defaults are used.
One of the most commonly used methods in this class is format( ). It has several
overloaded forms, one of which is shown here:
final String format(Date d)
878 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The argument is a Date object that is to be displayed. The method returns a string
containing the formatted information.
The following listing illustrates how to format date information. It begins by
creating a Date object. This captures the current date and time information. Then it
outputs the date information by using different styles and locales.
// Demonstrate date formats.
import java.text.*;
import java.util.*;
public class DateFormatDemo {
public static void main(String args[]) {
Date date = new Date();
DateFormat df;
df = DateFormat.getDateInstance(DateFormat.SHORT, Locale.JAPAN);
System.out.println("Japan: " + df.format(date));
df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.KOREA);
System.out.println("Korea: " + df.format(date));
df = DateFormat.getDateInstance(DateFormat.LONG, Locale.UK);
System.out.println("United Kingdom: " + df.format(date));
df = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);
System.out.println("United States: " + df.format(date));
}
}
Sample output from this program is shown here:
Japan: 02/05/08
Korea: 2002-05-08
United Kingdom: 08 May 2002
United States: Wednesday, May 8, 2002
The getTimeInstance( ) method returns an instance of DateFormat that can format
time information. It is available in these versions:
static final DateFormat getTimeInstance( )
static final DateFormat getTimeInstance(int style)
static final DateFormat getTimeInstance(int style, Locale locale)
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 879
TH
E
JA
V
A
LIB
R
A
R
Y
The argument style is one of the following values: DEFAULT, SHORT, MEDIUM,
LONG, or FULL. These are int constants defined by DateFormat. They cause
different details about the time to be presented. The argument locale is one of the
static references defined by Locale. If the style and/or locale is not specified,
defaults are used.
The following listing illustrates how to format time information. It begins by
creating a Date object. This captures the current date and time information and then
outputs the time information by using different styles and locales.
// Demonstrate time formats.
import java.text.*;
import java.util.*;
public class TimeFormatDemo {
public static void main(String args[]) {
Date date = new Date();
DateFormat df;
df = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.JAPAN);
System.out.println("Japan: " + df.format(date));
df = DateFormat.getTimeInstance(DateFormat.LONG, Locale.UK);
System.out.println("United Kingdom: " + df.format(date));
df = DateFormat.getTimeInstance(DateFormat.FULL, Locale.CANADA);
System.out.println("Canada: " + df.format(date));
}
}
Sample output from this program is shown here:
Japan: 20:25
United Kingdom: 20:25:14 CDT
Canada: 8:25:14 o'clock PM CDT
The DateFormat class also has a getDateTimeInstance( ) method that can format
both date and time information. You may wish to experiment with it on your own.
SimpleDateFormat Class
SimpleDateFormat is a concrete subclass of DateFormat. It allows you to define your
own formatting patterns that are used to display date and time information.
One of its constructors is shown here:
SimpleDateFormat(String formatString)
880 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The argument formatString describes how date and time information is displayed. An
example of its use is given here:
SimpleDateFormat sdf = SimpleDateFormat("dd MMM yyyy hh:mm:ss zzz");
The symbols used in the formatting string determine the information that is displayed.
Table 24-6 lists these symbols and gives a description of each.
In most cases, the number of times a symbol is repeated determines how that data
is presented. Text information is displayed in an abbreviated form if the pattern letter
is repeated less than four times. Otherwise, the unabbreviated form is used. For
C h a p t e r 2 4 : N e w I / O , R e g u l a r E x p r e s s i o n s , a n d O t h e r P a c k a g e s 881
TH
E
JA
V
A
LIB
R
A
R
Y
Symbol Description
a AM or PM
d Day of month (1–31)
h Hour in AM/PM (1–12)
k Hour in day (1–24)
m Minute in hour (0–59)
s Second in minute (0–59)
w Week of year (1–52)
y Year
z Time zone
D Day of year (1–366)
E Day of week (for example, Thursday)
F Day of week in month
G Era (that is, AD or BC)
H Hour in day (0–23)
K Hour in AM/PM (0–11)
M Month
S Millisecond in second
W Week of month (1–5)
Z Time zone in RFC822 format
Table 24-6. Formatting String Symbols for SimpleDateFormat
example, a zzzz pattern can display Pacific Daylight Time, and a zzz pattern can
display PDT.
For numbers, the number of times a pattern letter is repeated determines how
many digits are presented. For example, hh:mm:ss can present 01:51:15, but h:m:s
displays the same time value as 1:51:15.
Finally, M or MM causes the month to be displayed as one or two digits. However,
three or more repetitions of M cause the month to be displayed as a text string.
The following program shows how this class is used:
// Demonstrate SimpleDateFormat.
import java.text.*;
import java.util.*;
public class SimpleDateFormatDemo {
public static void main(String args[]) {
Date date = new Date();
SimpleDateFormat sdf;
sdf = new SimpleDateFormat("hh:mm:ss");
System.out.println(sdf.format(date));
sdf = new SimpleDateFormat("dd MMM yyyy hh:mm:ss zzz");
System.out.println(sdf.format(date));
sdf = new SimpleDateFormat("E MMM dd yyyy");
System.out.println(sdf.format(date));
}
}
Sample output from this program is shown here:
02:18:23
08 May 2002 02:18:23 CDT
Wed May 08 2002
882 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Part III
Software Development Using Java
This page intentionally left blank.
Chapter 25
Java Beans
885
886 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
This chapter provides an overview of an exciting technology that is at the forefrontof Java programming: Java Beans. Beans are important, because they allow you tobuild complex systems from software components. These components may be
provided by you or supplied by one or more different vendors. Java Beans defines an
architecture that specifies how these building blocks can operate together.
To better understand the value of Beans, consider the following. Hardware designers
have a wide variety of components that can be integrated together to construct a system.
Resistors, capacitors, and inductors are examples of simple building blocks. Integrated
circuits provide more advanced functionality. All of these different parts can be reused.
It is not necessary or possible to rebuild these capabilities each time a new system is
needed. Also, the same pieces can be used in different types of circuits. This is possible
because the behavior of these components is understood and documented.
Unfortunately, the software industry has not been as successful in achieving the
benefits of reusability and interoperability. Large applications grow in complexity and
become very difficult to maintain and enhance. Part of the problem is that, until recently,
there has not been a standard, portable way to write a software component. To achieve
the benefits of component software, a component architecture is needed that allows
programs to be assembled from software building blocks, perhaps provided by different
vendors. It must also be possible for a designer to select a component, understand its
capabilities, and incorporate it into an application. When a new version of a component
becomes available, it should be easy to incorporate this functionality into existing code.
Fortunately, Java Beans provides just such an architecture.
What Is a Java Bean?
A Java Bean is a software component that has been designed to be reusable in a variety
of different environments. There is no restriction on the capability of a Bean. It may
perform a simple function, such as checking the spelling of a document, or a complex
function, such as forecasting the performance of a stock portfolio. A Bean may be
visible to an end user. One example of this is a button on a graphical user interface.
A Bean may also be invisible to a user. Software to decode a stream of multimedia
information in real time is an example of this type of building block. Finally, a Bean
may be designed to work autonomously on a user’s workstation or to work in
cooperation with a set of other distributed components. Software to generate a pie
chart from a set of data points is an example of a Bean that can execute locally.
However, a Bean that provides real-time price information from a stock or
commodities exchange would need to work in cooperation with other distributed
software to obtain its data.
You will see shortly what specific changes a software developer must make to a
class so that it is usable as a Java Bean. However, one of the goals of the Java designers
was to make it easy to use this technology. Therefore, the code changes are minimal.
Advantages of Java Beans
A software component architecture provides standard mechanisms to deal with
software building blocks. The following list enumerates some of the specific benefits
that Java technology provides for a component developer:
■ A Bean obtains all the benefits of Java’s “write-once, run-anywhere” paradigm.
■ The properties, events, and methods of a Bean that are exposed to an
application builder tool can be controlled.
■ A Bean may be designed to operate correctly in different locales, which makes it
useful in global markets.
■ Auxiliary software can be provided to help a person configure a Bean. This
software is only needed when the design-time parameters for that component
are being set. It does not need to be included in the run-time environment.
■ The configuration settings of a Bean can be saved in persistent storage and
restored at a later time.
■ A Bean may register to receive events from other objects and can generate
events that are sent to other objects.
Application Builder Tools
When working with Java Beans, most developers use an application builder tool, a utility
that enables you to configure a set of Beans, connect them together, and produce a
working application. In general, Bean builder tools have the following capabilities.
■ A palette is provided that lists all of the available Beans. As additional Beans
are developed or purchased, they can be added to the palette.
■ A worksheet is displayed that allows the designer to lay out Beans in a graphical
user interface. A designer may drag and drop a Bean from the palette to this
worksheet.
■ Special editors and customizers allow a Bean to be configured. This is the
mechanism by which the behavior of a Bean may be adapted for a particular
environment.
■ Commands allow a designer to inquire about the state and behavior of a
Bean. This information automatically becomes available when a Bean is added
to the palette.
■ Capabilities exist to interconnect Beans. This means that events generated by
one component are mapped to method invocations on other components.
C h a p t e r 2 5 : J a v a B e a n s 887
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
■ When a collection of Beans has been configured and connected, it is possible to
save all of this information in a persistent storage area. At a later time, this
information can then be used to restore the state of the application.
Sun provides two Bean application builder tools. The first is the BeanBox, which is
part of the Bean Developers Kit (BDK). The BDK is the original builder tool provided
by Sun. The second is the new Bean Builder. Because Bean Builder is designed to
supplant the BeanBox, Sun has stopped development of the BDK and all new Bean
applications will be created using Bean Builder.
Although Bean Builder is the future of Bean development, it is not the sole focus of
this chapter. Instead, both BeanBox and Bean Builder are discussed. The reason for this
is that Bean Builder requires Java 2, version 1.4. It is incompatible with earlier versions
of Java 2. This means that readers of this book using Java 2, version 1.2 or version 1.3
will not be able to use Bean Builder. Instead, they must continue to use the BDK. Further,
readers using version 1.4 cannot use the BDK because it is not compatible with Java 2,
version 1.4. So, if you are using version 1.4, then you must use Bean Builder. If you are
using a version of Java prior to 1.4, you must use the BDK. Thus, both approaches are
described here, beginning with the BDK. Keep in mind that the information about Beans,
Bean architecture, JAR files, and so on, apply to either Bean development tool.
One other point: At the time of this writing, Java 2, version 1.4 is a released product,
but Bean Builder is currently in beta testing. This means that the only way for a 1.4 user
to create a Bean application is to do so using latest Bean Builder beta. For this reason,
we will not examine its features in depth at this time. However, at the end of this
chapter, a general overview is presented and a sample application is created.
Using the Bean Developer Kit (BDK)
The Bean Developer Kit (BDK), available from the JavaSoft site, is a simple example
of a tool that enables you to create, configure, and connect a set of Beans. There is
also a set of sample Beans with their source code. This section provides step-by-step
instructions for installing and using this tool. Remember, the BDK is for use with
versions of Java 2 prior to 1.4. For Java 2, v1.4 you must use the Bean Builder Tool
described at the end of this chapter.
In this chapter, instructions are provided for a Windows environment. The procedures
for a UNIX platform are similar, but some of the commands are different.
Installing the BDK
The Java 2  SDK must be installed on your machine for the BDK to work. Confirm that
the SDK tools are accessible from your environment.
The BDK can then be downloaded from the JavaSoft site (http://java.sun.com). It is
packaged as one file that is a self-extracting archive. Follow the instructions to install
it on your machine. The discussion that follows assumes that the BDK is installed in
888 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
a directory called bdk. If this is not the case with your system, substitute the proper
directory.
Starting the BDK
To start the BDK, follow these steps:
1. Change to the directory c:\bdk\beanbox.
2. Execute the batch file called run.bat. This causes the BDK to display the three
windows shown in Figure 25-1. ToolBox lists all of the different Beans that have
been included with the BDK. BeanBox provides an area to lay out and connect
the Beans selected from the ToolBox. Properties provides the ability to configure
a selected Bean. You may also see a window called Method Tracer, but we
won’t be using it.
Using the BDK
This section describes how to create an application by using some of the Beans
provided with the BDK. First, the Molecule Bean displays a three-dimensional view of
a molecule. It may be configured to present one of the following molecules: hyaluronic
acid, benzene, buckminsterfullerine, cyclohexane, ethane, or water. This component
also has methods that allow the molecule to be rotated in space along its X or Y axis.
C h a p t e r 2 5 : J a v a B e a n s 889
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Figure 25-1. The Bean Developer Kit (BDK)
Second, the OurButton Bean provides a push-button functionality. We will have one
button labeled “Rotate X” to rotate the molecule along its X axis and another button
labeled “Rotate Y” to rotate the molecule along its Y axis.
Figure 25-2 shows how this application appears.
Create and Configure an Instance of the Molecule Bean
Follow these steps to create and configure an instance of the Molecule Bean:
1. Position the cursor on the ToolBox entry labeled Molecule and click the left
mouse button. You should see the cursor change to a cross.
2. Move the cursor to the BeanBox display area and click the left mouse button in
approximately the area where you wish the Bean to be displayed. You should
see a rectangular region appear that contains a 3-D display of a molecule. This
area is surrounded by a hatched border, indicating that it is currently selected.
3. You can reposition the Molecule Bean by positioning the cursor over one of the
hatched borders and dragging the Bean.
4. You can change the molecule that is displayed by changing the selection in the
Properties window. Notice that the Bean display changes immediately when
you change the selected molecule.
890 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 25-2. The Molecule and OurButton Beans
C h a p t e r 2 5 : J a v a B e a n s 891
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Create and Configure an Instance of the OurButton Bean
Follow these steps to create and configure an instance of the OurButton Bean and
connect it to the Molecule Bean:
1. Position the cursor on the ToolBox entry labeled OurButton and click the left
mouse button. You should see the cursor change to a cross.
2. Move the cursor to the BeanBox display area and click the left mouse button in
approximately the area where you wish the Bean to be displayed. You should
see a rectangular region appear that contains a button. This area is surrounded
by a hatched border indicating that it is currently selected.
3. You may reposition the OurButton Bean by positioning the cursor over one of
the hatched borders and dragging the Bean.
4. Go to the Properties window and change the label of the Bean to “Rotate X”.
The button appearance changes immediately when this property is changed.
5. Go to the menu bar of the BeanBox and select Edit | Events | action |
actionPerformed. You should now see a line extending from the button to the
cursor. Notice that one end of the line moves as the cursor moves. However, the
other end of the line remains fixed at the button.
6. Move the cursor so that it is inside the Molecule Bean display area, and click
the left mouse button. You should see the Event Target Dialog dialog box.
7. The dialog box allows you to choose a method that should be invoked when
this button is clicked. Select the entry labeled “rotateOnX” and click the OK
button. You should see a message box appear very briefly, stating that the tool
is “Generating and compiling adaptor class.”
Test the application. Each time you press the button, the molecule should move a
few degrees around one of its axes.
Now create another instance of the OurButton Bean. Label it “Rotate Y” and map
its action event to the “rotateY” method of the Molecule Bean. The steps to do this are
very similar to those just described for the button labeled “Rotate X”.
Test the application by clicking these buttons and observing how the molecule moves.
JAR Files
Before developing your own Bean, it is necessary for you to understand JAR (Java
Archive) files, because tools such as the BDK expect Beans to be packaged within JAR
files. A JAR file allows you to efficiently deploy a set of classes and their associated
resources. For example, a developer may build a multimedia application that uses
various sound and image files. A set of Beans can control how and when this
information is presented. All of these pieces can be placed into one JAR file.
JAR technology makes it much easier to deliver and install software. Also, the
elements in a JAR file are compressed, which makes downloading a JAR file much
faster than separately downloading several uncompressed files. Digital signatures may
also be associated with the individual elements in a JAR file. This allows a consumer to
be sure that these elements were produced by a specific organization or individual.
The package java.util.zip contains classes that read and write JAR files.
Manifest Files
A developer must provide a manifest file to indicate which of the components in a JAR
file are Java Beans. An example of a manifest file is provided in the following listing. It
defines a JAR file that contains four .gif files and one .class file. The last entry is a Bean.
Name: sunw/demo/slides/slide0.gif
Name: sunw/demo/slides/slide1.gif
Name: sunw/demo/slides/slide2.gif
Name: sunw/demo/slides/slide3.gif
Name: sunw/demo/slides/Slides.class
Java-Bean: True
A manifest file may reference several .class files. If a .class file is a Java Bean, its
entry must be immediately followed by the line “Java-Bean: True”.
The JAR Utility
A utility is used to generate a JAR file. Its syntax is shown here:
jar options files
Table 25-1 lists the possible options and their meanings. The following examples show
how to use this utility.
Creating a JAR File
The following command creates a JAR file named Xyz.jar that contains all of the .class
and .gif files in the current directory:
jar cf Xyz.jar *.class *.gif
If a manifest file such as Yxz.mf is available, it can be used with the following command:
jar cfm Xyz.jar Yxz.mf *.class *.gif
892 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Tabulating the Contents of a JAR File
The following command lists the contents of Xyz.jar:
jar tf Xyz.jar
Extracting Files from a JAR File
The following command extracts the contents of Xyz.jar and places those files in the
current directory:
jar xf Xyz.jar
C h a p t e r 2 5 : J a v a B e a n s 893
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Option Description
c A new archive is to be created.
C Change directories during command execution.
f The first element in the file list is the name of the archive that is to be
created or accessed.
i Index information should be provided.
m The second element in the file list is the name of the external manifest file.
M Manifest file not created.
t The archive contents should be tabulated.
u Update existing JAR file.
v Verbose output should be provided by the utility as it executes.
x Files are to be extracted from the archive. (If there is only one file, that
is the name of the archive, and all files in it are extracted. Otherwise,
the first element in the file list is the name of the archive, and the
remaining elements in the list are the files that should be extracted
from the archive.)
0 Do not use compression.
Table 25-1. JAR Command Options
Updating an Existing JAR File
The following command adds the file file1.class to Xyz.jar:
jar -uf Xyz.jar file1.class
Recursing Directories
The following command adds all files below directoryX to Xyz.jar:
jar -uf Xyz.jar -C directoryX *
Introspection
Introspection is the process of analyzing a Bean to determine its capabilities. This is an
essential feature of the Java Beans API, because it allows an application builder tool to
present information about a component to a software designer. Without introspection,
the Java Beans technology could not operate.
There are two ways in which the developer of a Bean can indicate which of its
properties, events, and methods should be exposed by an application builder tool. With
the first method, simple naming conventions are used. These allow the introspection
mechanisms to infer information about a Bean. In the second way, an additional class is
provided that explicitly supplies this information. The first approach is examined here.
The second method is described later.
The following sections indicate the design patterns for properties and events that
enable the functionality of a Bean to be determined.
Design Patterns for Properties
A property is a subset of a Bean’s state. The values assigned to the properties determine
the behavior and appearance of that component. This section discusses three types of
properties: simple, Boolean, and indexed.
Simple Properties
A simple property has a single value. It can be identified by the following design
patterns, where N is the name of the property and T is its type.
public T getN( );
public void setN(T arg);
A read/write property has both of these methods to access its values. A read-only
property has only a get method. A write-only property has only a set method.
894 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The following listing shows a class that has three read/write simple properties:
public class Box {
private double depth, height, width;
public double getDepth( ) {
return depth;
}
public void setDepth(double d) {
depth = d;
}
public double getHeight( ) {
return height;
}
public void setHeight(double h) {
height = h;
}
public double getWidth( ) {
return width;
}
public void setWidth(double w) {
width = w;
}
}
Boolean Properties
A Boolean property has a value of true or false. It can be identified by the following
design patterns, where N is the name of the property:
public boolean isN( );
public boolean getN( );
public void setN(boolean value);
Either the first or second pattern can be used to retrieve the value of a Boolean
property. However, if a class has both of these methods, the first pattern is used.
The following listing shows a class that has one Boolean property:
public class Line {
private boolean dotted = false;
public boolean isDotted( ) {
return dotted;
}
public void setDotted(boolean dotted) {
C h a p t e r 2 5 : J a v a B e a n s 895
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
this.dotted = dotted;
}
}
Indexed Properties
An indexed property consists of multiple values. It can be identified by the following
design patterns, where N is the name of the property and T is its type:
public T getN(int index);
public void setN(int index, T value);
public T[ ] getN( );
public void setN(T values[ ]);
The following listing shows a class that has one read/write indexed property:
public class PieChart {
private double data[ ];
public double getData(int index) {
return data[index];
}
public void setData(int index, double value) {
data[index] = value;
}
public double[ ] getData( ) {
return data;
}
public void setData(double[ ] values) {
data = new double[values.length];
System.arraycopy(values, 0, data, 0, values.length);
}
}
Design Patterns for Events
Beans use the delegation event model that was discussed earlier in this book. Beans
can generate events and send them to other objects. These can be identified by the
following design patterns, where T is the type of the event:
public void addTListener(TListener eventListener);
public void addTListener(TListener eventListener) throws TooManyListeners;
public void removeTListener(TListener eventListener);
896 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
These methods are used by event listeners to register an interest in events of a specific
type. The first pattern indicates that a Bean can multicast an event to multiple listeners.
The second pattern indicates that a Bean can unicast an event to only one listener. The
third pattern is used by a listener when it no longer wishes to receive a specific type of
event notification from a Bean.
The following listing outlines a class that notifies other objects when a temperature
value moves outside a specific range. The two methods indicated here allow other
objects that implement the TemperatureListener interface to receive notifications when
this occurs.
public class Thermometer {
public void addTemperatureListener(TemperatureListener tl) {
...
}
public void removeTemperatureListener(TemperatureListener tl) {
...
}
}
Methods
Design patterns are not used for naming nonproperty methods. The introspection
mechanism finds all of the public methods of a Bean. Protected and private methods
are not presented.
Developing a Simple Bean Using the BDK
This section presents an example that shows how to develop a simple Bean and
connect it to other components via the BDK.
Our new component is called the Colors Bean. It appears as either a rectangle or
ellipse that is filled with a color. A color is chosen at random when the Bean begins
execution. A public method can be invoked to change it. Each time the mouse is clicked
on the Bean, another random color is chosen. There is one boolean read/write property
that determines the shape.
The BDK is used to lay out an application with one instance of the Colors Bean and
one instance of the OurButton Bean. The button is labeled “Change.” Each time it is
pressed, the color changes.
Figure 25-3 shows how this application appears.
C h a p t e r 2 5 : J a v a B e a n s 897
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Create a New Bean
Here are the steps that you must follow to create a new Bean:
1. Create a directory for the new Bean.
2. Create the Java source file(s).
3. Compile the source file(s).
4. Create a manifest file.
5. Generate a JAR file.
6. Start the BDK.
7. Test.
The following sections discuss each of these steps in detail.
Create a Directory for the New Bean
You need to make a directory for the Bean. To follow along with this example, create
c:\bdk\demo\sunw\demo\colors. Then change to that directory.
898 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 25-3. The Colors and OurButton Beans
Create the Source File for the New Bean
The source code for the Colors component is shown in the following listing. It is
located in the file Colors.java.
The import statement at the beginning of the file places it in the package named
sunw.demo.colors. Recall from Chapter 9 that the directory hierarchy corresponds to
the package hierarchy. Therefore, this file must be located in a subdirectory named
sunw\demo\colors relative to the CLASSPATH environment variable.
The color of the component is determined by the private Color variable color, and
its shape is determined by the private boolean variable rectangular.
The constructor defines an anonymous inner class that extends MouseAdapter and
overrides its mousePressed( ) method. The change( ) method is invoked in response to
mouse presses. The component is initialized to a rectangular shape of 200 by 100 pixels.
The change( ) method is invoked to select a random color and repaint the component.
The getRectangular( ) and setRectangular( ) methods provide access to the one
property of this Bean. The change( ) method calls randomColor( ) to choose a color and
then calls repaint( ) to make the change visible. Notice that the paint( ) method uses the
rectangular and color variables to determine how to present the Bean.
// A simple Bean.
package sunw.demo.colors;
import java.awt.*;
import java.awt.event.*;
public class Colors extends Canvas {
transient private Color color;
private boolean rectangular;
public Colors() {
addMouseListener(new MouseAdapter() {
public void mousePressed(MouseEvent me) {
change();
}
});
rectangular = false;
setSize(200, 100);
change();
}
public boolean getRectangular() {
return rectangular;
}
public void setRectangular(boolean flag) {
this.rectangular = flag;
repaint();
}
public void change() {
C h a p t e r 2 5 : J a v a B e a n s 899
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
color = randomColor();
repaint();
}
private Color randomColor() {
int r = (int)(255*Math.random());
int g = (int)(255*Math.random());
int b = (int)(255*Math.random());
return new Color(r, g, b);
}
public void paint(Graphics g) {
Dimension d = getSize();
int h = d.height;
int w = d.width;
g.setColor(color);
if(rectangular) {
g.fillRect(0, 0, w-1, h-1);
}
else {
g.fillOval(0, 0, w-1, h-1);
}
}
}
Compile the Source Code for the New Bean
Compile the source code to create a class file. Type the following:
javac Colors.java.
Create a Manifest File
You must now create a manifest file. First, switch to the c:\bdk\demo directory. This
is the directory in which the manifest files for the BDK demos are located. Put the
source code for your manifest file in the file colors.mft. It is shown here:
Name: sunw/demo/colors/Colors.class
Java-Bean: True
This file indicates that there is one .class file in the JAR file and that it is a Java Bean.
Notice that the Colors.class file is in the package sunw.demo.colors and in the
subdirectory sunw\demo\colors relative to the current directory.
900 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Generate a JAR File
Beans are included in the ToolBox window of the BDK only if they are in JAR files in the
directory c:\bdk\jars. These files are generated with the jar utility. Enter the following:
jar cfm ..\jars\colors.jar colors.mft sunw\demo\colors\*.class
This command creates the file colors.jar and places it in the directory c:\bdk\jars.
(You may wish to put this in a batch file for future use.)
Start the BDK
Change to the directory c:\bdk\beanbox and type run. This causes the BDK to start.
You should see three windows, titled ToolBox, BeanBox, and Properties. The ToolBox
window should include an entry labeled “Colors” for your new Bean.
Create an Instance of the Colors Bean
After you complete the preceding steps, create an instance of the Colors Bean in the
BeanBox window. Test your new component by pressing the mouse anywhere within
its borders. Its color immediately changes. Use the Properties window to change the
rectangular property from false to true. Its shape immediately changes.
Create and Configure an Instance of the OurButton Bean
Create an instance of the OurButton Bean in the BeanBox window. Then follow
these steps:
1. Go to the Properties window and change the label of the Bean to “Change”.
You should see that the button appearance changes immediately when this
property is changed.
2. Go to the menu bar of the BeanBox and select Edit | Events | action |
actionPerformed.
3. Move the cursor so that it is inside the Colors Bean display area, and click the
left mouse button. You should see the Event Target Dialog dialog box.
4. The dialog box allows you to choose a method that should be invoked when
this button is clicked. Select the entry labeled “change” and click the OK button.
You should see a message box appear very briefly, stating that the tool is
“Generating and compiling adaptor class.”
5. Click on the button. You should see the color change.
You might want to experiment with the Colors Bean a bit before moving on.
C h a p t e r 2 5 : J a v a B e a n s 901
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Using Bound Properties
A Bean that has a bound property generates an event when the property is changed.
The event is of type PropertyChangeEvent and is sent to objects that previously
registered an interest in receiving such notifications.
The TickTock Bean is supplied with the BDK. It generates a property change event
every N seconds. N is a property of the Bean that can be changed via the Properties
window of the BDK. The next example builds an application that uses the TickTock Bean
to automatically control the Colors Bean. Figure 25-4 shows how this application appears.
Steps
For this example, start the BDK and create an instance of the Colors Bean in the
BeanBox window.
Create an instance of the TickTock Bean. The Properties window should show one
property for this component. It is “Interval” and its initial value is 5. This represents
the number of seconds that elapse between property change events generated by the
TickTock Bean. Change the value to 1.
902 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 25-4. The Colors and TickTock Beans
C h a p t e r 2 5 : J a v a B e a n s 903
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Now you need to map events generated by the TickTock Bean into method calls on
the Colors Bean. Follow these steps:
1. Go to the menu bar of the BeanBox and select Edit | Events | propertyChange |
propertyChange. You should now see a line extending from the button to
the cursor.
2. Move the cursor so that it is inside the Colors Bean display area, and click the
left mouse button. You should see the Event Target Dialog dialog box.
3. The dialog box allows you to choose a method that should be invoked when
this event occurs. Select the entry labeled “change” and click the OK button.
You should see a message box appear very briefly, stating that the tool is
“Generating and compiling adaptor class.”
You should now see the color of your component change every second.
Using the BeanInfo Interface
In our previous examples, design patterns were used to determine the information that
was provided to a Bean user. This section describes how a developer can use the
BeanInfo interface to explicitly control this process.
This interface defines several methods, including these:
PropertyDescriptor[ ] getPropertyDescriptors( )
EventSetDescriptor[ ] getEventSetDescriptors( )
MethodDescriptor[ ] getMethodDescriptors( )
They return arrays of objects that provide information about the properties, events, and
methods of a Bean. By implementing these methods, a developer can designate exactly
what is presented to a user.
SimpleBeanInfo is a class that provides default implementations of the BeanInfo
interface, including the three methods just shown. You may extend this class and override
one or more of them. The following listing shows how this is done for the Colors
Bean that was developed earlier. ColorsBeanInfo is a subclass of SimpleBeanInfo.
It overrides getPropertyDescriptors( ) in order to designate which properties are
presented to a Bean user. This method creates a PropertyDescriptor object for the
rectangular property. The PropertyDescriptor constructor that is used is shown here:
PropertyDescriptor(String property, Class beanCls)
throws IntrospectionException
Here, the first argument is the name of the property, and the second argument is the
class of the Bean.
// A Bean information class.
package sunw.demo.colors;
import java.beans.*;
public class ColorsBeanInfo extends SimpleBeanInfo {
public PropertyDescriptor[] getPropertyDescriptors() {
try {
PropertyDescriptor rectangular = new
PropertyDescriptor("rectangular", Colors.class);
PropertyDescriptor pd[] = {rectangular};
return pd;
}
catch(Exception e) {
}
return null;
}
}
You must compile this file from the BDK\demo directory or set CLASSPATH so
that it includes c:\bdk\demo. If you don’t, the compiler won’t find the Colors.class
file properly. After this file is successfully compiled, the colors.mft file can be updated,
as shown here:
Name: sunw/demo/colors/ColorsBeanInfo.class
Name: sunw/demo/colors/Colors.class
Java-Bean: True
Use the JAR tool to create a new colors.jar file. Restart the BDK and create an
instance of the Colors Bean in the BeanBox.
The introspection facilities are designed to look for a BeanInfo class. If it exists,
its behavior explicitly determines the information that is presented to a Bean user.
Otherwise, design patterns are used to infer this information.
Figure 25-5 shows how the Properties window now appears. Compare it with
Figure 24-3. You can see that the properties inherited from Component are no longer
presented for the Colors Bean. Only the rectangular property appears.
904 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Constrained Properties
A Bean that has a constrained property generates an event when an attempt is made to
change its value. The event is of type PropertyChangeEvent. It is sent to objects that
previously registered an interest in receiving such notifications. Those other objects
have the ability to veto the proposed change. This capability allows a Bean to operate
differently according to its run-time environment. A full discussion of constrained
properties is beyond the scope of this book.
Persistence
Persistence is the ability to save a Bean to nonvolatile storage and retrieve it at a later
time. The information that is particularly important are the configuration settings.
C h a p t e r 2 5 : J a v a B e a n s 905
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Figure 25-5. Using the ColorsBeanInfo Class
Let us first see how the BDK allows you to save a set of Beans that have been
configured and connected together to form an application. Recall our previous example
involving both the Colors and TickTock Beans. The rectangular property of the Colors
Bean was changed to true, and the interval property of the TickTock Bean was changed
to one second. These changes can be saved.
To save the application, go to the menu bar of the BeanBox and select File | Save.
A dialog box should appear, allowing you to specify the name of a file to which the
Beans and their configuration parameters should be saved. Supply a filename and click
the OK button on that dialog box. Exit from the BDK.
Start the BDK again. To restore the application, go to the menu bar of the BeanBox
and select File | Load. A dialog box should appear, allowing you to specify the name
of the file from which an application should be restored. Supply the name of the file in
which the application was saved, and click the OK button. Your application should
now be functioning. Confirm that the rectangular property of the Colors Bean is true
and that the interval property for the TickTock Bean is equal to one second.
The object serialization capabilities provided by the Java class libraries are used
to provide persistence for Beans. If a Bean inherits directly or indirectly from
java.awt.Component, it is automatically serializable, because that class implements
the java.io.Serializable interface. If a Bean does not inherit an implementation of the
Serializable interface, you must provide this yourself. Otherwise, containers cannot
save the configuration of your component.
The transient keyword can be used to designate data members of a Bean that should
not be serialized. The color variable of the Colors class is an example of such an item.
Customizers
The Properties window of the BDK allows a developer to modify the properties of a
Bean. However, this may not be the best user interface for a complex component with
many interrelated properties. Therefore, a Bean developer can provide a customizer that
helps another developer configure this software. A customizer can provide a
step-by-step guide through the process that must be followed to use the component
in a specific context. Online documentation can also be provided. A Bean developer
has great flexibility to develop a customizer that can differentiate his or her product
in the marketplace.
The Java Beans API
The Java Beans functionality is provided by a set of classes and interfaces in the
java.beans package. This section provides a brief overview of its contents. Table 25-2
lists the interfaces in java.beans and provides a brief description of their functionality.
Table 25-3 lists the classes in java.beans.
906 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
C h a p t e r 2 5 : J a v a B e a n s 907
Interface Description
AppletInitializer Methods in this interface are used to initialize Beans
that are also applets.
BeanInfo This interface allows a designer to specify
information about the properties, events, and
methods of a Bean.
Customizer This interface allows a designer to provide a
graphical user interface through which a Bean may
be configured.
DesignMode Methods in this interface determine if a Bean is
executing in design mode.
ExceptionListener A method in this interface is invoked when an
exception has occurred. (Added by Java 2, version 1.4.)
PropertyChangeListener A method in this interface is invoked when a bound
property is changed.
PropertyEditor Objects that implement this interface allow
designers to change and display property values.
VetoableChangeListener A method in this interface is invoked when a
constrained property is changed.
Visibility Methods in this interface allow a Bean to execute
in environments where a graphical user interface is
not available.
Table 25-2. The Interfaces Defined in java.beans
Class Description
BeanDescriptor This class provides information about a Bean.
It also allows you to associate a customizer
with a Bean.
Beans This class is used to obtain information about
a Bean.
Table 25-3. The Classes Defined in java.beans
908 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Class Description
DefaultPersistenceDelegate A concrete subclass of PersistenceDelegate.
(Added by Java 2, version 1.4.)
Encoder Encodes the state of a set of Beans. Can be used
to write this information to a stream. (Added by
Java 2, version 1.4.)
EventHandler Supports dynamic event listener creation.
(Added by Java 2, version 1.4.)
EventSetDescriptor Instances of this class describe an event that can
be generated by a Bean.
Expression Encapsulates a call to a method that returns a
result. (Added by Java 2, version 1.4.)
FeatureDescriptor This is the superclass of the PropertyDescriptor,
EventSetDescriptor, and MethodDescriptor
classes.
IndexedPropertyDescriptor Instances of this class describe an indexed
property of a Bean.
IntrospectionException An exception of this type is generated if a
problem occurs when analyzing a Bean.
Introspector This class analyzes a Bean and constructs a
BeanInfo object that describes the component.
MethodDescriptor Instances of this class describe a method of
a Bean.
ParameterDescriptor Instances of this class describe a method
parameter.
PersistenceDelegate Handles the state information of an object.
(Added by Java 2, version 1.4.)
PropertyChangeEvent This event is generated when bound or constrained
properties are changed. It is sent to objects that
registered an interest in these events and
implement either the PropertyChangeListener or
VetoableChangeListener interfaces.
Table 25-3. The Classes Defined in java.beans (continued)
A complete discussion of these classes and interfaces is beyond the scope of this
book. However, the following program illustrates the Introspector, BeanDescriptor,
C h a p t e r 2 5 : J a v a B e a n s 909
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Class Description
PropertyChangeListenerProxy Extends EventListenerProxy and implements
PropertyChangeListener. (Added by Java 2,
version 1.4.)
PropertyChangeSupport Beans that support bound properties can use this
class to notify PropertyChangeListener objects.
PropertyDescriptor Instances of this class describe a property of
a Bean.
PropertyEditorManager This class locates a PropertyEditor object for a
given type.
PropertyEditorSupport This class provides functionality that can be
used when writing property editors.
PropertyVetoException An exception of this type is generated if a change
to a constrained property is vetoed.
SimpleBeanInfo This class provides functionality that can be
used when writing BeanInfo classes.
Statement Encapsulates a call to a method. (Added by Java 2,
version 1.4.)
VetoableChangeListenerProxy Extends EventListenerProxy and implements
VetoableChangeListener. (Added by Java 2,
version 1.4.)
VetoableChangeSupport Beans that support constrained properties can
use this class to notify VetoableChangeListener
objects.
XMLDecoder Used to read a Bean from an XML document.
(Added by Java 2, version 1.4.)
XMLEncoder Used to write a Bean to an XML document.
(Added by Java 2, version 1.4.)
Table 25-3. The Classes Defined in java.beans (continued)
PropertyDescriptor, and EventSetDescriptor classes and the BeanInfo interface. It lists
the properties and events of the Colors Bean that was developed earlier in this chapter.
// Show properties and events.
package sunw.demo.colors;
import java.awt.*;
import java.beans.*;
public class IntrospectorDemo {
public static void main(String args[]) {
try {
Class c = Class.forName("sunw.demo.colors.Colors");
BeanInfo beanInfo = Introspector.getBeanInfo(c);
BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor();
System.out.println("Bean name = " +
beanDescriptor.getName());
System.out.println("Properties:");
PropertyDescriptor propertyDescriptor[] =
beanInfo.getPropertyDescriptors();
for(int i = 0; i < propertyDescriptor.length; i++) {
System.out.println("\t" + propertyDescriptor[i].getName());
}
System.out.println("Events:");
EventSetDescriptor eventSetDescriptor[] =
beanInfo.getEventSetDescriptors();
for(int i = 0; i < eventSetDescriptor.length; i++) {
System.out.println("\t" + eventSetDescriptor[i].getName());
}
}
catch(Exception e) {
System.out.println("Exception caught. " + e);
}
}
}
The output from this program is the following:
Bean name = Colors
Properties:
910 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
rectangular
Events:
propertyChange
component
mouseMotion
mouse
hierarchy
key
focus
hierarchyBounds
inputMethod
Using Bean Builder
As explained at the start of the chapter, the BDK is not compatible with Java 2, version 1.4.
Instead, 1.4 users will need to use the new Bean Builder tool for Bean development. At
the time of this writing, Bean Builder is available only as a beta release, and its final
form and feature set are subject to change. However, because it is the tool that Java 2,
version 1.4 users must use to develop Beans, an overview of Bean Builder is presented
here. (Subsequent editions of this book will cover Bean Builder in detail after it is a
released product.) Keep in mind that the basic Bean information, such as introspection,
described earlier, also applies to Beans used by Bean Builder. Bean Builder is available
from http://java.sun.com.
Bean Builder is similar to the BeanBox offered by the BDK, except that it is more
powerful and sophisticated. Its operation is also similar to the BeanBox except that it is
easier to use. Perhaps the most striking feature of Bean Builder is that it supports two
separate modes of operation: design and test. In design mode, you construct a Bean-based
application, adding the various components, and wiring them together. In test mode,
also called run-time mode, the application is executed and all of the components are live.
Thus, it is extremely easy to construct and then test your application. Futhermore, you
switch between these two modes by checking or clearing a single check box.
Bean Builder provides the three windows shown in Figure 25-6. The top (main)
window holds the current palette set. This includes a default palette from which you
can choose various user-interface objects, such as buttons, scroll bars, lists, and menus.
These are Swing rather than AWT objects. (You will find an overview of Swing in
Chapter 26, but no knowledge of Swing is required to follow along with the example
developed later in this section.) You can also load other palettes and JAR files. Each
component has associated with it a set of properties. You can examine and set these
using the Property Inspector window provided by Bean Builder. The third window,
C h a p t e r 2 5 : J a v a B e a n s 911
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
called the design window (or, designer for short), is the window in which you will
assemble various components into an application.
In general, to build an application, you will select items from a palette and
instantiate them on the designer, setting their properties as necessary by using the
Property Inspector window. Once you have assembled the components, you will wire
them together by dragging a line from one to another. In the process, you will define
the input and output methods that will be called, and what action causes them to be
called. For example, you might wire a push button to a text field, specifying that when
the push button is pressed, the text field will be cleared.
912 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 25-6. The Bean Builder Windows
Building a Simple Bean Builder Application
It is really quite easy to build an application using Bean Builder. In this section, we
will walk through the construction of a very simple one that contains a label, a slider
control, and a scroll bar. When the slider control is moved, the scroll bar is also moved
by the same amount, and vice versa. Thus, moving one causes the other to move, too.
Once you have completed this walk through, you will be able to easily build other
applications on your own.
First, create a new project by selecting New from the File menu. Next, select
javax.swing.JFrame in the list at the top of the Property Inspector window. JFrame is
the top-level Swing class for the design window. Next, scroll down in the Property
Inspector window until you find title. Change the title to “A Bean Builder App”.
Your screen should look like the one shown in Figure 25-7.
C h a p t e r 2 5 : J a v a B e a n s 913
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Figure 25-7. A new Bean Builder Application
Next, we will add a label to the design. Click on the label button in the Swing
palette. This instantiates a JLabel object, which is the Swing class for a label. Then,
move the mouse to the designer and outline a rectangle near the top of the window.
This defines were the text will go. Then, using the Property Inspector window, find
the text entry. Change it to “Move slider or scroll bar.” After you do this, your screen
will look like Figure 25-8. Now, find the horizontalAlignment field in the Property
Inspector and change its value to CENTER. This will center the text within the label.
Next, select a slider from the palette and add it to the designer. Then, add a scroll
bar. The slider is an instance of the Swing class JSlider and the scroll bar is an instance
914 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 25-8. After adding a label
of the Swing class JScrollbar. By default, both the slider and the scroll bar have the
same range (0 to 100), so the value of one will translate directly to the value of the
other. To make your application look like the one in this book, position them as shown
in Figure 25-9.
Now it is time to wire the components together. To do this, you will position
the mouse pointer over one of the connection handles, then drag a “wire” from the
connection handle on one component to a connection handle on another component.
The component at which you start is the source of some event and the component at
which you end is the recipient of the event. Each component has four connection
C h a p t e r 2 5 : J a v a B e a n s 915
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Figure 25-9. The design window after added the slider and scroll bar
handles, and it doesn’t matter which one you choose. Begin by wiring a connection
from the slider to the scroll bar, as shown in Figure 25-10.
After you have completed the connection, the Interaction Wizard will appear. It
lets you specify how the two components communicate. In this case, you will define
what takes place when the slider is moved. On the first page you will select the event
method that will be called when the source object (in this case, the slider) changes
position. First, select the Event Adapter radio button (if it is not already selected).
916 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 25-10. Wiring a connection from the slider to the scroll bar
Then, select change in the Event Sets list. In Event Methods, stateChanged(ChangeEvent)
should already be selected. Your screen will look like Figure 25-11.
Press Next. You will now select the method on the target object (in this case, the
scroll bar) that you want called when the source object changes. In this case, select
the JScrollbar method setValue(int). It sets the current position of the scroll bar.
Your screen will look like Figure 25-12.
C h a p t e r 2 5 : J a v a B e a n s 917
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Figure 25-11. The first page of the Interaction Wizard
Press Next. Now, select the “getter” method that will supply the argument to
setValue( ). In this case, it will be JSlider’s getValue( ) method, which returns the
current position of the slider. A “getter” is a method that uses the get design pattern.
Your screen will look like Figure 25-13. Now, press finish. This completes the connection.
Now, each time the slider changes, the setValue( ) method of the scroll bar is called
with an argument supplied by the getValue( ) method of the slider. Thus, moving the
slider also causes the scroll bar to move.
918 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 25-12. The second page of the Interaction Wizard
Next, repeat this process, except this time, wire the connection from the scroll bar
to the slider box.
Finally, test the application. To do this, uncheck the Design Mode check box. This
causes the application to execute, as shown in Figure 25-14. Try moving the slider
box. When it moves, the scroll bar automatically moves, too. This is because of the
connection that we wired from the slider to the scroll bar. Assuming that you also
wired the reverse connection, moving the scroll bar will cause the slider to move.
C h a p t e r 2 5 : J a v a B e a n s 919
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Figure 25-13. The third page of the Interaction Wizard.
You can save your application by selecting Save in the file menu.
The Bean Builder is a powerful, yet easy to use development tool. If Bean
development is in your future, you will want to master its features. The best way
to do this is to create a number of sample Bean applications. Also, try creating your
own Beans and loading them into the palette. (To do so, create a JAR file containing
your Beans, as described earlier.)
920 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 25-14. The Bean Builder application executing
Chapter 26
A Tour of Swing
921
922 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
In Part II, you saw how to build user interfaces with the AWT classes. Here, we willtake a tour of a supercharged alternative called Swing.  Swing is a set of classes thatprovides more powerful and flexible components than are possible with the AWT.
In addition to the familiar components, such as buttons, check boxes, and labels, Swing
supplies several exciting additions, including tabbed panes, scroll panes, trees, and
tables. Even familiar components such as buttons have more capabilities in Swing. For
example, a button may have both an image and a text string associated with it. Also,
the image can be changed as the state of the button changes.
Unlike AWT components, Swing components are not implemented by
platform-specific code. Instead, they are written entirely in Java and, therefore, are
platform-independent. The term lightweight is used to describe such elements.
The number of classes and interfaces in the Swing packages is substantial, and this
chapter provides an overview of just a few. Swing is an area that you will want to
explore further on your own.
The Swing component classes that are used in this book are shown here:
Class Description
AbstractButton Abstract superclass for Swing buttons.
ButtonGroup Encapsulates a mutually exclusive set of buttons.
ImageIcon Encapsulates an icon.
JApplet The Swing version of Applet.
JButton The Swing push button class.
JCheckBox The Swing check box class.
JComboBox Encapsulates a combo box (an combination of a
drop-down list and text field).
JLabel The Swing version of a label.
JRadioButton The Swing version of a radio button.
JScrollPane Encapsulates a scrollable window.
JTabbedPane Encapsulates a tabbed window.
JTable Encapsulates a table-based control.
JTextField The Swing version of a text field.
JTree Encapsulates a tree-based control.
C h a p t e r 2 6 : A T o u r o f S w i n g 923
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
The Swing-related classes are contained in javax.swing and its subpackages, such
as javax.swing.tree. Many other Swing-related classes and interfaces exist that are not
examined in this chapter.
The remainder of this chapter examines various Swing components and illustrates
them through sample applets.
JApplet
Fundamental to Swing is the JApplet class, which extends Applet. Applets that use
Swing must be subclasses of JApplet. JApplet is rich with functionality that is not
found in Applet. For example, JApplet supports various “panes,” such as the content
pane, the glass pane, and the root pane. For the examples in this chapter, we will not be
using most of JApplet’s enhanced features. However, one difference between Applet
and JApplet is important to this discussion, because it is used by the sample applets in
this chapter. When adding a component to an instance of JApplet, do not invoke the
add( ) method of the applet. Instead, call add( ) for the content pane of the JApplet
object. The content pane can be obtained via the method shown here:
Container getContentPane( )
The add( ) method of Container can be used to add a component to a content pane.
Its form is shown here:
void add(comp)
Here, comp is the component to be added to the content pane.
Icons and Labels
In Swing, icons are encapsulated by the ImageIcon class, which paints an icon from an
image. Two of its constructors are shown here:
ImageIcon(String filename)
ImageIcon(URL url)
The first form uses the image in the file named filename. The second form uses the
image in the resource identified by url.
The ImageIcon class implements the Icon interface that declares the methods
shown here:
Method Description
int getIconHeight( ) Returns the height of the icon
in pixels.
int getIconWidth( ) Returns the width of the icon
in pixels.
void paintIcon(Component comp, Graphics g,
int x, int y)
Paints the icon at position x, y on
the graphics context g. Additional
information about the paint
operation can be provided in comp.
Swing labels are instances of the JLabel class, which extends JComponent. It can
display text and/or an icon. Some of its constructors are shown here:
JLabel(Icon i)
Label(String s)
JLabel(String s, Icon i, int align)
Here, s and i are the text and icon used for the label. The align argument is either LEFT,
RIGHT, CENTER, LEADING, or TRAILING. These constants are defined in the
SwingConstants interface, along with several others used by the Swing classes.
The icon and text associated with the label can be read and written by the
following methods:
Icon getIcon( )
String getText( )
void setIcon(Icon i)
void setText(String s)
Here, i and s are the icon and text, respectively.
The following example illustrates how to create and display a label containing both
an icon and a string. The applet begins by getting its content pane. Next, an ImageIcon
object is created for the file france.gif. This is used as the second argument to the
JLabel constructor. The first and last arguments for the JLabel constructor are the label
text and the alignment. Finally, the label is added to the content pane.
import java.awt.*;
import javax.swing.*;
/*
924 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 6 : A T o u r o f S w i n g 925
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
<applet code="JLabelDemo" width=250 height=150>
</applet>
*/
public class JLabelDemo extends JApplet {
public void init() {
// Get content pane
Container contentPane = getContentPane();
// Create an icon
ImageIcon ii = new ImageIcon("france.gif");
// Create a label
JLabel jl = new JLabel("France", ii, JLabel.CENTER);
// Add label to the content pane
contentPane.add(jl);
}
}
Output from this applet is shown here:
Text Fields
The Swing text field is encapsulated by the JTextComponent class, which extends
JComponent. It provides functionality that is common to Swing text components. One
926 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
of its subclasses is JTextField, which allows you to edit one line of text. Some of its
constructors are shown here:
JTextField( )
JTextField(int cols)
JTextField(String s, int cols)
JTextField(String s)
Here, s is the string to be presented, and cols is the number of columns in the text field.
The following example illustrates how to create a text field. The applet begins by
getting its content pane, and then a flow layout is assigned as its layout manager. Next,
a JTextField object is created and is added to the content pane.
import java.awt.*;
import javax.swing.*;
/*
<applet code="JTextFieldDemo" width=300 height=50>
</applet>
*/
public class JTextFieldDemo extends JApplet {
JTextField jtf;
public void init() {
// Get content pane
Container contentPane = getContentPane();
contentPane.setLayout(new FlowLayout());
// Add text field to content pane
jtf = new JTextField(15);
contentPane.add(jtf);
}
}
Output from this applet is shown here:
Buttons
Swing buttons provide features that are not found in the Button class defined by the
AWT. For example, you can associate an icon with a Swing button. Swing buttons are
subclasses of the AbstractButton class, which extends JComponent. AbstractButton
contains many methods that allow you to control the behavior of buttons, check boxes,
and radio buttons. For example, you can define different icons that are displayed for
the component when it is disabled, pressed, or selected. Another icon can be used as a
rollover icon, which is displayed when the mouse is positioned over that component.
The following are the methods that control this behavior:
void setDisabledIcon(Icon di)
void setPressedIcon(Icon pi)
void setSelectedIcon(Icon si)
void setRolloverIcon(Icon ri)
Here, di, pi, si, and ri are the icons to be used for these different conditions.
The text associated with a button can be read and written via the following methods:
String getText( )
void setText(String s)
Here, s is the text to be associated with the button.
Concrete subclasses of AbstractButton generate action events when they are
pressed. Listeners register and unregister for these events via the methods shown here:
void addActionListener(ActionListener al)
void removeActionListener(ActionListener al)
Here, al is the action listener.
AbstractButton is a superclass for push buttons, check boxes, and radio buttons.
Each is examined next.
The JButton Class
The JButton class provides the functionality of a push button. JButton allows an icon,
a string, or both to be associated with the push button. Some of its constructors are
shown here:
JButton(Icon i)
JButton(String s)
JButton(String s, Icon i)
Here, s and i are the string and icon used for the button.
The following example displays four push buttons and a text field. Each button
displays an icon that represents the flag of a country. When a button is pressed, the
C h a p t e r 2 6 : A T o u r o f S w i n g 927
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
928 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
name of that country is displayed in the text field. The applet begins by getting its
content pane and setting the layout manager of that pane. Four image buttons are
created and added to the content pane. Next, the applet is registered to receive action
events that are generated by the buttons. A text field is then created and added to the
applet. Finally, a handler for action events displays the command string that is
associated with the button. The text field is used to present this string.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JButtonDemo" width=250 height=300>
</applet>
*/
public class JButtonDemo extends JApplet
implements ActionListener {
JTextField jtf;
public void init() {
// Get content pane
Container contentPane = getContentPane();
contentPane.setLayout(new FlowLayout());
// Add buttons to content pane
ImageIcon france = new ImageIcon("france.gif");
JButton jb = new JButton(france);
jb.setActionCommand("France");
jb.addActionListener(this);
contentPane.add(jb);
ImageIcon germany = new ImageIcon("germany.gif");
jb = new JButton(germany);
jb.setActionCommand("Germany");
jb.addActionListener(this);
contentPane.add(jb);
ImageIcon italy = new ImageIcon("italy.gif");
jb = new JButton(italy);
jb.setActionCommand("Italy");
jb.addActionListener(this);
contentPane.add(jb);
ImageIcon japan = new ImageIcon("japan.gif");
jb = new JButton(japan);
jb.setActionCommand("Japan");
jb.addActionListener(this);
contentPane.add(jb);
// Add text field to content pane
jtf = new JTextField(15);
contentPane.add(jtf);
}
public void actionPerformed(ActionEvent ae) {
jtf.setText(ae.getActionCommand());
}
}
Output from this applet is shown here:
C h a p t e r 2 6 : A T o u r o f S w i n g 929
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
930 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Check Boxes
The JCheckBox class, which provides the functionality of a check box, is a concrete
implementation of AbstractButton. Its immediate superclass is JToggleButton, which
provides support for two-state buttons. Some of its constructors are shown here:
JCheckBox(Icon i)
JCheckBox(Icon i, boolean state)
JCheckBox(String s)
JCheckBox(String s, boolean state)
JCheckBox(String s, Icon i)
JCheckBox(String s, Icon i, boolean state)
Here, i is the icon for the button. The text is specified by s. If state is true, the check box
is initially selected. Otherwise, it is not.
The state of the check box can be changed via the following method:
void setSelected(boolean state)
Here, state is true if the check box should be checked.
The following example illustrates how to create an applet that displays four check
boxes and a text field. When a check box is pressed, its text is displayed in the text field.
The content pane for the JApplet object is obtained, and a flow layout is assigned as its
layout manager. Next, four check boxes are added to the content pane, and icons are
assigned for the normal, rollover, and selected states. The applet is then registered to
receive item events. Finally, a text field is added to the content pane.
When a check box is selected or deselected, an item event is generated. This is
handled by itemStateChanged( ). Inside itemStateChanged( ), the getItem( ) method
gets the JCheckBox object that generated the event. The getText( ) method gets the text
for that check box and uses it to set the text inside the text field.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JCheckBoxDemo" width=400 height=50>
</applet>
*/
public class JCheckBoxDemo extends JApplet
implements ItemListener {
JTextField jtf;
public void init() {
C h a p t e r 2 6 : A T o u r o f S w i n g 931
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
// Get content pane
Container contentPane = getContentPane();
contentPane.setLayout(new FlowLayout());
// Create icons
ImageIcon normal = new ImageIcon("normal.gif");
ImageIcon rollover = new ImageIcon("rollover.gif");
ImageIcon selected = new ImageIcon("selected.gif");
// Add check boxes to the content pane
JCheckBox cb = new JCheckBox("C", normal);
cb.setRolloverIcon(rollover);
cb.setSelectedIcon(selected);
cb.addItemListener(this);
contentPane.add(cb);
cb = new JCheckBox("C++", normal);
cb.setRolloverIcon(rollover);
cb.setSelectedIcon(selected);
cb.addItemListener(this);
contentPane.add(cb);
cb = new JCheckBox("Java", normal);
cb.setRolloverIcon(rollover);
cb.setSelectedIcon(selected);
cb.addItemListener(this);
contentPane.add(cb);
cb = new JCheckBox("Perl", normal);
cb.setRolloverIcon(rollover);
cb.setSelectedIcon(selected);
cb.addItemListener(this);
contentPane.add(cb);
// Add text field to the content pane
jtf = new JTextField(15);
contentPane.add(jtf);
}
public void itemStateChanged(ItemEvent ie) {
JCheckBox cb = (JCheckBox)ie.getItem();
jtf.setText(cb.getText());
}
}
Output from this applet is shown here:
Radio Buttons
Radio buttons are supported by the JRadioButton class, which is a concrete
implementation of AbstractButton. Its immediate superclass is JToggleButton, which
provides support for two-state buttons. Some of its constructors are shown here:
JRadioButton(Icon i)
JRadioButton(Icon i, boolean state)
JRadioButton(String s)
JRadioButton(String s, boolean state)
JRadioButton(String s, Icon i)
JRadioButton(String s, Icon i, boolean state)
Here, i is the icon for the button. The text is specified by s. If state is true, the button is
initially selected. Otherwise, it is not.
Radio buttons must be configured into a group. Only one of the buttons in that
group can be selected at any time. For example, if a user presses a radio button that is
in a group, any previously selected button in that group is automatically deselected.
The ButtonGroup class is instantiated to create a button group. Its default constructor
is invoked for this purpose. Elements are then added to the button group via the
following method:
void add(AbstractButton ab)
Here, ab is a reference to the button to be added to the group.
The following example illustrates how to use radio buttons. Three radio buttons
and one text field are created. When a radio button is pressed, its text is displayed in
the text field. First, the content pane for the JApplet object is obtained and a flow
layout is assigned as its layout manager. Next, three radio buttons are added to the
content pane. Then, a button group is defined and the buttons are added to it. Finally,
a text field is added to the content pane.
Radio button presses generate action events that are handled by actionPerformed( ).
The getActionCommand( ) method gets the text that is associated with a radio button
and uses it to set the text field.
932 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JRadioButtonDemo" width=300 height=50>
</applet>
*/
public class JRadioButtonDemo extends JApplet
implements ActionListener {
JTextField tf;
public void init() {
// Get content pane
Container contentPane = getContentPane();
contentPane.setLayout(new FlowLayout());
// Add radio buttons to content pane
JRadioButton b1 = new JRadioButton("A");
b1.addActionListener(this);
contentPane.add(b1);
JRadioButton b2 = new JRadioButton("B");
b2.addActionListener(this);
contentPane.add(b2);
JRadioButton b3 = new JRadioButton("C");
b3.addActionListener(this);
contentPane.add(b3);
// Define a button group
ButtonGroup bg = new ButtonGroup();
bg.add(b1);
bg.add(b2);
bg.add(b3);
// Create a text field and add it
// to the content pane
tf = new JTextField(5);
contentPane.add(tf);
}
C h a p t e r 2 6 : A T o u r o f S w i n g 933
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
934 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public void actionPerformed(ActionEvent ae) {
tf.setText(ae.getActionCommand());
}
}
Output from this applet is shown here:
Combo Boxes
Swing provides a combo box (a combination of a text field and a drop-down list)
through the JComboBox class, which extends JComponent. A combo box normally
displays one entry. However, it can also display a drop-down list that allows a user to
select a different entry. You can also type your selection into the text field. Two of
JComboBox’s constructors are shown here:
JComboBox( )
JComboBox(Vector v)
Here, v is a vector that initializes the combo box.
Items are added to the list of choices via the addItem( ) method, whose signature is
shown here:
void addItem(Object obj)
Here, obj is the object to be added to the combo box.
The following example contains a combo box and a label. The label displays an
icon. The combo box contains entries for “France”, “Germany”, “Italy”, and “Japan”.
When a country is selected, the label is updated to display the flag for that country.
C h a p t e r 2 6 : A T o u r o f S w i n g 935
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JComboBoxDemo" width=300 height=100>
</applet>
*/
public class JComboBoxDemo extends JApplet
implements ItemListener {
JLabel jl;
ImageIcon france, germany, italy, japan;
public void init() {
// Get content pane
Container contentPane = getContentPane();
contentPane.setLayout(new FlowLayout());
// Create a combo box and add it
// to the panel
JComboBox jc = new JComboBox();
jc.addItem("France");
jc.addItem("Germany");
jc.addItem("Italy");
jc.addItem("Japan");
jc.addItemListener(this);
contentPane.add(jc);
// Create label
jl = new JLabel(new ImageIcon("france.gif"));
contentPane.add(jl);
}
public void itemStateChanged(ItemEvent ie) {
String s = (String)ie.getItem();
jl.setIcon(new ImageIcon(s + ".gif"));
}
}
936 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Output from this applet is shown here:
Tabbed Panes
A tabbed pane is a component that appears as a group of folders in a file cabinet. Each
folder has a title. When a user selects a folder, its contents become visible. Only one of
the folders may be selected at a time. Tabbed panes are commonly used for setting
configuration options.
Tabbed panes are encapsulated by the JTabbedPane class, which extends
JComponent. We will use its default constructor. Tabs are defined via the following
method:
void addTab(String str, Component comp)
Here, str is the title for the tab, and comp is the component that should be added to the
tab. Typically, a JPanel or a subclass of it is added.
The general procedure to use a tabbed pane in an applet is outlined here:
1. Create a JTabbedPane object.
2. Call addTab( ) to add a tab to the pane. (The arguments to this method define
the title of the tab and the component it contains.)
3. Repeat step 2 for each tab.
4. Add the tabbed pane to the content pane of the applet.
The following example illustrates how to create a tabbed pane. The first tab is titled
“Cities” and contains four buttons. Each button displays the name of a city. The second
tab is titled “Colors” and contains three check boxes. Each check box displays the name
of a color. The third tab is titled “Flavors” and contains one combo box. This enables
the user to select one of three flavors.
C h a p t e r 2 6 : A T o u r o f S w i n g 937
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
import javax.swing.*;
/*
<applet code="JTabbedPaneDemo" width=400 height=100>
</applet>
*/
public class JTabbedPaneDemo extends JApplet {
public void init() {
JTabbedPane jtp = new JTabbedPane();
jtp.addTab("Cities", new CitiesPanel());
jtp.addTab("Colors", new ColorsPanel());
jtp.addTab("Flavors", new FlavorsPanel());
getContentPane().add(jtp);
}
}
class CitiesPanel extends JPanel {
public CitiesPanel() {
JButton b1 = new JButton("New York");
add(b1);
JButton b2 = new JButton("London");
add(b2);
JButton b3 = new JButton("Hong Kong");
add(b3);
JButton b4 = new JButton("Tokyo");
add(b4);
}
}
class ColorsPanel extends JPanel {
public ColorsPanel() {
JCheckBox cb1 = new JCheckBox("Red");
add(cb1);
JCheckBox cb2 = new JCheckBox("Green");
add(cb2);
JCheckBox cb3 = new JCheckBox("Blue");
add(cb3);
}
}
class FlavorsPanel extends JPanel {
public FlavorsPanel() {
JComboBox jcb = new JComboBox();
jcb.addItem("Vanilla");
jcb.addItem("Chocolate");
jcb.addItem("Strawberry");
add(jcb);
}
}
Output from this applet is shown in the following three illustrations:
938 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Scroll Panes
A scroll pane is a component that presents a rectangular area in which a component
may be viewed. Horizontal and/or vertical scroll bars may be provided if necessary.
Scroll panes are implemented in Swing by the JScrollPane class, which extends
JComponent. Some of its constructors are shown here:
JScrollPane(Component comp)
JScrollPane(int vsb, int hsb)
JScrollPane(Component comp, int vsb, int hsb)
Here, comp is the component to be added to the scroll pane. vsb and hsb are int
constants that define when vertical and horizontal scroll bars for this scroll pane are
shown. These constants are defined by the ScrollPaneConstants interface. Some
examples of these constants are described as follows:
Constant Description
HORIZONTAL_SCROLLBAR_ALWAYS Always provide horizontal
scroll bar
HORIZONTAL_SCROLLBAR_AS_NEEDED Provide horizontal scroll bar,
if needed
VERTICAL_SCROLLBAR_ALWAYS Always provide vertical
scroll bar
VERTICAL_SCROLLBAR_AS_NEEDED Provide vertical scroll bar,
if needed
Here are the steps that you should follow to use a scroll pane in an applet:
1. Create a JComponent object.
2. Create a JScrollPane object. (The arguments to the constructor specify the
component and the policies for vertical and horizontal scroll bars.)
3. Add the scroll pane to the content pane of the applet.
C h a p t e r 2 6 : A T o u r o f S w i n g 939
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
The following example illustrates a scroll pane. First, the content pane of the
JApplet object is obtained and a border layout is assigned as its layout manager. Next,
a JPanel object is created and four hundred buttons are added to it, arranged into
twenty columns. The panel is then added to a scroll pane, and the scroll pane is added
to the content pane. This causes vertical and horizontal scroll bars to appear. You can
use the scroll bars to scroll the buttons into view.
import java.awt.*;
import javax.swing.*;
/*
<applet code="JScrollPaneDemo" width=300 height=250>
</applet>
*/
public class JScrollPaneDemo extends JApplet {
public void init() {
// Get content pane
Container contentPane = getContentPane();
contentPane.setLayout(new BorderLayout());
// Add 400 buttons to a panel
JPanel jp = new JPanel();
jp.setLayout(new GridLayout(20, 20));
int b = 0;
for(int i = 0; i < 20; i++) {
for(int j = 0; j < 20; j++) {
jp.add(new JButton("Button " + b));
++b;
}
}
// Add panel to a scroll pane
int v = ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED;
int h = ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED;
JScrollPane jsp = new JScrollPane(jp, v, h);
// Add scroll pane to the content pane
contentPane.add(jsp, BorderLayout.CENTER);
}
}
940 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 6 : A T o u r o f S w i n g 941
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Output from this applet is shown here:
Trees
A tree is a component that presents a hierarchical view of data. A user has the ability to
expand or collapse individual subtrees in this display. Trees are implemented in Swing
by the JTree class, which extends JComponent. Some of its constructors are shown here:
JTree(Hashtable ht)
JTree(Object obj[ ])
JTree(TreeNode tn)
JTree(Vector v)
The first form creates a tree in which each element of the hash table ht is a child node.
Each element of the array obj is a child node in the second form. The tree node tn is the
root of the tree in the third form. Finally, the last form uses the elements of vector v as
child nodes.
A JTree object generates events when a node is expanded or collapsed. The
addTreeExpansionListener( ) and removeTreeExpansionListener( ) methods allow
listeners to register and unregister for these notifications. The signatures of these
methods are shown here:
void addTreeExpansionListener(TreeExpansionListener tel)
void removeTreeExpansionListener(TreeExpansionListener tel)
942 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Here, tel is the listener object.
The getPathForLocation( ) method is used to translate a mouse click on a specific
point of the tree to a tree path. Its signature is shown here:
TreePath getPathForLocation(int x, int y)
Here, x and y are the coordinates at which the mouse is clicked. The return value is a
TreePath object that encapsulates information about the tree node that was selected by
the user.
The TreePath class encapsulates information about a path to a particular node in a
tree. It provides several constructors and methods. In this book, only the toString( )
method is used. It returns a string equivalent of the tree path.
The TreeNode interface declares methods that obtain information about a tree
node. For example, it is possible to obtain a reference to the parent node or an
enumeration of the child nodes. The MutableTreeNode interface extends TreeNode. It
declares methods that can insert and remove child nodes or change the parent node.
The DefaultMutableTreeNode class implements the MutableTreeNode interface.
It represents a node in a tree. One of its constructors is shown here:
DefaultMutableTreeNode(Object obj)
Here, obj is the object to be enclosed in this tree node. The new tree node doesn’t have a
parent or children.
To create a hierarchy of tree nodes, the add( ) method of DefaultMutableTreeNode
can be used. Its signature is shown here:
void add(MutableTreeNode child)
Here, child is a mutable tree node that is to be added as a child to the current node.
Tree expansion events are described by the class TreeExpansionEvent in the
javax.swing.event package. The getPath( ) method of this class returns a TreePath
object that describes the path to the changed node. Its signature is shown here:
TreePath getPath( )
The TreeExpansionListener interface provides the following two methods:
void treeCollapsed(TreeExpansionEvent tee)
void treeExpanded(TreeExpansionEvent tee)
Here, tee is the tree expansion event. The first method is called when a subtree is
hidden, and the second method is called when a subtree becomes visible.
Here are the steps that you should follow to use a tree in an applet:
C h a p t e r 2 6 : A T o u r o f S w i n g 943
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
1. Create a JTree object.
2. Create a JScrollPane object. (The arguments to the constructor specify the tree
and the policies for vertical and horizontal scroll bars.)
3. Add the tree to the scroll pane.
4. Add the scroll pane to the content pane of the applet.
The following example illustrates how to create a tree and recognize mouse clicks on
it. The init( ) method gets the content pane for the applet. A DefaultMutableTreeNode
object labeled “Options” is created. This is the top node of the tree hierarchy. Additional
tree nodes are then created, and the add( ) method is called to connect these nodes to
the tree. A reference to the top node in the tree is provided as the argument to the
JTree constructor. The tree is then provided as the argument to the JScrollPane
constructor. This scroll pane is then added to the applet. Next, a text field is created
and added to the applet. Information about mouse click events is presented in this text
field. To receive mouse events from the tree, the addMouseListener( ) method of the
JTree object is called. The argument to this method is an anonymous inner class that
extends MouseAdapter and overrides the mouseClicked( ) method.
The doMouseClicked( ) method processes mouse clicks. It calls
getPathForLocation( ) to translate the coordinates of the mouse click into a TreePath
object. If the mouse is clicked at a point that does not cause a node selection, the return
value from this method is null. Otherwise, the tree path can be converted to a string
and presented in the text field.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.tree.*;
/*
<applet code="JTreeEvents" width=400 height=200>
</applet>
*/
public class JTreeEvents extends JApplet {
JTree tree;
JTextField jtf;
public void init() {
944 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
// Get content pane
Container contentPane = getContentPane();
// Set layout manager
contentPane.setLayout(new BorderLayout());
// Create top node of tree
DefaultMutableTreeNode top = new DefaultMutableTreeNode("Options");
// Create subtree of "A"
DefaultMutableTreeNode a = new DefaultMutableTreeNode("A");
top.add(a);
DefaultMutableTreeNode a1 = new DefaultMutableTreeNode("A1");
a.add(a1);
DefaultMutableTreeNode a2 = new DefaultMutableTreeNode("A2");
a.add(a2);
// Create subtree of "B"
DefaultMutableTreeNode b = new DefaultMutableTreeNode("B");
top.add(b);
DefaultMutableTreeNode b1 = new DefaultMutableTreeNode("B1");
b.add(b1);
DefaultMutableTreeNode b2 = new DefaultMutableTreeNode("B2");
b.add(b2);
DefaultMutableTreeNode b3 = new DefaultMutableTreeNode("B3");
b.add(b3);
// Create tree
tree = new JTree(top);
// Add tree to a scroll pane
int v = ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED;
int h = ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED;
JScrollPane jsp = new JScrollPane(tree, v, h);
// Add scroll pane to the content pane
contentPane.add(jsp, BorderLayout.CENTER);
C h a p t e r 2 6 : A T o u r o f S w i n g 945
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
// Add text field to applet
jtf = new JTextField("", 20);
contentPane.add(jtf, BorderLayout.SOUTH);
// Anonymous inner class to handle mouse clicks
tree.addMouseListener(new MouseAdapter() {
public void mouseClicked(MouseEvent me) {
doMouseClicked(me);
}
});
}
void doMouseClicked(MouseEvent me) {
TreePath tp = tree.getPathForLocation(me.getX(), me.getY());
if(tp != null)
jtf.setText(tp.toString());
else
jtf.setText("");
}
}
Output from this applet is shown here:
946 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The string presented in the text field describes the path from the top tree node to the
selected node.
Tables
A table is a component that displays rows and columns of data. You can drag the
cursor on column boundaries to resize columns. You can also drag a column to a new
position. Tables are implemented by the JTable class, which extends JComponent.
One of its constructors is shown here:
JTable(Object data[ ][ ], Object colHeads[ ])
Here, data is a two-dimensional array of the information to be presented, and colHeads
is a one-dimensional array with the column headings.
Here are the steps for using a table in an applet:
1. Create a JTable object.
2. Create a JScrollPane object. (The arguments to the constructor specify the table
and the policies for vertical and horizontal scroll bars.)
3. Add the table to the scroll pane.
4. Add the scroll pane to the content pane of the applet.
The following example illustrates how to create and use a table. The content pane
of the JApplet object is obtained and a border layout is assigned as its layout manager.
A one-dimensional array of strings is created for the column headings. This table has
three columns. A two-dimensional array of strings is created for the table cells. You can
see that each element in the array is an array of three strings. These arrays are passed to
the JTable constructor. The table is added to a scroll pane and then the scroll pane is
added to the content pane.
import java.awt.*;
import javax.swing.*;
/*
<applet code="JTableDemo" width=400 height=200>
</applet>
*/
public class JTableDemo extends JApplet {
C h a p t e r 2 6 : A T o u r o f S w i n g 947
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
public void init() {
// Get content pane
Container contentPane = getContentPane();
// Set layout manager
contentPane.setLayout(new BorderLayout());
// Initialize column headings
final String[] colHeads = { "Name", "Phone", "Fax" };
// Initialize data
final Object[][] data = {
{ "Gail", "4567", "8675" },
{ "Ken", "7566", "5555" },
{ "Viviane", "5634", "5887" },
{ "Melanie", "7345", "9222" },
{ "Anne", "1237", "3333" },
{ "John", "5656", "3144" },
{ "Matt", "5672", "2176" },
{ "Claire", "6741", "4244" },
{ "Erwin", "9023", "5159" },
{ "Ellen", "1134", "5332" },
{ "Jennifer", "5689", "1212" },
{ "Ed", "9030", "1313" },
{ "Helen", "6751", "1415" }
};
// Create the table
JTable table = new JTable(data, colHeads);
// Add table to a scroll pane
int v = ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED;
int h = ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED;
JScrollPane jsp = new JScrollPane(table, v, h);
// Add scroll pane to the content pane
contentPane.add(jsp, BorderLayout.CENTER);
}
}
Output from this applet is shown here:
Exploring Swing
As mentioned earlier, Swing is a large system, and it has many features that you will
want to explore on your own. For example, Swing provides toolbars, tooltips, and
progress bars. Also, Swing components can provide a pluggable look and feel, which
means that it is easy to substitute another appearance and behavior for an element.
This can be done dynamically. You may even design your own look and feel. Frankly,
the Swing approach to GUI components might replace the AWT classes some time
in the future, so familiarizing yourself with it now is a good idea.
Swing is just one part of the Java Foundation Classes (JFC). You may want to
explore other JFC features. The Accessibility API can be used to build programs
that are usable by people with disabilities. The Java 2-D API provides advanced
capabilities for working with shapes, text, and images. The Drag-and-Drop API
allows information to be exchanged between Java and non-Java programs.
948 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Chapter 27
Servlets
949
This chapter presents an overview of servlets. Servlets are small programs thatexecute on the server side of a Web connection. Just as applets dynamically extendthe functionality of a Web browser, servlets dynamically extend the functionality
of a Web server. The topic of servlets is quite large, and it is beyond the scope of
this chapter to cover it all. Instead, we will focus on the core concepts, interfaces, and
classes, and develop several examples.
Background
In order to understand the advantages of servlets, you must have a basic understanding
of how Web browsers and servers cooperate to provide content to a user. Consider
a request for a static Web page. A user enters a Uniform Resource Locator (URL) into
a browser. The browser generates an HTTP request to the appropriate Web server.
The Web server maps this request to a specific file. That file is returned in an HTTP
response to the browser. The HTTP header in the response indicates the type of the
content. The Multipurpose Internet Mail Extensions (MIME) are used for this purpose.
For example, ordinary ASCII text has a MIME type of text/plain. The Hypertext
Markup Language (HTML) source code of a Web page has a MIME type of text/html.
Now consider dynamic content. Assume that an online store uses a database to
store information about its business. This would include items for sale, prices, availability,
orders, and so forth. It wishes to make this information accessible to customers via
Web pages. The contents of those Web pages must be dynamically generated in order
to reflect the latest information in the database.
In the early days of the Web, a server could dynamically construct a page by creating
a separate process to handle each client request. The process would open connections
to one or more databases in order to obtain the necessary information. It communicated
with the Web server via an interface known as the Common Gateway Interface (CGI).
CGI allowed the separate process to read data from the HTTP request and write data to
the HTTP response. A variety of different languages were used to build CGI programs.
These included C, C++, and Perl.
However, CGI suffered serious performance problems. It was expensive in terms
of processor and memory resources to create a separate process for each client request.
It was also expensive to open and close database connections for each client request.
In addition, the CGI programs were not platform-independent. Therefore, other
techniques were introduced. Among these are servlets.
Servlets offer several advantages in comparison with CGI. First, performance is
significantly better. Servlets execute within the address space of a Web server. It is
not necessary to create a separate process to handle each client request. Second, servlets
are platform-independent because they are written in Java. A number of Web servers
from different vendors offer the Servlet API. Programs developed for this API can be
moved to any of these environments without recompilation. Third, the Java security
manager on the server enforces a set of restrictions to protect the resources on a server
950 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
machine. You will see that some servlets are trusted and others are untrusted. Finally,
the full functionality of the Java class libraries is available to a servlet. It can communicate
with applets, databases, or other software via the sockets and RMI mechanisms that
you have seen already.
The Life Cycle of a Servlet
Three methods are central to the life cycle of a servlet. These are init( ), service( ),
and destroy( ). They are implemented by every servlet and are invoked at specific
times by the server. Let us consider a typical user scenario to understand when these
methods are called.
First, assume that a user enters a Uniform Resource Locator (URL) to a Web
browser. The browser then generates an HTTP request for this URL. This request is
then sent to the appropriate server.
Second, this HTTP request is received by the Web server. The server maps this
request to a particular servlet. The servlet is dynamically retrieved and loaded into
the address space of the server.
Third, the server invokes the init( ) method of the servlet. This method is invoked
only when the servlet is first loaded into memory. It is possible to pass initialization
parameters to the servlet so it may configure itself.
Fourth, the server invokes the service( ) method of the servlet. This method is
called to process the HTTP request. You will see that it is possible for the servlet to
read data that has been provided in the HTTP request. It may also formulate an
HTTP response for the client.
The servlet remains in the server’s address space and is available to process any
other HTTP requests received from clients. The service( ) method is called for each
HTTP request.
Finally, the server may decide to unload the servlet from its memory. The algorithms
by which this determination is made are specific to each server. The server calls the
destroy( ) method to relinquish any resources such as file handles that are allocated for
the servlet. Important data may be saved to a persistent store. The memory allocated
for the servlet and its objects can then be garbage collected.
Using Tomcat For Servlet Development
To create servlets, you will need to download a servlet development environment. The
one currently recommended by Sun is Tomcat 4.0, which supports the latest servlet
specification, which is 2.3. (The complete servlet specification is available for download
through java.sun.com.) Tomcat replaces the old JSDK (Java Servlet Development Kit)
that was previously provided by Sun. Tomcat is an open-source product maintained
by the Jakarta Project of the Apache Software Foundation. It contains the class libraries,
documentation, and run-time support that you will need to create and test servlets.
C h a p t e r 2 7 : S e r v l e t s 951
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
You can download Tomcat through the Sun Microsystems Web site at java.sun.com.
The current version is 4.0. Follow the instructions to install this toolkit on your
machine. The examples in this chapter assume a Windows environment. The default
location for Tomcat 4.0 is
C:\Program Files\Apache Tomcat 4.0\
This is the location assumed by the examples in this book. If you load Tomcat in a
different location, you will need to make appropriate changes to the examples. You may
need to set the environmental variable JAVA_HOME to the top-level directory in which
the Java Software Development Kit is installed. For Java 2, version 1.4, the default
directory is C:\j2sdk1.4.0, but you will need to confirm this for your environment.
To start Tomcat, select Start Tomcat in the Start | Programs menu, or run startup.bat
from the
C:\Program Files\Apache Tomcat 4.0\bin\
directory. When you are done testing servlets, you can stop Tomcat by selecting Stop
Tomcat in the Start | Programs menu, or run shutdown.bat.
The directory
C:\Program Files\Apache Tomcat 4.0\common\lib\
contains servlet.jar. This JAR file contains the classes and interfaces that are needed
to build servlets. To make this file accessible, update your CLASSPATH environment
variable so that it includes
C:\Program Files\Apache Tomcat 4.0\common\lib\servlet.jar.
Alternatively, you can specify this class file when you compile the servlets. For
example, the following command compiles the first servlet example:
javac HelloServlet.java -classpath "C:\Program Files\Apache Tomcat
4.0\common\lib\servlet.jar"
Once you have compiled a servlet, you must copy the class file into the directory
that Tomcat uses for example servlet class files. For the purposes of this chapter, you
must put the servlet files into the following directory:
C:\Program Files\Apache Tomcat 4.0\webapps\examples\WEB-INF\classes
952 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
A Simple Servlet
To become familiar with the key servlet concepts, we will begin by building and testing
a simple servlet. The basic steps are the following:
1. Create and compile the servlet source code.
2. Start Tomcat.
3. Start a Web browser and request the servlet.
Let us examine each of these steps in detail.
Create and Compile the Servlet Source Code
To begin, create a file named HelloServlet.java that contains the following program:
import java.io.*;
import javax.servlet.*;
public class HelloServlet extends GenericServlet {
public void service(ServletRequest request,
ServletResponse response)
throws ServletException, IOException {
response.setContentType("text/html");
PrintWriter pw = response.getWriter();
pw.println("<B>Hello!");
pw.close();
}
}
Let’s look closely at this program. First, note that it imports the javax.servlet package.
This package contains the classes and interfaces required to build servlets. You will learn
more about these later in this chapter. Next, the program defines HelloServlet as a subclass
of GenericServlet. The GenericServlet class provides functionality that makes it easy to
handle requests and responses.
Inside HelloServet, the service( ) method (which is inherited from GenericServlet)
is overridden. This method handles requests from a client. Notice that the first argument
is a ServletRequest object. This enables the servlet to read data that is provided via
the client request. The second argument is a ServletResponse object. This enables the
servlet to formulate a response for the client.
The call to setContentType( ) establishes the MIME type of the HTTP response.
In this program, the MIME type is text/html. This indicates that the browser should
interpret the content as HTML source code.
C h a p t e r 2 7 : S e r v l e t s 953
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Next, the getWriter( ) method obtains a PrintWriter. Anything written to this stream
is sent to the client as part of the HTTP response. Then println( ) is used to write some
simple HTML source code as the HTTP response.
Compile this source code and place the HelloServlet.class file in the Tomcat class
files directory as described in the previous section.
Start Tomcat
As explained, to start Tomcat, select Start Tomcat in the Start | Programs menu, or run
startup.bat from the
C:\Program Files\Apache Tomcat 4.0\bin\
directory.
Start a Web Browser and Request the Servlet
Start a Web browser and enter the URL shown here:
http://localhost:8080/examples/servlet/HelloServlet
Alternatively, you may enter the URL shown here:
http://127.0.0.1:8080/examples/servlet/HelloServlet
This can be done because 127.0.0.1 is defined as the IP address of the local machine.
You will observe the output of the servlet in the browser display area. It will
contain the string Hello! in bold type.
The Servlet API
Two packages contain the classes and interfaces that are required to build servlets. These
are javax.servlet and javax.servlet.http. They constitute the Servlet API. Keep in mind
that these packages are not part of the Java core packages. Instead, they are standard
extensions. Therefore, they are not included in the Java Software Development Kit. You
must download Tomcat to obtain their functionality.
The Servlet API has been in a process of ongoing development and enhancement.
The current servlet specification is version is 2.3 and that is the one used in this book.
However, because changes happen fast in the world of Java, you will want to check for
any additions or alterations. This chapter discusses the core of the Servlet API, which
will be available to most readers.
The Servlet API is supported by most Web servers, such as those from Sun,
Microsoft, and others. Check at http://java.sun.com for the latest information.
954 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The javax.servlet Package
The javax.servlet package contains a number of interfaces and classes that establish
the framework in which servlets operate. The following table summarizes the core
interfaces that are provided in this package. The most significant of these is Servlet. All
servlets must implement this interface or extend a class that implements the interface.
The ServletRequest and ServletResponse interfaces are also very important.
Interface Description
Servlet Declares life cycle methods for a servlet.
ServletConfig Allows servlets to get initialization parameters.
ServletContext Enables servlets to log events and access information
about their environment.
ServletRequest Used to read data from a client request.
ServletResponse Used to write data to a client response.
SingleThreadModel Indicates that the servlet is thread safe.
The following table summarizes the core classes that are provided in the
javax.servlet package.
Class Description
GenericServlet Implements the Servlet and ServletConfig
interfaces.
ServletInputStream Provides an input stream for reading requests from
a client.
ServletOutputStream Provides an output stream for writing responses to
a client.
ServletException Indicates a servlet error occurred.
UnavailableException Indicates a servlet is unavailable.
Let us examine these interfaces and classes in more detail.
The Servlet Interface
All servlets must implement the Servlet interface. It declares the init( ), service( ), and
destroy( ) methods that are called by the server during the life cycle of a servlet. A
method is also provided that allows a servlet to obtain any initialization parameters.
The methods defined by Servlet are shown in Table 27-1.
C h a p t e r 2 7 : S e r v l e t s 955
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
The init( ), service( ), and destroy( ) methods are the life cycle methods of the
servlet. These are invoked by the server. The getServletConfig( ) method is called by
the servlet to obtain initialization parameters. A servlet developer overrides the
getServletInfo( ) method to provide a string with useful information (for example,
author, version, date, copyright). This method is also invoked by the server.
The ServletConfig Interface
The ServletConfig interface is implemented by the server. It allows a servlet to obtain
configuration data when it is loaded. The methods declared by this interface are
summarized here:
Method Description
ServletContext getServletContext( ) Returns the context for this servlet.
String getInitParameter(String param) Returns the value of the initialization
parameter named param.
Enumeration getInitParameterNames( ) Returns an enumeration of all
initialization parameter names.
String getServletName( ) Returns the name of the invoking servlet.
956 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Method Description
void destroy( ) Called when the servlet is unloaded.
ServletConfig getServletConfig( ) Returns a ServletConfig object that contains
any initialization parameters.
String getServletInfo( ) Returns a string describing the servlet.
void init(ServletConfig sc)
throws ServletException
Called when the servlet is initialized.
Initialization parameters for the servlet can be
obtained from sc. An UnavailableException
should be thrown if the servlet cannot be
initialized.
void service(ServletRequest req,
ServletResponse res)
throws ServletException,
IOException
Called to process a request from a client. The
request from the client can be read from req.
The response to the client can be written to
res. An exception is generated if a servlet or
IO problem occurs.
Table 27-1. The Methods Defined by Servlet
The ServletContext Interface
The ServletContext interface is implemented by the server. It enables servlets to obtain
information about their environment. Several of its methods are summarized in Table 27-2.
The ServletRequest Interface
The ServletRequest interface is implemented by the server. It enables a servlet to
obtain information about a client request. Several of its methods are summarized in
Table 27-3.
The ServletResponse Interface
The ServletResponse interface is implemented by the server. It enables a servlet to
formulate a response for a client. Several of its methods are summarized in Table 27-4.
The SingleThreadModel Interface
This interface is used to indicate that only a single thread will execute the service( )
method of a servlet at a given time. It defines no constants and declares no methods.
If a servlet implements this interface, the server has two options. First, it can create
several instances of the servlet. When a client request arrives, it is sent to an available
instance of the servlet. Second, it can synchronize access to the servlet.
C h a p t e r 2 7 : S e r v l e t s 957
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Method Description
Object getAttribute(String attr) Returns the value of the server attribute
named attr.
String getMimeType(String file) Returns the MIME type of file.
String getRealPath(String vpath) Returns the real path that corresponds
to the virtual path vpath.
String getServerInfo( ) Returns information about the server.
void log(String s) Writes s to the servlet log.
void log(String s, Throwable e) Write s and the stack trace for e to the
servlet log.
void setAttribute(String attr, Object val) Sets the attribute specified by attr to the
value passed in val.
Table 27-2. Various Methods Defined by ServletContext
958 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Method Description
Object getAttribute(String attr) Returns the value of the attribute
named attr.
String getCharacterEncoding( ) Returns the character encoding of
the request.
int getContentLength( ) Returns the size of the request. The
value –1 is returned if the size is
unavailable.
String getContentType( ) Returns the type of the request. A
null value is returned if the type
cannot be determined.
ServletInputStream getInputStream( )
throws IOException
Returns a ServletInputStream
that can be used to read binary
data from the request. An
IllegalStateException is thrown
if getReader( ) has already been
invoked for this request.
String getParameter(String pname) Returns the value of the parameter
named pname.
Enumeration getParameterNames( ) Returns an enumeration of the
parameter names for this request.
String[ ] getParameterValues(String name ) Returns an array containing values
associated with the parameter
specified by name.
String getProtocol( ) Returns a description of the
protocol.
BufferedReader getReader( )
throws IOException
Returns a buffered reader that
can be used to read text from the
request. An IllegalStateException
is thrown if getInputStream( ) has
already been invoked for this
request.
Table 27-3. Various Methods Defined by ServletRequest
C h a p t e r 2 7 : S e r v l e t s 959
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Method Description
String getRemoteAddr( ) Returns the string equivalent of the
client IP address.
String getRemoteHost( ) Returns the string equivalent of the
client host name.
String getScheme( ) Returns the transmission scheme of
the URL used for the request (for
example, “http”, “ftp”).
String getServerName( ) Returns the name of the server.
int getServerPort( ) Returns the port number.
Table 27-3. Various Methods Defined by ServletRequest (continued)
Method Description
String getCharacterEncoding( ) Returns the character encoding for the
response.
ServletOutputStream
getOutputStream( )
throws IOException
Returns a ServletOutputStream that can be
used to write binary data to the response.
An IllegalStateException is thrown if
getWriter( ) has already been invoked for
this request.
PrintWriter getWriter( )
throws IOException
Returns a PrintWriter that can be used
to write character data to the response.
An IllegalStateException is thrown if
getOutputStream( ) has already been
invoked for this request.
void setContentLength(int size) Sets the content length for the response to size.
void setContentType(String type) Sets the content type for the response to type.
Table 27-4. Various Methods Defined by ServletResponse
The GenericServlet Class
The GenericServlet class provides implementations of the basic life cycle methods for
a servlet and is typically subclassed by servlet developers. GenericServlet implements
the Servlet and ServletConfig interfaces. In addition, a method to append a string to
the server log file is available. The signatures of this method are shown here:
void log(String s)
void log(String s, Throwable e)
Here, s is the string to be appended to the log, and e is an exception that occurred.
The ServletInputStream Class
The ServletInputStream class extends InputStream. It is implemented by the server
and provides an input stream that a servlet developer can use to read the data from a
client request. It defines the default constructor. In addition, a method is provided to
read bytes from the stream. Its signature is shown here:
int readLine(byte[ ] buffer, int offset, int size) throws IOException
Here, buffer is the array into which size bytes are placed starting at offset. The method
returns the actual number of bytes read or –1 if an end-of-stream condition is encountered.
The ServletOutputStream Class
The ServletOutputStream class extends OutputStream. It is implemented by the
server and provides an output stream that a servlet developer can use to write data
to a client response. A default constructor is defined. It also defines the print( ) and
println( ) methods, which output data to the stream.
The Servlet Exception Classes
javax.servlet defines two exceptions. The first is ServletException, which indicates that
a servlet problem has occurred. The second is UnavailableException, which extends
ServletException. It indicates that a servlet is unavailable.
Reading Servlet Parameters
The ServletRequest class includes methods that allow you to read the names and
values of parameters that are included in a client request. We will develop a servlet
that illustrates their use. The example contains two files. A Web page is defined in
PostParameters.htm and a servlet is defined in PostParametersServlet.java.
The HTML source code for PostParameters.htm is shown in the following listing. It
defines a table that contains two labels and two text fields. One of the labels is Employee
960 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
and the other is Phone. There is also a submit button. Notice that the action parameter
of the form tag specifies a URL. The URL identifies the servlet to process the HTTP
POST request.
<html>
<body>
<center>
<form name="Form1"
method="post"
action="http://localhost:8080/examples/servlet/PostParametersServlet">
<table>
<tr>
<td><B>Employee</td>
<td><input type=textbox name="e" size="25" value=""></td>
</tr>
<tr>
<td><B>Phone</td>
<td><input type=textbox name="p" size="25" value=""></td>
</tr>
</table>
<input type=submit value="Submit">
</body>
</html>
The source code for PostParametersServlet.java is shown in the following listing.
The service( ) method is overridden to process client requests. The getParameterNames( )
method returns an enumeration of the parameter names. These are processed in a loop.
You can see that the parameter name and value are output to the client. The parameter
value is obtained via the getParameter( ) method.
import java.io.*;
import java.util.*;
import javax.servlet.*;
public class PostParametersServlet
extends GenericServlet {
public void service(ServletRequest request,
ServletResponse response)
throws ServletException, IOException {
// Get print writer.
PrintWriter pw = response.getWriter();
C h a p t e r 2 7 : S e r v l e t s 961
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
// Get enumeration of parameter names.
Enumeration e = request.getParameterNames();
// Display parameter names and values.
while(e.hasMoreElements()) {
String pname = (String)e.nextElement();
pw.print(pname + " = ");
String pvalue = request.getParameter(pname);
pw.println(pvalue);
}
pw.close();
}
}
Compile the servlet and perform these steps to test this example:
1. Start Tomcat (if it is not already running).
2. Display the Web page in a browser.
3. Enter an employee name and phone number in the text fields.
4. Submit the Web page.
After following these steps, the browser will display a response that is dynamically
generated by the servlet.
The javax.servlet.http Package
The javax.servlet.http package contains a number of interfaces and classes that are
commonly used by servlet developers. You will see that its functionality makes it easy
to build servlets that work with HTTP requests and responses.
The following table summarizes the core interfaces that are provided in this package:
Interface Description
HttpServletRequest Enables servlets to read data from an HTTP request.
HttpServletResponse Enables servlets to write data to an HTTP response.
HttpSession Allows session data to be read and written.
HttpSessionBindingListener Informs an object that it is bound to or unbound
from a session.
962 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The following table summarizes the core classes that are provided in this package.
The most important of these is HttpServlet. Servlet developers typically extend this
class in order to process HTTP requests.
Class Description
Cookie Allows state information to be stored on a client
machine.
HttpServlet Provides methods to handle HTTP requests and
responses.
HttpSessionEvent Encapsulates a session-changed event.
HttpSessionBindingEvent Indicates when a listener is bound to or unbound
from a session value, or that a session attribute
changed.
The HttpServletRequest Interface
The HttpServletRequest interface is implemented by the server. It enables a servlet to
obtain information about a client request. Several of its methods are shown in Table 27-5.
C h a p t e r 2 7 : S e r v l e t s 963
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Method Description
String getAuthType( ) Returns authentication scheme.
Cookie[ ] getCookies( ) Returns an array of the cookies in this
request.
long getDateHeader(String field) Returns the value of the date header
field named field.
String getHeader(String field) Returns the value of the header field
named field.
Enumeration getHeaderNames( ) Returns an enumeration of the header
names.
int getIntHeader(String field) Returns the int equivalent of the header
field named field.
Table 27-5. Various Methods Defined by HttpServletRequest
964 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Method Description
String getMethod( ) Returns the HTTP method for this
request.
String getPathInfo( ) Returns any path information that is
located after the servlet path and before
a query string of the URL.
String getPathTranslated( ) Returns any path information that
is located after the servlet path and
before a query string of the URL after
translating it to a real path.
String getQueryString( ) Returns any query string in the URL.
String getRemoteUser( ) Returns the name of the user who
issued this request.
String getRequestedSessionId( ) Returns the ID of the session.
String getRequestURI( ) Returns the URI.
StringBuffer getRequestURL( ) Returns the URL.
String getServletPath( ) Returns that part of the URL that
identifies the servlet.
HttpSession getSession( ) Returns the session for this request.
If a session does not exist, one is created
and then returned.
HttpSession getSession(boolean new) If new is true and no session exists,
creates and returns a session for this
request. Otherwise, returns the existing
session for this request.
boolean
isRequestedSessionIdFromCookie( )
Returns true if a cookie contains the
session ID. Otherwise, returns false.
boolean
isRequestedSessionIdFromURL( )
Returns true if the URL contains the
session ID. Otherwise, returns false.
boolean isRequestedSessionIdValid( ) Returns true if the requested session ID
is valid in the current session context.
Table 27-5. Various Methods Defined by HttpServletRequest (continued)
The HttpServletResponse Interface
The HttpServletResponse interface is implemented by the server. It enables a servlet
to formulate an HTTP response to a client. Several constants are defined. These
correspond to the different status codes that can be assigned to an HTTP response. For
example, SC_OK indicates that the HTTP request succeeded and SC_NOT_FOUND
indicates that the requested resource is not available. Several methods of this interface
are summarized in Table 27-6.
C h a p t e r 2 7 : S e r v l e t s 965
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Method Description
void addCookie(Cookie cookie) Adds cookie to the HTTP response.
boolean containsHeader(String field) Returns true if the HTTP response
header contains a field named field.
String encodeURL(String url) Determines if the session ID must
be encoded in the URL identified
as url. If so, returns the modified
version of url. Otherwise, returns
url. All URLs generated by a
servlet should be processed by
this method.
String encodeRedirectURL(String url) Determines if the session ID
must be encoded in the URL
identified as url. If so, returns
the modified version of url.
Otherwise, returns url. All URLs
passed to sendRedirect( ) should
be processed by this method.
void sendError(int c)
throws IOException
Sends the error code c to the client.
void sendError(int c, String s)
throws IOException
Sends the error code c and message
s to the client.
void sendRedirect(String url)
throws IOException
Redirects the client to url.
Table 27-6. Various Methods Defined by HttpServletResponse
The HttpSession Interface
The HttpSession interface is implemented by the server. It enables a servlet to read and
write the state information that is associated with an HTTP session. Several of its methods
are summarized in Table 27-7. All of these methods throw an IllegalStateException if the
session has already been invalidated.
966 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Method Description
void setDateHeader(String field, long msec) Adds field to the header with date
value equal to msec (milliseconds
since midnight, January 1, 1970,
GMT).
void setHeader(String field, String value) Adds field to the header with value
equal to value.
void setIntHeader(String field, int value) Adds field to the header with value
equal to value.
void setStatus(int code) Sets the status code for this
response to code.
Table 27-6. Various Methods Defined by HttpServletResponse (continued)
Method Description
Object getAttribute(String attr) Returns the value associated with the
name passed in attr. Returns null if
attr is not found.
Enumeration getAttributeNames( ) Returns an enumeration of the attribute
names associated with the session.
long getCreationTime( ) Returns the time (in milliseconds since
midnight, January 1, 1970, GMT) when
this session was created.
String getId( ) Returns the session ID.
Table 27-7. The Methods Defined by HttpSession
The HttpSessionBindingListener Interface
The HttpSessionBindingListener interface is implemented by objects that need to be
notified when they are bound to or unbound from an HTTP session. The methods that
are invoked when an object is bound or unbound are
void valueBound(HttpSessionBindingEvent e)
void valueUnbound(HttpSessionBindingEvent e)
Here, e is the event object that describes the binding.
The Cookie Class
The Cookie class encapsulates a cookie. A cookie is stored on a client and contains state
information. Cookies are valuable for tracking user activities. For example, assume that
a user visits an online store. A cookie can save the user’s name, address, and other
information. The user does not need to enter this data each time he or she visits the store.
A servlet can write a cookie to a user’s machine via the addCookie( ) method of the
HttpServletResponse interface. The data for that cookie is then included in the header
of the HTTP response that is sent to the browser.
C h a p t e r 2 7 : S e r v l e t s 967
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Method Description
long getLastAccessedTime( ) Returns the time (in milliseconds since
midnight, January 1, 1970, GMT) when
the client last made a request for this
session.
void invalidate( ) Invalidates this session and removes it
from the context.
boolean isNew( ) Returns true if the server created the
session and it has not yet been
accessed by the client.
void removeAttribute(String attr) Removes the attribute specified by attr
from the session.
void setAttribute(String attr, Object val) Associates the value passed in val with
the attribute name passed in attr.
Table 27-7. The Methods Defined by HttpSession (continued)
The names and values of cookies are stored on the user’s machine. Some of the
information that is saved for each cookie includes the following:
■ The name of the cookie
■ The value of the cookie
■ The expiration date of the cookie
■ The domain and path of the cookie
The expiration date determines when this cookie is deleted from the user’s machine.
If an expiration date is not explicitly assigned to a cookie, it is deleted when the current
browser session ends. Otherwise, the cookie is saved in a file on the user’s machine.
The domain and path of the cookie determine when it is included in the header of
an HTTP request. If the user enters a URL whose domain and path match these values,
the cookie is then supplied to the Web server. Otherwise, it is not.
There is one constructor for Cookie. It has the signature shown here:
Cookie(String name, String value)
Here, the name and value of the cookie are supplied as arguments to the constructor.
The methods of the Cookie class are summarized in Table 27-8.
968 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Method Description
Object clone( ) Returns a copy of this object.
String getComment( ) Returns the comment.
String getDomain( ) Returns the domain.
int getMaxAge( ) Returns the age (in seconds).
String getName( ) Returns the name.
String getPath( ) Returns the path.
boolean getSecure( ) Returns true if the cookie must be sent using
only a secure protocol. Otherwise, returns false.
String getValue( ) Returns the value.
int getVersion( ) Returns the cookie protocol version. (Will be
0 or 1.)
Table 27-8. The Methods Defined by Cookie
The HttpServlet Class
The HttpServlet class extends GenericServlet. It is commonly used when developing
servlets that receive and process HTTP requests. The methods of the HttpServlet class
are summarized in Table 27-9.
C h a p t e r 2 7 : S e r v l e t s 969
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Method Description
void setComment(String c) Sets the comment to c.
void setDomain(String d) Sets the domain to d.
void setMaxAge(int secs) Sets the maximum age of the cookie to secs.
This is the number of seconds after which the
cookie is deleted. Passing –1 causes the cookie
to be removed when the browser is terminated.
void setPath(String p) Sets the path to p.
void setSecure(boolean secure) Sets the security flag to secure, which means
that cookies will be sent only when a secure
protocol is being used.
void setValue(String v) Sets the value to v.
void setVersion(int v) Sets the cookie protocol version to v, which will
be 0 or 1.
Table 27-8. The Methods Defined by Cookie (continued)
Method Description
void doDelete(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
Performs an HTTP DELETE.
void doGet(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
Performs an HTTP GET.
Table 27-9. The Methods Defined by HttpServlet
The HttpSessionEvent Class
HttpSessionEvent encapsulates session events. It extents EventObject and is generated
when a change occurs to the session. It defines this constructor:
HttpSessionEvent(HttpSession session)
Here, session is the source of the event.
970 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Method Description
void doHead(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
Performs an HTTP HEAD.
void doOptions(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
Performs an HTTP OPTIONS.
void doPost(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
Performs an HTTP POST.
void doPut(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
Performs an HTTP PUT.
void doTrace(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
Performs an HTTP TRACE.
long getLastModified(HttpServletRequest req) Returns the time (in
milliseconds since midnight,
January 1, 1970, GMT) when
the requested resource was
last modified.
void service(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
Called by the server when an
HTTP request arrives for this
servlet. The arguments provide
access to the HTTP request and
response, respectively.
Table 27-9. The Methods Defined by HttpServlet (continued)
HttpSessionEvent defines one method, getSession( ), which is shown here:
HttpSession getSession( )
It returns the session in which the event occurred.
The HttpSessionBindingEvent Class
The HttpSessionBindingEvent class extends HttpSessionEvent. It is generated
when a listener is bound to or unbound from a value in an HttpSession object. It is
also generated when an attribute is bound or unbound. Here are its constructors:
HttpSessionBindingEvent(HttpSession session, String name)
HttpSessionBindingEvent(HttpSession session, String name, Object val)
Here, session is the source of the event and name is the name associated with the object
that is being bound or unbound. If an attribute is being bound or unbound, its value is
passed in val.
The getName( ) method obtains the name that is being bound or unbound. Its is
shown here:
String getName( )
The getSession( ) method, shown next, obtains the session to which the listener is
being bound or unbound:
HttpSession getSession( )
The getValue( ) method obtains the value of the attribute that is being bound or
unbound. It is shown here:
Object getValue( )
Handling HTTP Requests and Responses
The HttpServlet class provides specialized methods that handle the various types of
HTTP requests. A servlet developer typically overrides one of these methods. These
methods are doDelete( ), doGet( ), doHead( ), doOptions( ), doPost( ), doPut( ), and
doTrace( ). A complete description of the different types of HTTP requests is beyond
the scope of this book. However, the GET and POST requests are commonly used
when handling form input. Therefore, this section presents examples of these cases.
Handling HTTP GET Requests
Here we will develop a servlet that handles an HTTP GET request. The servlet is invoked
when a form on a Web page is submitted. The example contains two files. A Web page
C h a p t e r 2 7 : S e r v l e t s 971
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
is defined in ColorGet.htm and a servlet is defined in ColorGetServlet.java. The HTML
source code for ColorGet.htm is shown in the following listing. It defines a form that
contains a select element and a submit button. Notice that the action parameter of the
form tag specifies a URL. The URL identifies a servlet to process the HTTP GET request.
<html>
<body>
<center>
<form name="Form1"
action="http://localhost:8080/examples/servlet/ColorGetServlet">
<B>Color:</B>
<select name="color" size="1">
<option value="Red">Red</option>
<option value="Green">Green</option>
<option value="Blue">Blue</option>
</select>
<br><br>
<input type=submit value="Submit">
</form>
</body>
</html>
The source code for ColorGetServlet.java is shown in the following listing. The
doGet( ) method is overridden to process any HTTP GET requests that are sent to
this servlet. It uses the getParameter( ) method of HttpServletRequest to obtain the
selection that was made by the user. A response is then formulated.
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class ColorGetServlet extends HttpServlet {
public void doGet(HttpServletRequest request,
HttpServletResponse response)
throws ServletException, IOException {
String color = request.getParameter("color");
response.setContentType("text/html");
PrintWriter pw = response.getWriter();
pw.println("<B>The selected color is:  ");
pw.println(color);
972 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
pw.close();
}
}
Compile the servlet and perform these steps to test this example:
1. Start Tomcat, if it is not already running.
2. Display the Web page in a browser.
3. Select a color.
4. Submit the Web page.
After completing these steps, the browser will display the response that is dynamically
generated by the servlet.
One other point: Parameters for an HTTP GET request are included as part of the
URL that is sent to the Web server. Assume that the user selects the red option and
submits the form. The URL sent from the browser to the server is
http://localhost:8080/examples/servlet/ColorGetServlet?color=Red
The characters to the right of the question mark are known as the query string.
Handling HTTP POST Requests
Here we will develop a servlet that handles an HTTP POST request. The servlet is
invoked when a form on a Web page is submitted. The example contains two files. A
Web page is defined in ColorPost.htm and a servlet is defined in ColorPostServlet.java.
The HTML source code for ColorPost.htm is shown in the following listing. It is
identical to ColorGet.htm except that the method parameter for the form tag explicitly
specifies that the POST method should be used, and the action parameter for the form
tag specifies a different servlet.
<html>
<body>
<center>
<form name="Form1"
method="post"
action="http://localhost:8080/examples/servlet/ColorPostServlet">
<B>Color:</B>
<select name="color" size="1">
<option value="Red">Red</option>
<option value="Green">Green</option>
C h a p t e r 2 7 : S e r v l e t s 973
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
<option value="Blue">Blue</option>
</select>
<br><br>
<input type=submit value="Submit">
</form>
</body>
</html>
The source code for ColorPostServlet.java is shown in the following listing. The
doPost( ) method is overridden to process any HTTP POST requests that are sent to
this servlet. It uses the getParameter( ) method of HttpServletRequest to obtain the
selection that was made by the user. A response is then formulated.
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class ColorPostServlet extends HttpServlet {
public void doPost(HttpServletRequest request,
HttpServletResponse response)
throws ServletException, IOException {
String color = request.getParameter("color");
response.setContentType("text/html");
PrintWriter pw = response.getWriter();
pw.println("<B>The selected color is:  ");
pw.println(color);
pw.close();
}
}
Compile the servlet and perform the same steps as described in the previous
section to test it.
Note: Parameters for an HTTP POST request are not included as part of the URL that
is sent to the Web server. In this example, the URL sent from the browser to the server is:
http://localhost:8080/examples/servlet/ColorGetServlet
The parameter names and values are sent in the body of the HTTP request.
974 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Using Cookies
Now, let’s develop a servlet that illustrates how to use cookies. The servlet is invoked
when a form on a Web page is submitted. The example contains three files as
summarized here:
File Description
AddCookie.htm Allows a user to specify a value for the cookie
named MyCookie.
AddCookieServlet.java Processes the submission of AddCookie.htm.
GetCookiesServlet.java Displays cookie values.
The HTML source code for AddCookie.htm is shown in the following listing.
This page contains a text field in which a value can be entered. There is also a submit
button on the page. When this button is pressed, the value in the text field is sent to
AddCookieServlet via an HTTP POST request.
<html>
<body>
<center>
<form name="Form1"
method="post"
action="http://localhost:8080/examples/servlet/AddCookieServlet">
<B>Enter a value for MyCookie:</B>
<input type=textbox name="data" size=25 value="">
<input type=submit value="Submit">
</form>
</body>
</html>
The source code for AddCookieServlet.java is shown in the following listing. It
gets the value of the parameter named “data”. It then creates a Cookie object that has
the name “MyCookie” and contains the value of the “data” parameter. The cookie is
then added to the header of the HTTP response via the addCookie( ) method. A feedback
message is then written to the browser.
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
C h a p t e r 2 7 : S e r v l e t s 975
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
public class AddCookieServlet extends HttpServlet {
public void doPost(HttpServletRequest request,
HttpServletResponse response)
throws ServletException, IOException {
// Get parameter from HTTP request.
String data = request.getParameter("data");
// Create cookie.
Cookie cookie = new Cookie("MyCookie", data);
// Add cookie to HTTP response.
response.addCookie(cookie);
// Write output to browser.
response.setContentType("text/html");
PrintWriter pw = response.getWriter();
pw.println("<B>MyCookie has been set to");
pw.println(data);
pw.close();
}
}
The source code for GetCookiesServlet.java is shown in the following listing. It
invokes the getCookies( ) method to read any cookies that are included in the HTTP
GET request. The names and values of these cookies are then written to the HTTP
response. Observe that the getName( ) and getValue( ) methods are called to obtain
this information.
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class GetCookiesServlet extends HttpServlet {
public void doGet(HttpServletRequest request,
HttpServletResponse response)
throws ServletException, IOException {
// Get cookies from header of HTTP request.
976 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Cookie[] cookies = request.getCookies();
// Display these cookies.
response.setContentType("text/html");
PrintWriter pw = response.getWriter();
pw.println("<B>");
for(int i = 0; i < cookies.length; i++) {
String name = cookies[i].getName();
String value = cookies[i].getValue();
pw.println("name = " + name +
"; value = " + value);
}
pw.close();
}
}
Compile the servlet and perform these steps:
1. Start Tomcat, if it is not already running.
2. Display AddCookie.htm in a browser.
3. Enter a value for MyCookie.
4. Submit the Web page.
After completing these steps you will observe that a feedback message is displayed by
the browser.
Next, request the following URL via the browser:
http://localhost:8080/examples/servlet/GetCookiesServlet
Observe that the name and value of the cookie are displayed in the browser.
In this example, an expiration date is not explicitly assigned to the cookie via the
setMaxAge( ) method of Cookie. Therefore, the cookie expires when the browser
session ends. You can experiment by using setMaxAge( ) and observe that the cookie
is then saved to the disk on the client machine.
Session Tracking
HTTP is a stateless protocol. Each request is independent of the previous one. However,
in some applications, it is necessary to save state information so that information can
be collected from several interactions between a browser and a server. Sessions provide
such a mechanism.
C h a p t e r 2 7 : S e r v l e t s 977
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
A session can be created via the getSession( ) method of HttpServletRequest. An
HttpSession object is returned. This object can store a set of bindings that associate
names with objects. The setAttribute( ), getAttribute( ), getAttributeNames( ), and
removeAttribute( ) methods of HttpSession manage these bindings. It is important
to note that session state is shared among all the servlets that are associated with a
particular client.
The following servlet illustrates how to use session state. The getSession( ) method
gets the current session. A new session is created if one does not already exist. The
getAttribute( ) method is called to obtain the object that is bound to the name “date”.
That object is a Date object that encapsulates the date and time when this page was last
accessed. (Of course, there is no such binding when the page is first accessed.) A Date
object encapsulating the current date and time is then created. The setAttribute( )
method is called to bind the name “date” to this object.
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class DateServlet extends HttpServlet {
public void doGet(HttpServletRequest request,
HttpServletResponse response)
throws ServletException, IOException {
// Get the HttpSession object.
HttpSession hs = request.getSession(true);
// Get writer.
response.setContentType("text/html");
PrintWriter pw = response.getWriter();
pw.print("<B>");
// Display date/time of last access.
Date date = (Date)hs.getAttribute("date");
if(date != null) {
pw.print("Last access: " + date + "<br>");
}
// Display current date/time.
date = new Date();
hs.setAttribute("date", date);
978 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
pw.println("Current date: " + date);
}
}
When you first request this servlet, the browser displays one line with the current
date and time information. On subsequent invocations, two lines are displayed. The
first line shows the date and time when the servlet was last accessed. The second line
shows the current date and time.
Security Issues
In earlier chapters of this book, you learned that untrusted applets are constrained
to operate in a “sandbox”. They cannot perform operations that are potentially
dangerous to a user’s machine. This includes reading and writing files, opening
sockets to arbitrary machines, calling native methods, and creating new processes.
Other restrictions also apply.
Similar constraints also exist for untrusted servlets. Code that is loaded from a
remote machine is untrusted. However, trusted servlets are not limited in this manner.
Trusted servlets are those which are loaded from the local machine.
C h a p t e r 2 7 : S e r v l e t s 979
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
This page intentionally left blank.
Chapter 28
Migrating from C++
to Java
981
This chapter discusses several of the issues that arise when you move from C++to Java. Since many Java programmers come from a C++ background, it is naturalto want to carry over the skills, techniques, and code acquired in this language.
Although C++ and Java were designed to address the programming needs of two
very different environments, many of the same coding techniques, algorithms, and
optimizations apply to both. However, as explained in Part One, Java is not “the
Internet version of C++.” While there are many similarities between the two languages,
there are also several differences. This chapter reviews those differences and shows
ways to handle some of the more challenging ones.
The Differences Between C++ and Java
Before we look at specific situations, let’s review the basic differences between C++
and Java. The differences fall into three categories:
■ C++ features not supported by Java
■ Features unique to Java
■ Shared features which differ between C++ and Java
Each is examined here.
What Java Has Removed from C++
There are a number of C++ features that Java does not support. In some cases, a
specific C++ feature simply didn’t relate to the Java environment. In other cases, the
designers of Java eliminated some of the duplication of features that exists in C++. In
still other instances, a feature of C++ is not supported by Java because it was deemed
too dangerous for Internet applets.
Perhaps the single biggest difference between Java and C++ is that Java does not
support pointers. As a C++ programmer you know that the pointer is one of C++’s
most powerful and important language features. It is also one of its most dangerous
when used improperly. Pointers don’t exist in Java for two reasons:
■ Pointers are inherently insecure. For example, using a C++-style pointer, it is
possible to gain access to memory addresses outside a program’s code and
data. A malicious program could make use of this fact to damage the system,
perform unauthorized accesses (such as obtaining passwords), or otherwise
violate security restrictions.
982 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
■ Even if pointers could be restricted to the confines of the Java run-time system
(which is theoretically possible), the designers of Java believed that they were
inherently troublesome.
Since pointers don’t exist in Java, neither does the -> operator.
Here are a few more of the most important “omissions”:
■ Java does not include structures or unions. These were felt to be redundant
since the class encompasses them.
■ Java does not support operator overloading. Operator overloading is sometimes
a source of ambiguity in a C++ program, and the Java design team felt that it
causes more trouble than benefit.
■ Java does not include a preprocessor nor does it support the preprocessor
directives. The preprocessor plays a less important role in C++ than it does
in C. The designers of Java felt that it was time to eliminate it entirely.
■ Java does not perform any automatic type conversions that result in a loss of
precision. For example, a conversion from long integer to integer must be
explicitly cast.
■ All the code in a Java program is encapsulated within one or more classes.
Therefore, Java does not have what you normally think of as global variables
or global functions.
■ Java does not allow default arguments. In C++, you may specify a value
that a parameter will have when there is no argument corresponding to
that parameter when the function is invoked. This is not allowed in Java.
■ Java does not support the inheritance of multiple superclasses by a subclass.
■ Although Java supports constructors, it does not have destructors. It does,
however, add the finalize( ) function.
■ Java does not support typedef.
■ It is not possible to declare unsigned integers in Java.
■ Java does not allow the goto.
■ Java does not have the delete operator.
■ The << and >> in Java are not overloaded for I/O operations.
■ In Java, objects are passed by reference only. In C++, objects may be passed by
value or by reference.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 983
984 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
New Features Added by Java
There are a number of features in Java that have no equivalent in C++. Perhaps the
three most important are multithreading, packages, and interfaces, but there are
several others that enrich the Java programming environment as well.
■ As explained earlier, multithreading allows two or more pieces of the same
program to execute concurrently. Further, this approach to concurrence is
supported at the language level. There is no parallel for this in C++. If you
need to multithread a C++ program, you will need to do so manually, using
operating system functions. While both methods allow for concurrent execution
of two or more threads, Java’s approach is cleaner and easier to use.
■ There is no feature in C++ that directly corresponds to a Java package. The
closest similarity is a set of library functions that use a common header file.
However, constructing and using a library in C++ is completely different from
constructing and using a package in Java.
■ The Java interface is somewhat similar to a C++ abstract class. (An abstract class
in C++ is a class that contains at least one pure virtual function.) For example, it
is impossible to create an instance of a C++ abstract class or a Java interface.
Both are used to specify a consistent interface that subclasses will implement.
The main difference is that an interface more cleanly represents this concept.
■ Java has a streamlined approach to memory allocation. Like C++, it supports
the new keyword. However, it does not have delete. Instead, when the last
reference to an object is destroyed, the object, itself, is automatically deleted the
next time that garbage collection occurs.
■ Java “removes” the C++ standard library, replacing it with its own set of API
classes. While there is substantial functional similarity, there are significant
differences in the names and parameters. Also, since all of the Java API library
is object-oriented, and only a portion of the C++ library is, there will be
differences in the way library routines are invoked.
■ The break and continue statements have been enhanced in Java to accept labels
as targets.
■ The char type in Java declares 16-bit-wide Unicode characters. This makes
them similar to C++’s wchar_t type. The use of Unicode helps ensure
portability.
■ Java adds the >>> operator, which performs an unsigned right shift.
■ In addition to supporting single-line and multiline comments, Java adds a third
comment form: the documentation comment. Documentation comments begin
with a /** and end with a */.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 985
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
■ Java contains a built-in string type called String. String is somewhat similar
to the standard string class type provided by C++. Of course, in C++ string is
only available if you include its class declarations in your program. It is not a
built-in type.
Features That Differ
There are some features common to both C++ and Java that each language handles a
bit differently:
■ While both C++ and Java support a Boolean data type, Java does not implement
true and false in the same way as C++. In C++, true is any nonzero value. False
is zero. In Java, true and false are predefined literals, and these are the only
values that a boolean expression may have. While C++ also defines true and
false, which may be assigned to a bool variable, C++ automatically converts
nonzero values into true and zero values into false. This does not occur in Java.
■ When you create a C++ class, the access specifiers apply to groups of
statements. In Java, access specifiers apply only to the declarations that they
immediately precede.
■ C++ supports exception handling that is fairly similar to Java’s. However,
in C++ there is no requirement that a thrown exception be caught.
With these additions, deletions, and differences as a backdrop, the rest of this
chapter will look closely at a few of the key issues that you must deal with when
converting code from C++ to Java.
Eliminating Pointers
When you convert a C++ program into Java, perhaps the greatest number of changes
will be caused by pointers. Most C++ code is heavily dependent upon pointers for its
operation. You can’t program anything very significant in C++ without using a pointer.
There are four general categories of pointer usage that you will encounter in
C++ code:
■ As parameters to functions. Although C++ supports the reference parameter,
there is a large base of legacy code that was originally written in C. C does not
support reference parameters. In C, if a function needs to change the value of an
argument, it is necessary to explicitly pass a pointer to that argument. Therefore,
it is still common to find pointer parameters used in C++ code that was originally
ported from C. Also, in some cases the same function library will need to be
shared by both C and C++ code, which prevents the use of reference parameters.
986 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Additionally, many of the standard library functions supported by C++ are
holdovers from C. When one of these C-based functions requires the address
of an argument, a pointer to the argument is used. Inside the function, the
argument is then accessed through its pointer.
■ To provide a more efficient means of implementing certain constructs—
especially array indexing. For example, it is often more efficient to sequentially
move through an array using a pointer rather than an array index. While modern
compilers implement highly efficient optimizations, pointers can still provide a
significant performance boost. Thus, the use of pointers to access arrays is
ubiquitous in C++ code.
■ To support memory allocation. In C++, when you allocate memory, an
address (that is, a pointer) to that memory is returned. This address must be
assigned to a pointer variable. Once this has been done, the pointer can point to
any part of the allocated memory—or anywhere else, for that matter—by means
of pointer arithmetic. In Java, when an object is allocated by new, a reference to
the object is returned. This reference must be assigned to a reference variable of
a compatible type. While Java reference variables do implicitly point to the
object that was allocated by the new operator, they cannot be manipulated in
the same way as C++ pointers. And they cannot point to memory outside of the
Java run-time context.
■ To provide access to any arbitrary machine address, possibly to call a ROM
routine or to read/write directly to memory. Since Java purposely disallows
such actions, this use of pointers has no direct parallel. If you are writing
applications, not applets, you can always use Java’s native capabilities
(described in Part One) to gain access to native code routines that would
be allowed access to such system resources.
Let’s look at two situations in which pointer-based C++ code is converted to Java.
Converting Pointer Parameters
For the most part, it is quite easy to convert a C++ function that uses pointer
parameters into its equivalent Java method. Since Java passes all objects by reference,
sometimes the conversion simply requires the removal of C++’s pointer operators. For
example, consider this C++ program that reverses the signs of a Coord object, which
stores a pair of Cartesian coordinates. The function reverseSign( ) is passed a pointer
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 987
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
to the Coord object that will be reversed. As you can see, C++’s *, &, and -> pointer
operators are used to perform the operation.
// Reverse the signs of a coordinate - C++ version.
#include <iostream>
using namespace std;
class Coord {
public:
int x;
int y;
};
// Reverse the sign of the coordinates.
void reverseSign(Coord *ob) {
ob->x = -ob->x;
ob->y = -ob->y;
}
int main()
{
Coord ob;
ob.x = 10;
ob.y = 20;
cout << "Original values for ob: ";
cout << ob.x << ", " << ob.y << "\n";
reverseSign(&ob);
cout << "Sign reversed values for ob: ";
cout << ob.x << ", " << ob.y << "\n";
return 0;
}
988 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
This program can be recoded into the following Java version. As you can see, most
of the conversion involves the deletion of the C++ pointer operators. Since Java passes
objects by reference, changes to the parameter automatically affect the argument.
// Reverse the signs of a coordinate - Java version.
class Coord {
int x;
int y;
};
class DropPointers {
// Reverse the sign of the coordinates.
static void reverseCoord(Coord ob) {
ob.x = -ob.x;
ob.y = -ob.y;
}
public static void main(String args[]) {
Coord ob = new Coord();
ob.x = 10;
ob.y = 20;
System.out.println("Original values for ob: " +
ob.x + ", " + ob.y);
reverseCoord(ob);
System.out.println("Sign reversed values for ob: " +
ob.x + ", " + ob.y);
}
}
The output from both of these programs is the same and is shown here:
Original values for ob: 10, 20
Sign reversed values for ob: -10, -20
Converting Pointers that Operate on Arrays
Conceptually, converting C++-style pointer-based array accessing into the equivalent
Java-compatible array indexing is straightforward—simply substitute the appropriate
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 989
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
array-indexing statements. However, in practice this may require some thought.
Pointer-based array accessing can be a bit difficult to follow, because the normal C++
coding style encourages rather dense, complex expressions. For example, this short
C++ program copies the contents of one array to another. It uses 0 to mark the end of
the arrays. Pay special attention to the pointer expressions. Even in this simple example,
if you did not know that this program copied the contents of nums to copy (and later
displayed the arrays), it would require some careful thought before you were completely
sure that you knew what the code was doing.
// Copy an array in C++ using pointers.
#include <iostream>
using namespace std;
int main()
{
int nums[] = {10, 12, 24, 45, 23, 19, 44,
88, 99, 65, 76, 12, 89, 0};
int copy[20];
int *p1, *p2; // integer pointers
// copy array
p1 = nums; // p1 points to start of nums array
p2 = copy;
while(*p1) *p2++ = *p1++;
*p2 = 0; // terminate copy with zero
// Display contents of each array.
cout << "Here is the original array:\n";
p1 = nums;
while(*p1) cout << *p1++ << " ";
cout << endl;
cout << "Here is the copy:\n";
p1 = copy;
while(*p1) cout << *p1++ << " ";
cout << endl;
return 0;
}
990 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Even though it is quite simple for C++ code, at first glance the line
while(*p1) *p2++ = *p1++;
still requires a moment of thought to decipher its exact operation. One of the
advantages of Java is that it does not encourage the creation of such expressions
in the first place. Here is the Java version of the program. As you can see, its purpose
and effects are transparent.
// Array copy without pointers using Java.
class CopyArray {
public static void main(String args[]) {
int nums[] = {10, 12, 24, 45, 23, 19, 44,
88, 99, 65, 76, 12, 89, 0};
int copy[] = new int[14];
int i;
// copy array
for(i=0; nums[i]!=0; i++)
copy[i] = nums[i];
nums[i] = 0; // terminate copy with zero
// Display contents of each array.
System.out.println("Here is the original array:");
for(i=0; nums[i]!=0; i++)
System.out.print(nums[i] + " ");
System.out.println();
System.out.println("Here is the copy:");
for(i=0; nums[i]!=0; i++)
System.out.print(copy[i] + " ");
System.out.println();
}
}
Both versions of the program produce the following results:
Here is the original array:
10 12 24 45 23 19 44 88 99 65 76 12 89
Here is the copy:
10 12 24 45 23 19 44 88 99 65 76 12 89
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 991
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Much C++ code is sprinkled with obscure, difficult to understand pointer expressions.
While these expressions do tend to increase speed of execution, they are one of the
most troubling issues associated with the maintenance of C++ programs. They will also
present difficulty when you convert the code to Java. When you are confronted with a
complex pointer expression, it is sometimes useful to begin by breaking it into its
subexpressions so that its exact operation becomes clear.
C++ Reference Parameters Versus Java
Reference Parameters
In the preceding section, you saw an example of a C++ program that used a pointer
parameter. In Java, this became a reference parameter. Of course, C++ also supports
reference parameters. As mentioned, most pointer parameters found in C++ code
are simply holdovers from C. Nearly all new C++ code will use reference parameters
when a function needs access to the argument, itself. (In essence, pointer parameters,
although still common, are actually anachronisms in most C++ code.) Since both Java
and C++ support reference parameters, you might think that the conversion of a C++
function that uses reference parameters to a Java method would involve few changes.
Unfortunately, this is not always the case. To understand why, let’s convert the
following C++ program, which swaps the contents of two Coord objects using
reference parameters:
// Swap coordinates -- C++ version.
#include <iostream>
using namespace std;
class Coord {
public:
int x;
int y;
};
// Swap contents of two Coord objects.
void swap(Coord &a, Coord &b) {
Coord temp;
// swap contents of objects
temp = a;
a = b;
b = temp;
}
992 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
int main()
{
Coord ob1, ob2;
ob1.x = 10;
ob1.y = 20;
ob2.x = 88;
ob2.y = 99;
cout << "Original values:\n";
cout << "ob1: " << ob1.x << ", " << ob1.y << "\n";
cout << "ob2: " << ob2.x << ", " << ob2.y << "\n";
cout << "\n";
swap(ob1, ob2);
cout << "Swapped values:\n";
cout << "ob1: " << ob1.x << ", " << ob1.y << "\n";
cout << "ob2: " << ob2.x << ", " << ob2.y << "\n";
return 0;
}
Following is the output produced by this program. As you can see, the contents of
ob1 and ob2 have been exchanged:
Original values:
ob1: 10, 20
ob2: 88, 99
Swapped values:
ob1: 88, 99
ob2: 10, 20
In Java, all objects are accessed via an object reference variable. Thus, when an
object is passed to a method, only its reference is passed. This means that all objects
are automatically passed by reference to a Java method. Without thinking any deeper
about what is actually occurring, someone might initially try the following (incorrect)
conversion of the preceding program:
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 993
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
// Swap program incorrectly converted to Java.
class Coord {
int x;
int y;
};
class SwapDemo {
static void swap(Coord a, Coord b) {
Coord temp = new Coord();
// this won't swap contents of a and b!
temp = a;
a = b;
b = temp;
}
public static void main(String args[]) {
Coord ob1 = new Coord();
Coord ob2 = new Coord();
ob1.x = 10;
ob1.y = 20;
ob2.x = 88;
ob2.y = 99;
System.out.println("Original values:");
System.out.println("ob1: " +
ob1.x + ", " + ob1.y);
System.out.println("ob2: " +
ob2.x + ", " + ob2.y + "\n");
swap(ob1, ob2);
System.out.println("Swapped values:");
System.out.println("ob1: " +
ob1.x + ", " + ob1.y);
System.out.println("ob2: " +
ob2.x + ", " + ob2.y + "\n");
}
}
994 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The output produced by this incorrect program is shown here:
Original values:
ob1: 10, 20
ob2: 88, 99
Swapped values:
ob1: 10, 20
ob2: 88, 99
As you can see, the values of ob1 and ob2 in main( ) have not been exchanged!
Although a bit counterintuitive at first, the reason is actually obvious, once you
understand precisely what happens when an object reference is passed to a method.
Java passes all arguments to methods using call-by-value. This means that a copy of the
argument is made, and what occurs to the copy inside the method has no effect on the
argument used to call the method. However, this situation is blurred a bit in the case of
object references.
When an object reference is passed to a method, a copy of the reference variable is
made, as just explained. This means that the parameter inside the method will refer to
the same object as does the reference variable used as an argument outside the method.
Therefore, operations on the object through the parameter will affect the object referred
to by the argument (since they are one and the same). But operations on the reference
parameter, itself, affect only that parameter. Thus, when the preceding program attempts
to swap the objects by exchanging the objects pointed to by a and b, all that is happening
is that the parameters (that is, the copies of the arguments) are exchanging what they
are referring to, but this does not alter what ob1 and ob2 refer to back in main( ).
To fix the program, swap( ) needs to be rewritten so that the contents of the objects
are exchanged, not what the parameters refer to. Here is the corrected version of swap( ):
// Corrected version of swap().
static void swap(Coord a, Coord b) {
Coord temp = new Coord();
// swap contents of objects
temp.x = a.x;
temp.y = a.y;
a.x = b.x;
a.y = b.y;
b.x = temp.x;
b.y = temp.y;
}
If you substitute this version of swap( ) into the preceding program, the correct results
will be achieved.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 995
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
Converting C++ Abstract Classes into
Java Interfaces
One of the most innovative aspects of Java is the interface. As explained earlier in this
book, an interface specifies the form of its various methods without specifying any
implementation details. Each class that implements an interface does so by creating
the actual methods declared by the interface. Thus, in Java an interface is the means
by which you can define the general form of a class while ensuring that all specific
versions of the class conform to the same set of rules. The interface is one of the ways
that Java provides support for polymorphism.
In C++, there is no direct parallel to the interface. Instead, in C++, if you wish to
define the form of a class without defining implementation details, you must do so by
using an abstract class. Abstract classes in C++ are similar to abstract classes in Java:
they do not contain a full set of implementation details. In C++, an abstract class contains
at least one pure virtual function. A pure virtual function defines no implementation; it
only defines the function prototype. Thus, a pure virtual function in C++ is essentially
the same as an abstract method in Java. In C++, abstract classes serve a function similar
to interfaces in Java. For this reason, they are one of the items that you will want to
watch for when converting code to Java. While not all C++ abstract classes can be
converted into Java interfaces, many can. Let’s look at two examples.
Here is a short C++ program that uses an abstract class called IntList to define the
form of an integer list. An implementation of this class is created by IntArray, which
uses an array to implement a list of integers.
// A C++-style abstract class and its implementation.
#include <iostream>
#include <cstdlib>
using namespace std;
// An abstract class that defines the form of an integer list.
class IntList {
public:
virtual int getNext() = 0; // pure virtual functions
virtual void putOnList(int i) = 0;
};
// Create an implementation of an integer list.
class IntArray : public IntList {
int storage[100];
int putIndex, getIndex;
public:
IntArray() {
putIndex = 0;
getIndex = 0;
996 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}
// Return next integer in list.
int getNext() {
if(getIndex >= 100) {
cout << "List Underflow";
exit(1);
}
getIndex++;
return storage[getIndex-1];
}
// Put an integer on the list.
void putOnList(int i) {
if(putIndex < 100) {
storage[putIndex] = i;
putIndex++;
}
else {
cout << "List Overflow";
exit(1);
}
}
};
int main()
{
IntArray nums;
int i;
for(i=0; i<10; i++) nums.putOnList(i);
for(i=0; i<10; i++)
cout << nums.getNext() << endl;
return 0;
}
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 997
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
In this program, the abstract class IntList defines only the form of an integer list. It
contains only pure virtual functions and does not declare any data. For these reasons, it
can be made into an interface when the program is converted into Java, as shown here:
// Here, IntList is made into an interface which IntArray implements.
// Define interface for an integer list.
interface IntListIF {
int getNext();
void putOnList(int i);
}
// Create an implementation of an integer list.
class IntArray implements IntListIF {
private int storage[];
private int putIndex, getIndex;
IntArray() {
storage = new int[100];
putIndex = 0;
getIndex = 0;
}
// Create an implementation of an integer list.
public int getNext() {
if(getIndex >= 100) {
System.out.println("List Underflow");
System.exit(1);
}
getIndex++;
return storage[getIndex-1];
}
// Put an integer on the list.
public void putOnList(int i) {
if(putIndex < 100) {
storage[putIndex] = i;
putIndex++;
}
else {
System.out.println("List Overflow");
System.exit(1);
}
}
}
class ListDemo {
public static void main(String args[]) {
IntArray nums = new IntArray();
int i;
for(i=0; i<10; i++) nums.putOnList(i);
for(i=0; i<10; i++)
System.out.println(nums.getNext());
}
}
As you can see, there is nearly a one-to-one correspondence between the C++ abstract
class IntList and the Java interface IntListIF. It is possible to convert IntList into
IntListIF because it contained only pure virtual functions. This is the key. If IntList had
contained any data or function implementations, then it would not have qualified for
conversion into an interface.
When you convert or adapt C++ code into Java, look for examples of abstract
classes that contain only pure virtual functions. These are prime candidates for
conversion to Java interfaces. But don’t overlook abstract C++ classes that contain a
small number of implemented functions or data. It is possible that these items don’t
really belong in the abstract class to begin with and should be defined by individual
implementations. Since C++ does not define an interface construct, there was no reason
for C++ programmers to think in terms of one.
Sometimes a concrete member is contained in an otherwise abstract class simply for
expedience—not because it is the most logical place for it. For example, consider the
following abstract C++ class:
// An abstract C++ class.
class SomeClass {
bool isOK;
public:
virtual int f1() = 0;
virtual void f2(int i) = 0;
virtual double f3() = 0;
virtual int f4(int a, char ch) = 0;
};
998 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 999
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
The only reason that this class cannot be made into a Java interface is the existence
of isOK. Presumably, isOK is used to indicate some status associated with the class.
However, if you think about it, there really is no reason for isOK to be defined as a
variable. Instead, you could specify a method called isOK( ) that returns the status.
In this approach, isOK( ) will be defined, along with the other methods, by any
implementing class. Thus, you could convert the preceding C++ abstract class into
the following Java interface:
interface SomeClass {
int f1();
void f2(int i);
double f3();
int f4(int a, char ch);
boolean isOK();
}
Many abstract classes in C++ can—and should—be converted into interfaces when
you move code to Java. In doing so, you will probably find that it clarifies the structure
of the class hierarchy.
Converting Default Arguments
One extensively used feature of C++ that Java does not support is default function
arguments. For example, the area( ) function shown in the following C++ program
computes the area of a rectangle if called with two arguments, or the area of a square
if called with one argument.
// C++ program that uses default arguments.
#include <iostream>
using namespace std;
/* Compute area of a rectangle.  For a square,
pass only one argument.
*/
double area(double l, double w=0) {
if(w==0)  return l * l;
else return l * w;
}
int main()
{
cout << "Area of 2.2 by 3.4 rectangle: ";
cout << area(2.2, 3.4) << endl;
1000 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
cout << "Area of 3.0 by 3.0 square: ";
cout << area(3.0) << endl;
return 0;
}
As you can see, when area( ) is called with only one argument, the second defaults to
zero. When this happens, the function simply uses the first argument for both the
length and the width of the rectangle.
While convenient, default arguments are not, of course, necessary. In essence,
default arguments are actually a shorthand form of function overloading in which one
form of the function has a different number of parameters than the other. Thus, to
convert a C++ function that contains one or more default arguments into Java, simply
create overloaded methods that handle each case. In this example, you need a version
of area( ) that takes two arguments and another that takes only one argument. Using
this approach, here is the preceding program rewritten for Java:
// Java version of area program.
class Area {
// Compute area of a rectangle.
static double area(double l, double w) {
if(w==0)  return l * l;
else return l * w;
}
// Overload area( ) for a square.
static double area(double l) {
return l * l;
}
public static void main(String args[]) {
System.out.println("Area of 2.2 by 3.4 rectangle: " +
area(2.2, 3.4));
System.out.println("Area of 3.0 by 3.0 square: " +
area(3.0));
}
}
Converting C++ Multiple-Inheritance
Hierarchies
C++ allows one class to inherit two or more base classes at the same time. Java does
not. To understand the difference, consider the two hierarchies depicted here:
In both cases, subclass C inherits classes A and B. However, in the hierarchy on the left,
C inherits both A and B at the same time. In the one on the right, B inherits A, and C
inherits B. By not allowing the inheritance of multiple base classes by a single subclass,
Java greatly simplifies the inheritance model. Multiple inheritance carries with it
several special cases that must be handled. This adds overhead to both the compiler
and the run-time system, while providing only marginal benefit for the programmer.
Since C++ supports multiple inheritance and Java does not, you may have to deal
with this issue when porting C++ applications to Java. While every situation is
different, two general pieces of advice can be offered. First, in many cases, multiple
inheritance is employed in a C++ program when there is actually no need to do so.
When this is the case, just convert the class structure to a single-inheritance hierarchy.
For example, consider this C++ class hierarchy that defines a class called House:
class Foundation {
// ...
};
class Walls {
// ...
};
class Rooms {
// ...
};
class House : public Foundation, Walls, Rooms {
// ...
};
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 1001
Notice that House multiply inherits Foundation, Walls, and Rooms. While there is
nothing wrong with structuring a C++ hierarchy like this, it is not necessary. For
example, here is the same set of classes structured for Java:
class Foundation {
// ...
}
class Walls extends Foundation {
// ...
}
class Rooms extends Walls {
// ...
}
class House extends Rooms {
// ...
}
Here, each class extends the preceding one, with House becoming the final extension.
Sometimes a multiple inheritance hierarchy is more readily converted by including
objects of the multiply inherited classes in the final object. For example, here is another
way that House could be constructed in Java:
class Foundation {
// ...
}
class Walls{
// ...
}
class Rooms {
// ...
}
/* Now, House includes Foundation, Walls, and Rooms
as object members.
*/
1002 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
class House {
Foundation f;
Walls w;
Rooms r;
// ...
}
Here, Foundation, Walls, and Rooms are objects that are part of House rather than
inherited by House.
One other point: sometimes a C++ program will contain a multiple-inheritance
hierarchy simply because of poor initial design. A good time to correct this type of
design flaw is when you port to Java.
Destructors Versus Finalization
When you move from C++ to Java, one of the more subtle, yet important issues you
will face is the difference between a C++ destructor and a Java finalize( ) method.
Although similar in many respects, their actual operation is distinctively different.
Let’s begin by reviewing the purpose and effect of a C++ destructor and the Java
finalize( ) method.
In C++, when an object goes out of scope, it is destroyed. Just prior to its destruction,
its destructor function is called (if it has one). This is a hard-and-fast rule. There are no
exceptions. Let’s look more closely at each part of this rule:
■ Every object is destroyed when it goes out of scope. Thus, if you declare a
local object inside a function, when that function returns, that local object is
automatically destroyed. The same goes for function parameters and for objects
returned by functions.
■ Just before destruction, the object’s destructor is called. This happens
immediately, and before any other program statements will execute. Thus, a
C++ destructor will always execute in a deterministic fashion. You can always
know when and where a destructor will be executed.
In Java, the tight linkage of the destruction of an object and the calling of its
finalize( ) method does not exist. In Java, objects are not explicitly destroyed when
they go out of scope. Rather, an object is marked as unused when there are no longer
any references pointing to it. Even then, the finalize( ) method will not be called until
the garbage collector runs. Thus, you cannot know precisely when or where a call to
finalize( ) will occur. Even if you execute a call to gc( ) (the garbage collector), there is
no guarantee that finalize( ) will immediately be executed.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 1003
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
While the deterministic behavior of a C++ constructor and the somewhat
probabilistic aspect of finalization are of little concern in most cases, they will have
an impact on others. For example, consider the following C++ program:
// This C++ program can call f() indefinitely.
#include <iostream>
#include <cstdlib>
using namespace std;
const int MAX = 5;
int count = 0;
class X {
public:
// constructor
X() {
if(count<MAX) {
count++;
}
else  {
cout << "Error -- can't construct";
exit(1);
}
}
// destructor
~X() {
count--;
}
};
void f()
{
X ob; // allocate an object
// destruct on way out
}
int main()
{
int i;
for(i=0; i < (MAX*2); i++) {
f();
1004 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
cout << "Current count is: " << count << endl;
}
return 0;
}
Here is the output generated by this program:
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Current count is: 0
Look carefully at the constructor and destructor for X. The constructor increments
the value of count as long as count is less than MAX. The destructor decrements count.
Thus, count is incremented when an X object is created and decremented when an X
object is destroyed. But no more than MAX objects can exist at any one time. However,
in main( ), f( ) is called MAX*2 times without causing an error! Here is why. Inside f( ),
an object of type X is created, causing count to be incremented, and then the function
returns. This causes the object to immediately go out of scope and its destructor to be
called, which decrements count. Thus, calling f( ) has no net effect on the value of
count. This means that it can be called indefinitely. However, this is not the case when
this program is converted to Java.
Here is the Java version of the preceding program:
// This Java program will fail after 5 calls to f().
class X {
static final int MAX = 5;
static int count = 0;
// constructor
X() {
if(count<MAX) {
count++;
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 1005
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
}else  {
System.out.println("Error -- can't construct");
System.exit(1);
}
}
// finalization
protected void finalize() {
count--;
}
static void f()
{
X ob = new X(); // allocate an object
// destruct on way out
}
public static void main(String args[]) {
int i;
for(i=0; i < (MAX*2); i++) {
f();
System.out.println("Current count is: " + count);
}
}
}
This program will fail after five calls to f( ), as this output shows:
Current count is: 1
Current count is: 2
Current count is: 3
Current count is: 4
Current count is: 5
Error — can’t construct
The reason the program fails is that garbage collection does not occur each time f( )
returns. Thus, finalize( ) is not invoked, and the value of count is not decremented.
After five calls to the method, count reaches its maximum value and the program fails.
1006 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
It is important to emphasize that precisely when garbage collection occurs is
implementation dependent. It is possible that for some implementation of Java, on
some platform, the preceding program will function similarly to its C++ version.
However, the point of the example remains: In C++, you know when and where a
destructor will be called. In Java, you do not know when or where finalize( ) will be
executed. Therefore, when porting code from C++ to Java, you will need to watch for
instances in which the precise timing of the execution of a destructor is relied upon.
C h a p t e r 2 8 : M i g r a t i n g f r o m C + + t o J a v a 1007
S
O
FTW
A
R
E
D
EV
ELO
P
M
EN
T
U
S
IN
G
JA
V
A
This page intentionally left blank.
Part IV
Applying Java
This page intentionally left blank.
Chapter 29
The DynamicBillboard
Applet
1011
Robert Temple is a software engineer who has designed several highly used applets.His work includes the ESPNET SportsZone “HitCharts” and “Batter vs. Pitcher”applets. One of his most impressive applets is DynamicBillboard, which he wrote
while he was at Embry-Riddle Aeronautical University in Florida.
The DynamicBillboard applet displays a sequence of images by repeatedly
changing the image on the screen to another after a period of time. The transition
between one image and the next is done with one of a variety of special effects. One
example of a transition is the SmashTransition, where the new image drops down
from above the old image and appears to smash the old image out of place. The applet
links to other pages through a URL associated with each image. When the user presses
the mouse button with the cursor over the applet, the browser will go to the new page
associated with the current image. The DynamicBillboard applet provides web sites
with an elegant way to rotate ads, banners, or billboards on a single static page.
Robert has included many interesting optimizations. This applet would not be
functional without the careful changes that he crafted. There are enough tips and tricks
in this source code to help you make your applets really fly.
The APPLET Tag
The APPLET tag for DynamicBillboard is fairly easy to configure. You name the main
class in the code parameter and specify the width and height, as with most applets:
<applet code=DynamicBillboard width=392 height=72>
There are several parameters that must be specified for the applet to function
properly. Without them the applet does nothing. Also, you will notice that if you make
any mistakes naming files and such, the behavior is a little unfriendly: either nothing
happens or some of your billboards will be blank. The following parameters are
specified as:
<param name=parameter_name value="your value here">
■ bgcolor This parameter is used to set the background color of the applet
before the first image loads. You can use this to get rid of the gray applet
square quickly.
■ delay This parameter specifies the number of milliseconds between
each billboard. Typically, it’s a number like 5000 or 10000, meaning five or
ten seconds.
1012 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
■ billboards This parameter specifies the number of billboards you wish to
cycle through.
■ bill# This is shorthand for bill0, bill1, bill2, and so on, up to one less than the
number of billboards you’ve specified. (Robert is a typical programmer who
starts counting at 0.) You will have as many of these as you specified in the
billboards parameter. The value of each of these bill#s will be a pair of strings
separated by a comma. The first one is the image name to display for this
billboard. The second is the URL of where to go when the user clicks on this
billboard. Here is an example:
<param name="bill0" value="sample.jpg,http://www.example.com/">
■ transitions This is a list beginning with the number of items in the list as an
integer, followed by the list of Transition subclass names. Here is an example:
<param name="transitions" value="2,TearTransition,SmashTransition">
Here is an example of a complete APPLET tag with all of the transitions discussed
in this chapter:
<applet code=DynamicBillboard width=392 height=72>
<param name="bgcolor" value="#ffffff">
<param name="delay" value="5000">
<param name="billboards" value="5">
<param name="bill0"
value="board1.jpg,http://www.someURL">
<param name="bill1"
value="board2.jpg,http://www.someURL">
<param name="bill2"
value="board3.jpg,http://www.someURL">
<param name="bill3"
value="board4.jpg,http://www.someURL">
<param name="bill4"
value="board5.jpg,http://www.someURL">
<param name="transitions"
value="5,ColumnTransition,FadeTransition,TearTransition,
SmashTransition,UnrollTransition">
</applet>
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1013
A
P
P
LY
IN
G
JA
V
A
Source Code Overview
Robert designed the applet with a fast load time in mind. He tries to keep the size of
the applet to a minimum so that there is less code to send across the network. He also
attempts to delay some of the loading and initializing of the applet until after the first
image is displayed. As far as the user is concerned, the applet is running after the first
image is fully displayed, even though there is a lot more work to be done.
The applet consists of three main classes and any number of transition classes.
The three main classes are DynamicBillboard, BillData, and BillTransition. The
DynamicBillboard class is a top-level Applet subclass that uses all of the other classes.
The BillData class encapsulates a number of billboard attributes, including the image
and the URL associated with the image. The BillTransition class is an abstract class
that contains methods and attributes common to all transitions. The three main classes
are described next, along with five popular transitions.
DynamicBillboard.java
This is the main applet class. It implements Runnable to include a thread that
controls the continuous process of creation and animation of the transitions.
The transition_classes array stores the names of the transition classes as strings.
It uses strings because it loads these classes dynamically using the method
java.lang.Class.forName(String). This allows the applet to put off the loading of
these classes until they are first instantiated.
init( )
The init( ) method is called automatically when the applet is first loaded. Most applets
use this method to perform all of their necessary initialization. Robert, however,
decided to separate his initialization into two methods: init( ) and finishInit( ). The
idea behind splitting up the initialization is to try to display the first image within the
applet in the least amount of time, minimizing the time that the applet is showing a
blank rectangle while it is loading and initializing. The only processing that is done
in this init( ) method is that which is absolutely necessary to get initial content to the
screen, because the browser will not call paint( ) until after init( ) returns.
The first thing that Robert does with init( ) is to change the background color of the
applet and the parent frame in which the applet is embedded. In the past, the space
that an applet uses on the screen was shown as a solid gray box while the applet was
loading and initializing. This box would tend to stand out on pages that use a background
color other than gray, which is just about every page created since 1994. Robert discovered
a way around this problem. He found that applets always have a parent container in
which they are embedded. Under both Netscape Navigator and Internet Explorer, this
container is derived from the core Java class: java.awt.Container. Robert uses the
methods inherited from java.awt.Component—setBackground( ) and repaint( )—to
change the background color to the value of a bgcolor applet parameter. This makes
1014 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
the applet space stand out less than it does when it is gray. All this is done even before
the applet begins to load the first image.
With newer browsers, this frame no longer defaults to gray but rather uses the
background color of the page. Thus, today applets will not benefit from changing the
background color. However, this appoach still illustrates an interesting technique,
which you can adapt for other purposes.
After changing background colors, Robert’s applet reads in a parameter that tells
how many different billboards there will be and then allocates an array of BillData
objects based on this parameter.
With the help of Math.random( ), a random billboard is chosen to start.
parseBillData( ) is called to parse the parameters for this billboard.
parseBillData( )
This method creates and initializes the next billboard (BillData) object that the applet
will use. It only gets called if the billboard object has not been created yet (the element
corresponding to the next billboard object in the billboard array will be null).
Normally, parseBillData( ) calls the BillData method initPixels( ) after creating
the new object to initialize a pixel array within the BillData object. The first time this
method is called, however, the applet is still concentrating on getting the first image to
the screen as fast as possible. It knows this because the reference to the image that is
used to paint the applet is still null. So instead it sets the image variable and waits to
call the processor-intensive initPixel( ) method until after the first image is loaded.
finishInit( )
After the first image is displayed on the screen, the applet can finish the rest of its
initialization. This includes initializing the names of all the transition classes and
initializing the pixels array for the first billboard and reading the target parameter.
finishInit( ) is called from the run( ) method of the applet. The run( ) method
restarts from the top each time the user leaves and comes back to the page. When this
happens, finishInit( ) will be called again. Since the applet has already finished its
initialization, Robert does not want it to reinitialize everything. This is why the applet
checks to see if the delay variable has already been initialized. If it has, then the applet
can skip the rest of the initialization.
start( ) and stop( )
The start( ) and stop( ) methods respectively are called when the user comes to or
leaves the page. They ensure that the applet thread that runs the transitions is on or off.
If stop( ) is called while the applet is in the middle of running a transition, some
data might be left in an improper state. Some variables are reset in start( ) to make sure
the applet restarts with a new transition.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1015
A
P
P
LY
IN
G
JA
V
A
In start( ), the mouse cursor is changed to a hand so that when the mouse cursor is
over the applet, it will appear to be a link.
run( )
The run( ) method starts with a loop that waits for the first image to be fully loaded
before proceeding. It then finishes the initialization of the applet by calling
finishInit( ). From there, it enters the main loop of the program.
This main loop drives the transitions between billboards. Using the delay
parameter passed in from the HTML to the applet, the applet calculates when the next
transition is supposed to be run. While it is waiting, it prepares for the transition. It
starts the preparation by determining which billboard is to be displayed next, parsing
the billboard data from HTML parameters if this has not been done yet for this
billboard. Then it randomly chooses which transition to run next, being careful not to
let the applet run the same transition consecutively.
Once the applet has determined what transition will be run next, it creates a new
instance of this transition class by dynamically loading the class using the String name
and then creating a new instance of the class. The dynamic loading of the transition
classes has a big impact on the loading time of the applet as a whole. Instead of every
single class having to be downloaded before the applet starts, only three classes are
sent initially: DynamicBillboard, BillData, and BillTransition. The other transition
classes are only downloaded by the applet the first time they are needed. This reduces
the initial download of the applet significantly. Some class files might not even need to
be sent if the user leaves the page quickly.
Finally, the applet calls the init( ) method on the transition object, passing the
applet and image pixels for the current and next billboard as parameters. This creates
all the cell frames that are used to animate a transition. With the transition ready to go,
the applet only need wait for the proper time to start the transition.
The applet performs the transition by using simple frame animation—drawing each
cell in order onto the screen, with a short delay between each frame. The applet calls
the toolkit method sync( ) just to be sure that the drawing of one cell does not take
place before the previous cell has been shown on the screen. After the last cell is
displayed, the applet draws the image from the next billboard onto the screen to
complete the transition.
Following this, the mouse_over_applet flag is checked to see if the mouse cursor
is currently over the applet. If so, the URL of the previous billboard is showing on the
status bar and must be updated to reflect the URL of the new billboard. This is done
with a call to the applet method showStatus( ). The applet has completed this
transition and is now ready to begin the next one.
mouseMoved( ) and mouseExited( )
mouseMoved( ) and mouseExited( ) are used to change the text that appears on the
status bar. When the mouse cursor is over the applet, the status bar is supposed to
show the URL that the current billboard links to. So when mouseMoved( ) gets called,
1016 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
the applet shows the URL on the status bar. When mouseExited( ) is called, the URL
text is removed from the status bar. Both methods also set the Boolean mouse_inside_
applet to the appropriate value. This variable is used in the run( ) method after a
transition is run. If the mouse is positioned over the applet when the transition
completes, then the applet knows to show the URL of the new billboard on the
status bar.
mouseReleased( )
When the mouse button is pressed with the cursor over the applet and then released,
the mouseReleased( ) method is called. The applet uses getAppletContext( ).show-
Document( ) to send the browser to the URL that the current billboard points to. As
Robert found out, sometimes browsers take a long time to display this new page. To
keep the applet from running more transitions while the new page is waiting to load,
stop( ) is called to force the main thread to quit. To let users know that the applet is
loading the new page, the applet changes the mouse cursor to the wait cursor.
It is important to remember that users can come back to this page after going to a
new page. The wait cursor will still be present on the applet when users come back.
The start( ) method is always called when the user comes back to a page with an
applet, so the applet resets the cursor to the hand cursor there.
The Code
Here is the source code for the DynamicBillboard class:
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.awt.*;
import java.awt.image.*;
public class DynamicBillboard
extends java.applet.Applet
implements Runnable {
BillData[] billboards;
int current_billboard;
int next_billboard;
String[] transition_classes;
Thread thread = null;
Image image = null;
long delay = -1;
boolean mouse_inside_applet;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1017
A
P
P
LY
IN
G
JA
V
A
String link_target_frame;
boolean stopFlag;
public void init() {
String s = getParameter("bgcolor");
if(s != null) {
Color color = new Color(Integer.parseInt(s.substring(1), 16));
setBackground(color);
getParent().setBackground(color);
getParent().repaint();
}
billboards = new
BillData[Integer.parseInt(getParameter("billboards"))];
current_billboard = next_billboard
= (int)(Math.random() *billboards.length);
parseBillData();
}
void parseBillData() {
String s = getParameter("bill" + next_billboard);
int field_end = s.indexOf(",");
Image new_image = getImage(getDocumentBase(),
s.substring(0, field_end));
URL link;
try {
link = new URL(getDocumentBase(),
s.substring(field_end + 1));
}
catch (java.net.MalformedURLException e) {
e.printStackTrace();
link = getDocumentBase();
}
billboards[next_billboard] = new BillData(link, new_image);
if(image == null) {
image = new_image;
}
else {
prepareImage(new_image, this);
billboards[next_billboard].initPixels(getSize().width,
getSize().height);
}
1018 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}void finishInit() {
if(delay != -1) {
return;
}
delay = Long.parseLong(getParameter("delay"));
link_target_frame = getParameter("target");
if(link_target_frame == null) {
link_target_frame = "_top";
}
String s = getParameter("transitions");
int field_end = s.indexOf(",");
int trans_count = Integer.parseInt(s.substring(0, field_end));
transition_classes = new String[trans_count];
for(--trans_count; trans_count > 0; --trans_count) {
s = s.substring(field_end + 1);
field_end = s.indexOf(",");
transition_classes[trans_count] = s.substring(0, field_end);
}
transition_classes[0] = s.substring(field_end + 1);
billboards[next_billboard].initPixels(getSize().width,
getSize().height);
mouse_inside_applet = false;
}
public void paint(Graphics g) {
g.drawImage(image, 0, 0, this);
}
public void update(Graphics g) {
paint(g);
}
public void start() {
next_billboard = current_billboard;
image = billboards[current_billboard].image;
setCursor(new Cursor(Cursor.HAND_CURSOR));
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1019
A
P
P
LY
IN
G
JA
V
A
if(thread == null) {
thread = new Thread(this);
thread.start();
}
}
public void stop() {
if(thread != null) {
stopFlag = true;
}
}
public void run() {
while((checkImage(image, this) & ImageObserver.ALLBITS) == 0) {
try { Thread.sleep(600); } catch (InterruptedException e) {}
}
finishInit();
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
int last_transition_type = -1;
BillTransition transition;
long next_billboard_time;
while(true) {
if(stopFlag)
return;
next_billboard_time = System.currentTimeMillis() + delay;
current_billboard = next_billboard;
if(++next_billboard >= billboards.length) {
next_billboard = 0;
}
if(billboards[next_billboard] == null) {
parseBillData();
try { Thread.sleep(120); } catch (InterruptedException e) {}
}
int transition_type = (int)(Math.random() *
(transition_classes.length - 1));
if(transition_type >= last_transition_type) {
++transition_type;
1020 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}last_transition_type = transition_type;
try {
String trans = transition_classes[last_transition_type];
transition = (BillTransition)Class.forName(trans)
.newInstance();
}
catch(Exception e) {
e.printStackTrace();
continue;
}
transition.init(this,billboards[current_billboard].image_pixels,
billboards[next_billboard].image_pixels);
if(System.currentTimeMillis() < next_billboard_time) {
try {
Thread.sleep(next_billboard_time -
System.currentTimeMillis());
} catch (InterruptedException e) { };
}
Graphics g = getGraphics();
for(int c = 0; c < transition.cells.length; ++c) {
image = transition.cells[c];
g.drawImage(image, 0, 0, null);
getToolkit().sync();
try { Thread.sleep(transition.delay); }
catch(InterruptedException e) { };
}
image = billboards[next_billboard].image;
g.drawImage(image, 0, 0, null);
getToolkit().sync();
g.dispose();
if(mouse_inside_applet == true) {
showStatus(billboards[next_billboard].link.toExternalForm());
}
transition = null;
try { Thread.sleep(120); } catch (InterruptedException e) {}
}
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1021
A
P
P
LY
IN
G
JA
V
A
public class MyMouseAdapter extends MouseAdapter {
public void mouseExited(MouseEvent me) {
mouse_inside_applet = false;
showStatus("");
}
public void mouseReleased(MouseEvent me) {
stop();
setCursor(new Cursor(Cursor.WAIT_CURSOR));
getAppletContext().showDocument(billboards[current_billboard].link,
link_target_frame);
}
}
public class MyMouseMotionAdapter extends MouseMotionAdapter {
public void mouseMoved(MouseEvent me) {
mouse_inside_applet = true;
showStatus(billboards[current_billboard].link.toExternalForm());
}
}
}
BillData.java
The BillData class is mostly just a data structure for encapsulating attributes associated
with individual billboards. It contains three variables. The first variable stores the
URL to which the billboard is a link. The second variable has an Image that the applet
uses to draw on the screen. The third variable includes a pixel array of the image in
RGB format.
The pixel array is used by transitions in combination with another BillData pixel
array to create the cells for transition animation. The array is only one-dimensional.
The pixels in it are arranged in such a way that the first element in this array is the
top-left corner of the image. The second element is the pixel just to the right of this
corner. Elements that follow are the pixels to the right of this one, and so on, until the
rightmost pixel is reached. Then the leftmost pixel on the next line of the image is used.
This continues until the last index in the array, which corresponds to the pixel on the
bottom-right corner of the image.
You might notice that Robert has made all of the variables in this class public.
Normally, it is good programming practice to hide the data members that should be
read only by other classes. This is done by making them protected or private and then
creating functions to return references to the variables. Unfortunately, in Java this
increases the size of the compiled bytecode even when the one line function is made
1022 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
final and the code is compiled with optimizations. So to make the applet smaller and
hence faster to download, Robert made the data members public.
The Constructor
The constructor for a BillData object simply initializes the URL and Image variables
with the two parameters passed in. Initializing the pixel array is done in a separate
method, because it is very processor-intensive. This gives the applet a chance to initialize
the pixel array only when it needs it.
initPixels( )
The initPixels( ) method creates the pixel array from the image using the Java core
class: java.awt.image.PixelGrabber.
The Code
Here is the source code for the BillData class:
import java.net.*;
import java.awt.*;
import java.awt.image.*;
public class BillData {
public URL link;
public Image image;
public int[] image_pixels;
public BillData(URL link, Image image) {
this.link = link;
this.image = image;
}
public void initPixels(int image_width, int image_height) {
image_pixels = new int[image_width * image_height];
PixelGrabber pixel_grabber = new
PixelGrabber(image.getSource(), 0, 0,
image_width, image_height, image_pixels, 0, image_width);
try {
pixel_grabber.grabPixels();
}
catch (InterruptedException e) {
image_pixels = null;
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1023
A
P
P
LY
IN
G
JA
V
A
}}
BillTransition.java
The BillTransition class is used as a base class for other transition classes. These other
classes create transition cells between two individual billboard images. This abstract
class contains variables and methods that are common to all transitions.
There are no constructors provided in the BillTransition class. This is because the
applet does not use “new” to create new instances and instead uses the factory method,
java.lang.Class.newInstance( ). Objects created in this way have no way to directly
initialize themselves using parameters in constructors. This factory method indirectly
creates objects using a default constructor, one without any parameters. The
BillTransition class provides a number of overloaded init( ) methods to initialize
instances with parameters.
In previous versions of DynamicBillboard, Robert used static variables within
different transition classes to store data that only needed to be initialized once. It was
discovered, however, that when more than one instance of the applet ran from a web
server, the applets would share the static variables. This led to some problems if one
applet needed a different static value than the other when the applets were different
sizes. An example is the FadeTransition class used to create an array whose size
depended on the dimensions of the applet. When another DynamicBillboard was
created with dimensions that were smaller than the previous applet, it would
overwrite this array with an array too small for the first applet. This would cause the
first applet to crash.
Robert introduced the static hash table called object_table in this version of the
applet to work around this problem. Now transition classes can store data inside this
hash table using the transition name in conjunction with the applet size as a key. When
this data needs to be used, the applet can look to see if it exists for the applet’s size
within the hash table. If it does not, then it can create the data and store it in the hash
table for later use. Now if there is more than one applet on a web server and both are
the same size, then only one has to initialize the data.
init( )
The init( ) method is overloaded three times. The first method, which has three
parameters, is abstract and must be overridden by classes derived from this class. The
other two methods initialize data members within this class. Robert’s intention was to
have the init( ) method of classes that are derived from this class call one of these two
methods to initialize data members of BillTransition.
1024 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
createCellFromWorkPixels( )
The createCellFromWorkPixels( ) method is used to perform the common task of
converting the work_pixels array into an Image object. Notice that it uses the owner
variable to complete this task. This is the only reason the owner variable is needed by
transition classes. When a transition has completed assembly of a new cell in the
work_pixels array, it should call this method.
The Code
Here is the source code for the BillTransition class:
import java.util.*;
import java.awt.*;
import java.awt.image.*;
public abstract class BillTransition {
static Hashtable object_table = new Hashtable(20);
public Image[] cells;
public int delay;
Component owner;
int cell_w;
int cell_h;
int pixels_per_cell;
int[] current_pixels;
int[] next_pixels;
int[] work_pixels;
public abstract void
init(Component owner, int[] current_pixels, int[] next_pixels);
final protected void
init(Component owner, int[] current_pixels, int[] next_pixels,
int number_of_cells, int delay) {
this.delay = delay;
this.next_pixels = next_pixels;
this.current_pixels = current_pixels;
this.owner = owner;
cells = new Image[number_of_cells];
cell_w = owner.getSize().width;
cell_h = owner.getSize().height;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1025
A
P
P
LY
IN
G
JA
V
A
pixels_per_cell = cell_w * cell_h;
work_pixels = new int[pixels_per_cell];
}
final protected void
init(Component owner, int[] current_pixels, int[] next_pixels,
int number_of_cells) {
init(owner, current_pixels, next_pixels, number_of_cells, 120);
}
final void createCellFromWorkPixels(int cell) {
cells[cell] = owner.createImage(
new MemoryImageSource(cell_w, cell_h,
work_pixels, 0, cell_w));
owner.prepareImage(cells[cell], null);
}
}
ColumnTransition.java
The ColumnTransition class changes one image into another by drawing increasingly
large columns of the new image onto the old image. The column sizes increase to the
left, and the same pixels are always drawn on the left side of each column. This makes
the billboard appear to be sliding in from behind the old billboard through vertical
slots in the current billboard.
To create the cells for this transition, the billboard space is split up into a number of
columns, each column 24 pixels wide. Each of the seven image cells the transition will
create will have pixels on the left side of each column from the old image and pixels
on the right side from the new image. The first cell that is created starts out with only
the three right pixels in each column taken from the new image. With each successive
cell, three more pixels are filled in from the new image. The last cell has only the three
left pixels in each column from the old image.
Because the width of the image space is most likely not perfectly divisible by 24,
there will be some remaining pixels remaining on the right side of the image. These
pixels are accounted for in each cell with the rightmost_columns_max_width and
rightmost_columns_x_start variables.
init( )
The init( ) function starts by calling the base class’ init( ) method to initialize the variables
contained within this base class. It goes on to initialize the variables associated with the
rightmost column and then copies all of the pixels from the current billboard into the
work pixels. The loop that follows creates all of the cell frames.
1026 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The nextCell( ) method changes work_pixels, and the method inherited from the
BillTransition class, createCellFromWorkPixels( ), is used to convert these pixels into
an image. Because the process of creating the cells can be very demanding on the CPU,
Robert tells the thread to sleep occasionally to allow other threads to run.
nextCell( )
The nextCell( ) method modifies the work_pixels array for the next cell. It loops
through each line of the image starting from the bottom line and fills part of each
column by copying pixels from the next billboard onto the work_pixels array. It does
not ever need to copy pixels from the old billboard, because these were already copied
to the array in the init( ) method.
It’s worth repeating that the pixel arrays used to form the images are only
one-dimensional. Every width pixel represents one horizontal line of the image.
The Code
Here is the source code for the ColumnTransition class:
import java.awt.*;
import java.awt.image.*;
public class ColumnTransition extends BillTransition {
final static int CELLS = 7;
final static int WIDTH_INCREMENT = 3;
final static int MAX_COLUMN_WIDTH = 24;
int rightmost_columns_max_width;
int rightmost_columns_x_start;
int column_width = WIDTH_INCREMENT;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 200);
rightmost_columns_max_width = cell_w % MAX_COLUMN_WIDTH;
rightmost_columns_x_start = cell_w - rightmost_columns_max_ width;
System.arraycopy(current_pixels, 0,
work_pixels, 0, pixels_per_cell);
for(int c = 0; c < CELLS; ++c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
NextCell();
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1027
A
P
P
LY
IN
G
JA
V
A
try { Thread.sleep(100); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
column_width += WIDTH_INCREMENT;
}
work_pixels = null;
}
void NextCell() {
int old_column_width = MAX_COLUMN_WIDTH - column_width;
for(int p = pixels_per_cell - cell_w; p >= 0; p -= cell_w) {
for (int x = 0; x < rightmost_columns_x_start; x +=
MAX_COLUMN_WIDTH) {
System.arraycopy(next_pixels, x + p, work_pixels,
old_column_width + x + p, column_width);
}
if(old_column_width <= rightmost_columns_max_width) {
System.arraycopy(next_pixels, rightmost_columns_x_start + p,
work_pixels, rightmost_columns_x_start +
old_column_width + p - 1,
rightmost_columns_max_width -
old_column_width + 1);
}
}
}
}
Here is what the column transition looks like before, during, and after:
1028 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
FadeTransition.java
The FadeTransition class changes one image into another by randomly including a
number of new pixels from the next billboard in each successive cell frame. This makes
the next billboard appear to fade in over the old billboard.
The heart of this transition is a two-dimensional array of short integers called
random. This array holds an index for every element in the next billboard’s image pixel
array. These indexes are randomly distributed in the two-dimensional array. The eight
elements in the first dimension of this array will be used when cells are created, one for
each new cell. The last element is never actually used, because there are only seven
cells. It is included when the random array is created to ensure that the indexes are
randomly distributed correctly.
The FadeTransition uses this array to pick pixels from the next billboard to
overwrite pixels of the old billboard. For the first cell, the work_pixels array contains
nothing but pixels from the old billboard. One-eighth of these pixels get changed to
the next billboard’s pixels. For the following cell, the same work_pixels array is used,
and one-eighth more pixels are filled in from the next billboard. For this cell the
result has one-fourth of the pixels from the next billboard, while the remainder are
from the old billboard. This continues until the last cell, cell number seven, which has
seven-eighths of its pixels from the new billboard. Remember, the DynamicBillboard
applet simply uses the whole image from the next billboard after the last cell to
complete the transition.
Because the size of this two-dimensional array is dependent on the size of the
applet, it must be unique to each applet. Using a static variable to store this array is
unacceptable, because applets of different sizes would share this array. Since it is fairly
time-consuming to create this array, it does not make sense to re-create it every time
this transition is to be used.
This is where the superclass’ static variable, object_table, first comes into play.
Once this array is created, it can be stored in this hash table with a key that includes the
size of the applet. When the array needs to be used, the applet can get the appropriate
one out of the hash table. If it does not exist in the hash table, the applet can then create
the array and store it in the hash table for future use. New applets of the same size as
the current applet will benefit from a usable array already being there. This seems like
a lot of effort, but in practice, web sites tend to use this applet on a large number of
pages with a standard layout size for each banner advertisement. So, it saves an
enormous amount of memory and CPU time to cache these tables.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1029
A
P
P
LY
IN
G
JA
V
A
createRandomArray( )
The createRandomArray( ) static method creates the two-dimensional random array.
It takes two parameters that describe the size of the applet. It is highly optimized,
because originally it was too slow. It includes its own random-number generator that is
very fast, but with a short cycle. Because of this, it is fairly complicated and beyond the
scope of this book. The basic idea is that Java’s built-in random-number generator is
better at generating truly random distribution, but it is too slow for this application.
Plus, the user will not notice exactly how random this transition is, so Robert’s
home-grown random-number generator is sufficient.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. Then, like some other transitions, it copies all of the old
billboard’s pixels into the work_pixels array.
The two-dimensional random array is pulled out of the object_table for an applet
of this size. If it does not exist yet, it is created and stored in the object_table. With the
random array in hand, the method just loops through each cell and each index in the
random array, copying pixels from the next billboard into the work pixels.
The Code
Here is the source code for the FadeTransition class:
import java.awt.*;
import java.awt.image.*;
public class FadeTransition extends BillTransition {
private static final int CELLS = 7;
private static final int MULTIPLIER = 0x5D1E2F;
private static short[][] createRandomArray(int number_pixels,
int cell_h) {
int total_cells = CELLS + 1;
int new_pixels_per_cell = number_pixels / total_cells;
short[][] random = new short[total_cells][new_pixels_per_cell];
int random_count[] = new int[total_cells];
for(int s = 0; s < total_cells; ++s) {
random_count[s] = 0;
}
int cell;
int rounded_new_pixels_per_cell =
new_pixels_per_cell * total_cells;
1030 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
int seed = (int)System.currentTimeMillis();
int denominator = 10;
while((new_pixels_per_cell % denominator > 0 ||
cell_h % denominator == 0) && denominator > 1) {
--denominator;
}
int new_randoms_per_cell = new_pixels_per_cell / denominator;
int new_randoms = rounded_new_pixels_per_cell / denominator;
for(int p = 0; p < new_randoms_per_cell; ++p) {
seed *= MULTIPLIER;
cell = (seed >>> 29);
random[cell][random_count[cell]++] = (short)p;
}
seed += 0x5050;
try { Thread.sleep(150); } catch (InterruptedException e) {}
for(int p = new_randoms_per_cell; p < new_randoms; ++p) {
seed *= MULTIPLIER;
cell = (seed >>> 29);
while(random_count[cell] >= new_randoms_per_cell) {
if(++cell >= total_cells) {
cell = 0;
}
}
random[cell][random_count[cell]++] = (short)p;
}
for(int s = 0; s < CELLS; ++s) {
for(int ps = new_randoms_per_cell; ps < new_pixels_per_cell;
ps += new_randoms_per_cell) {
int offset = ps * total_cells;
for(int p = 0; p < new_randoms_per_cell; ++p) {
random[s][ps + p] = (short)(random[s][p] + offset);
}
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1031
A
P
P
LY
IN
G
JA
V
A
try { Thread.sleep(50); } catch (InterruptedException e) {}
}
random[CELLS] = null;
return random;
}
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS);
System.arraycopy(current_pixels, 0, work_pixels,
0, pixels_per_cell);
short random[][] = (short[][])object_table.get(
getClass().getName() + pixels_per_cell);
if(random == null) {
random = createRandomArray(pixels_per_cell, cell_h);
object_table.put(getClass().getName() + pixels_per_cell,
random);
}
for(int c = 0; c < CELLS; ++c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
int limit = random[c].length;
for(int p = 0; p < limit; ++p) {
int pixel_index = random[c][p];
work_pixels[pixel_index] = next_pixels[pixel_index];
}
try { Thread.sleep(50); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
}
work_pixels = null;
}
}
Here is what the fade transition looks like before, during, and after:
1032 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
SmashTransition.java
The SmashTransition class changes one image into another by dropping the new
image onto the old one. The old image appears to crumble under the weight of
the new image.
Two instance variables, drop_amount and location, are used to create the frames.
The location variable keeps track of the pixel that the smashed image starts on. The
drop_amount variable stores the number of pixels of the new image to drop onto the
smashed image every frame. In other words, it is the number to add to the location
variable each frame. A static array called fill_pixels is used to color a whole line of the
work_pixels array white.
The smash effect is done by drawing the old image in an accordion-like fashion.
It starts out by drawing the first lines of the old image offset to the right. Each
progressive line is offset a little bit more to the right. This continues until some
maximum left offset is reached. At this point, the offset is reduced every line until
an offset of zero is reached. This continues until all of the lines of the smashed image
are drawn.
It does not draw the lines from the old image in their entirety. It uses a length that
is a bit shorter than the actual length.
The number of lines to draw for the smashed image decreases each frame as the old
billboard becomes more and more compacted. This transition uses lines that are evenly
distributed across the old image. This ensures that the smashed image does not appear
to be falling off the bottom of the applet or sliding under the new image.
setupFillPixels( )
The setupFillPixels( ) static method is used to ensure that the fill_pixels array is
initialized and is at least as long as one whole line for this applet. If this array has not
been initialized yet or is not long enough for this applet, then this method respectively
re-creates or creates and fills in the array. If there is more than one instance of this
applet running, both can share this fill_pixels array, but it must be at least as long as
the widest applet.
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1033
A
P
P
LY
IN
G
JA
V
A
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. It follows this with a call to the method described earlier,
setupFillPixels( ). The initial values of the drop_amount and location variables are then
calculated. After this, the init( ) method goes into a loop to create each frame. It actually
does this in reverse, creating the last frame first. It does not have to be done in reverse.
However, running loops in reverse saves one byte of code in the resulting class file. After
each cell is created, the location variable is incremented to the next proper location.
Smash( )
The Smash( ) method modifies the work_pixels array for the next cell. It creates the
smashed image of the old billboard in the work_pixels array and draws in the pixels
for the new image. This method takes one parameter, max_fold, which is used as the
maximum right offset that the lines in the fold will have. It is also used by subtracting
this from the line width to determine the length of the lines to draw for the folds.
The method begins by copying the pixels from the new image onto work_ pixels.
It then initializes a number of variables that it uses to draw the smashed image. The
drawing of this smashed image is done line by line, in a loop. Within the loop, it first
makes the current line totally white. It then copies a portion of the correct line from
the old billboard over this line. To get the accordion effect, it does not start drawing
onto the same pixel location as it did for drawing the white line. It instead offsets
the destination pixels to the right by a few pixels. After drawing in the line, it adds a
number to the offset counter. It follows this with a bounds check to see if the offset has
gone beyond the minimum or maximum offset. If it has, it flips the sign of the number
it adds to the offset counter each line. The effect of this is that the direction of the offset
is reversed.
The Code
Here is the source code for the SmashTransition class:
import java.awt.*;
import java.awt.image.*;
public class SmashTransition extends BillTransition {
final static int CELLS = 8;
final static float FOLDS = 8.0f;
static int[] fill_pixels;
static void setupFillPixels(int width) {
if(fill_pixels != null && fill_pixels.length <= width) {
return;
1034 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}fill_pixels = new int[width];
for(int f = 0; f < width; ++f) {
fill_pixels[f] = 0xFFFFFFFF;
}
}
int drop_amount;
int location;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 160);
setupFillPixels(cell_w);
drop_amount =  (cell_h / CELLS) * cell_w;
location = pixels_per_cell - ((cell_h / CELLS) / 2) * cell_w;
for(int c = CELLS - 1; c >= 0; --c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
Smash(c + 1);
try { Thread.sleep(150); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
location -= drop_amount;
}
work_pixels = null;
}
void Smash(int max_fold) {
System.arraycopy(next_pixels, pixels_per_cell - location,
work_pixels, 0, location);
int height = cell_h - location / cell_w;
float fold_offset_adder = (float)max_fold * FOLDS / (float)height;
float fold_offset = 0.0f;
int fold_width = cell_w - max_fold;
float src_y_adder = (float)cell_h / (float)height;
float src_y_offset = cell_h - src_y_adder / 2;
for(int p = pixels_per_cell - cell_w; p >= location; p -=
cell_w) {
System.arraycopy(fill_pixels, 0, work_pixels, p, cell_w);
System.arraycopy(current_pixels, (int)src_y_offset * cell_w,
work_pixels, p + (int)fold_offset, fold_width);
src_y_offset -= src_y_adder;
fold_offset += fold_offset_adder;
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1035
A
P
P
LY
IN
G
JA
V
A
if(fold_offset < 0.0 || fold_offset >= max_fold) {
fold_offset_adder *= -1.0f;
}
}
}
}
Here is what the smash transition looks like before, during, and after:
TearTransition.java
The TearTransition creates the illusion of the current billboard getting torn off the
applet like a piece of paper. It gets ripped upwards and toward the left to reveal the
next billboard image underneath.
There is only one member variable used in this transition, x_cross. It is used as a
multiplier to create the tear effect. The larger the value of this variable, the smaller the
tear effect will appear to be.
The code for this transition has many optimizations. One optimization of
significance is to create the cell frames in reverse order, building the last cell frame first
and the first, last. In their normal order, each subsequent cell frame reveals a little bit
more of the new image underneath. If the frames were to be created in the normal
order, the tear effect would have to be drawn, along with the new image pixels
revealed in the current frame, which had been covered by the tearing effect in the
previous frame. Doing it in reverse only requires redrawing the tearing effect each cell
1036 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
frame. For example, the last frame, created first, starts out with the tearing effect using
only a small portion of the upper-left corner of the image, while the rest of the pixels
are taken from the new billboard image. In the second to the last frame, which is
created second, the new tear effect draws over a little bit more of the upper-left corner
of the image, while the rest of the image remains the same. The cell frames that follow
draw the new tear effect over more and more of the image, but always covering up the
old tear effect from the last frame.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. It then copies all of the new billboard’s pixels into the
work_pixels array and copies the first line of the old billboard’s pixels onto the first
line of the work_pixels array. After the x_cross variable is initialized, the init( ) method
loops through each cell frame in reverse order. Inside the loop, it creates each cell
frame and decreases the value of the x_cross variable.
Tear( )
The Tear( ) method modifies the work_pixels array for the next cell. It draws the tear
effect onto the work pixels. It draws the tear effect line by line. To draw one line, the
method copies pixels from the old image pixels into the work_pixels array. It uses two
counters, one that is an index into the work_pixels array, the destination, and one that
references an index into the array of pixels for the old billboard, the source. Both
counters are started at zero. The destination counter is always incremented by one.
The source counter, however, is incremented by a floating-point number that is always
greater than one. When the loop is run until the destination index is larger than the
width of the line, the result is the source index growing faster than the destination
index. The overall effect is that in the destination, only a number of pixels on the left
side of the image will be copied from the source. The pixels taken from the source will
skip some pixels, resulting in pixels taken from the source being evenly distributed
across the line.
Each line of the cell frame will use a larger value for the floating-point number on
the line above. This makes lines toward the bottom draw on fewer pixels for the tear
effect than lines toward the top.
This method has one big optimization that it uses to get around the slow array
indexing in Java. Whenever a element in an array is used, bounds checking is done
to ensure that the index is within the bounds of the array. There is a performance hit
involved in this bounds checking. The standard Java class, System, provides a method
that allows you to copy sections of arrays from one array to another almost as fast or as
fast as copying one array element into another. This method is used to speed up the
creation lines within the cell frames. It only uses this method when the applet knows
some of the source pixels will be adjacent to one another. If the applet skips at least
every other pixel from the source image, then it will use the standard loop method.
An x_increment value less than 0.5 indicates that less than 1.5 will be added to the
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1037
A
P
P
LY
IN
G
JA
V
A
source index counter each time, and there will be a speed benefit from using the array
copy method for a particular line.
The Code
Here is the source code for the TearTransition class:
import java.awt.*;
import java.awt.image.*;
public class TearTransition extends BillTransition {
static final int CELLS = 7;
static final float INITIAL_X_CROSS = 1.6f;
static final float X_CROSS_DIVISOR = 3.5f;
float x_cross;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS);
System.arraycopy(next_pixels, 0, work_pixels, 0,
pixels_per_cell);
System.arraycopy(current_pixels, 0, work_pixels, 0, cell_w);
x_cross = INITIAL_X_CROSS;
for(int c = CELLS - 1; c >= 0; --c) {
try { Thread.sleep(100); } catch (InterruptedException e) {}
Tear();
try { Thread.sleep(150); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
x_cross /= X_CROSS_DIVISOR;
}
work_pixels = null;
}
final void Tear() {
float x_increment;
int p, height_adder;
p = height_adder = cell_w;
for (int y = 1; y < cell_h; ++y) {
x_increment = x_cross * y;
if(x_increment >= 0.50f) {
float fx = 0.0f;
1038 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
x_increment += 1.0f;
int x = 0;
do {
work_pixels[p++] = current_pixels[height_adder + x];
x = (int)(fx += x_increment);
} while(x < cell_w);
}
else {
float overflow = 1.0f / x_increment;
float dst_end = overflow / 2.0f  + 1.49999999f;
int dst_start = 0, src_offset = 0, length = (int)dst_end;
while(dst_start + src_offset + length < cell_w) {
System.arraycopy(current_pixels, p + src_offset,
work_pixels, p, length);
++src_offset;
dst_end += overflow;
p += length;
dst_start += length;
length = (int)dst_end - dst_start;
}
length = cell_w - src_offset - dst_start;
System.arraycopy(current_pixels, p + src_offset,
work_pixels, p, length);
}
p = height_adder += cell_w;
}
}
}
Here is what the tear transition looks like before, during, and after:
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1039
A
P
P
LY
IN
G
JA
V
A
UnrollTransition.java
UnrollTransition makes it appear as if a rolled-up poster is placed on the bottom of the
applet and then unrolled upward, gradually revealing the next image and covering
the old image. To enhance the unroll illusion, the roll gradually decreases in size as it
makes its way upward on the billboard.
Two instance variables are used during the creation of unroll transitions. The
location variable references pixels within the pixel arrays. It stores the current pixel
that the roll first appears on. The unroll_amount array variable tells the class how
many vertical pixels the roll should move upward each frame.
The most difficult part of creating each cell frame is drawing the roll. The only
other task that needs to be completed each frame is to draw the pixels from the new
image onto the space vacated by the roll from the previous frame.
The roll is drawn with scan lines from the new image. The first line of the roll is
drawn with the scan line located at the Y coordinate above the roll’s Y coordinate on
the applet. For example, if the roll is located on line ten for a particular cell frame,
then line nine of the new image will be used to draw the first line of the roll. Each
subsequent line of the roll is drawn using a line from the image located above the
previous line of the new image. So, continuing the example, the second line of the roll
will be drawn using line eight of the new image.
The roll is painted with its 3-D appearance by drawing each line of the roll with a
slight offset to the left. Lines closer to the center of the roll are drawn with a larger
offset than lines close to the top and bottom. The top and bottom lines of the rolls are
then shaded to make it look as if a light were above the applet. This results in the top
line being a bit brighter than the rest of the roll and the bottom line being a bit darker.
createUnrollAmountArray( )
Each consecutive cell frame in this transition unrolls the roll onto the applet a little
bit less than the previous cell frame. The createUnrollAmountArray( ) static method
is used to calculate an array that indicates how much each cell frame should unroll
the roll.
init( )
The init( ) method for this transition starts like all other transitions, with a call to the
base class’ init( ) method. Then the location variable is initialized to an index past the
last pixel in a pixel array. This is followed by copying all of the old billboard’s pixels
into the work_pixels array.
1040 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
An array that stores the number of pixels to unroll each frame is pulled out of the
object_table for an applet of this height. If it does not exist in the hash table, it is
created and stored in the object_table.
Then the init( ) method loops through each cell, moving the roll upward by
subtracting from the location variable and drawing each cell frame. It makes the
current thread take a break before and after the processor-intensive cell frame
creation, to allow other threads in Java’s multitasking environment to execute.
After the cell frame is created from the work_pixels array with the call to the
createCellFromWorkPixels( ) method, the area the roll was on is drawn over with
pixels from the new image. This prepares the work_pixels array for the next cell frame.
Unroll( )
The Unroll( ) method modifies the work_pixels array for the next cell. It draws the roll
onto the work pixels. This method first calculates the offset that it needs to use for
drawing each line of the roll. It then loops through each line of the roll, copying scan
lines from the new image onto the work_pixels array. The pixels that are exposed due
to the left offset of each line are filled in with pixels from the static fill_pixels array.
Another loop then increments though each pixel on the top and the bottom lines of
the roll, brightening pixels on the top line and darkening pixels on the bottom line.
The Code
Here is the source code for the UnrollTransition class:
import java.awt.*;
import java.awt.image.*;
public class UnrollTransition extends BillTransition {
final static int CELLS = 9;
static int fill_pixels[] = { 0xFFFFFFFF, 0xFF000000,
0xFF000000, 0xFFFFFFFF };
private static int[] createUnrollAmountArray(int cell_h) {
float unroll_increment =
((float)cell_h / (float)(CELLS + 1)) /
((float)(CELLS + 2) / 2.0f);
int total = 0;
int unroll_amount[] = new int[CELLS + 1];
for(int u = 0; u <= CELLS; ++u) {
unroll_amount[u] = (int)(unroll_increment * (CELLS - u + 1));
total += unroll_amount[u];
}
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1041
A
P
P
LY
IN
G
JA
V
A
if(total < 0) {
unroll_amount[0] -= 1;
}
return unroll_amount;
}
int location;
int[] unroll_amount;
public void init(Component owner, int[] current, int[] next) {
init(owner, current, next, CELLS, 220);
location = pixels_per_cell;
System.arraycopy(current_pixels, 0,
work_pixels, 0, pixels_per_cell);
unroll_amount = (int[])object_table.get(getClass().getName() +
cell_h);
if(unroll_amount == null) {
unroll_amount = createUnrollAmountArray(cell_h);
object_table.put(getClass().getName() + cell_h, unroll_amount);
}
for(int c = 0; c < CELLS; ++c) {
location -= unroll_amount[c] * cell_w;
try { Thread.sleep(150); } catch (InterruptedException e) {}
Unroll(c);
try { Thread.sleep(100); } catch (InterruptedException e) {}
createCellFromWorkPixels(c);
System.arraycopy(next_pixels, location,
work_pixels, location,
unroll_amount[c] * cell_w);
}
work_pixels = null;
}
void Unroll(int c) {
int y_flip = cell_w;
int offset[] = new int[unroll_amount[c]];
for(int o = 0; o < unroll_amount[c]; ++o) {
offset[o] = 4;
}
offset[0] = 2;
1042 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
if(unroll_amount[c] > 1) {
offset[1] = 3;
}
if(unroll_amount[c] > 2) {
offset[unroll_amount[c] - 1] = 2;
}
if(unroll_amount[c] > 3) {
offset[unroll_amount[c] - 2] = 3;
}
int offset_index = 0;
int end_location = location + unroll_amount[c] * cell_w;
for(int p = location; p < end_location; p += cell_w) {
System.arraycopy(next_pixels,
p - y_flip + offset[offset_index],
work_pixels,
p, cell_w - offset[offset_index]);
System.arraycopy(fill_pixels, 0,
work_pixels,
p + cell_w - offset[offset_index],
offset[offset_index]);
++offset_index;
y_flip += cell_w + cell_w;
}
for(int x = location + cell_w - 1; x > location; --x) {
work_pixels[x] |= 0xFFAAAAAA;
work_pixels[x + unroll_amount[c]] &= 0xFF555555;
}
}
}
Here is what the unroll transition looks like before, during, and after:
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1043
A
P
P
LY
IN
G
JA
V
A
Dynamic Code
Robert has shown us how to create interactive high-performance graphics by
working around many of the apparent limitations in Java. He shows how to use
System.arraycopy( ) to effectively shuffle pixel data around. He shows how to properly
use cooperative multithreading to do computation and network transfers in the
background while the user isn’t waiting. Robert proves that high-performance direct
pixel manipulation algorithms can be efficiently written in Java if you are careful.
In addition to containing interesting code, DynamicBillboard is a very compelling
applet for nonprogrammers and users alike. It is easily configured by HTML editors,
extensible by Java programmers, and entertaining to web users. In this age of
advertising rates being driven by “click-through,” where advertisers only want to pay
for transfers from a content site to their site, Robert’s applet can be used to increase
traffic and ultimately increase revenue.
1044 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 9 : T h e D y n a m i c B i l l b o a r d A p p l e t 1045
A
P
P
LY
IN
G
JA
V
A
1046 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Chapter 30
ImageMenu: An
Image-Based Web Menu
1047
The ImageMenu applet is a simple program that presents an image-based menuwith an arbitrary number of choices in a vertical list. When the user moves themouse cursor over these choices, the one under the cursor changes appearance,
indicating that it can be clicked on. When the user clicks on a choice, the web browser
changes to a new document specified for that choice. ImageMenu was created by
David LaVallée, the creator of several interesting applets. Figure 30-1 shows an
instance of ImageMenu.
ImageMenu uses the showDocument( ) function in AppletContext to make the
hypertext leap to the new pages. The novelty of ImageMenu is that it uses different
portions of a single source image to draw the menu on the screen. Basing a menu on
an image rather than on text frees you to design menus that use any font or image you
desire. You can also provide various types of selection feedback. You no longer need to
rely on the AWT’s limited rendering functions.
1048 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 30-1. An example of ImageMenu
The ImageMenu applet was inspired by an applet called Navigation, created by
top-notch Java programmer Sean Welch. The difference between Navigation and
ImageMenu is efficiency in bandwidth and applet tag specification. The Navigation
applet uses a source image that is the applet’s width times the number of possible
selections wide to display all of its states. Both applets download a single image, which
is much more efficient over the Internet than loading multiple files. A menu of seven
choices for the Navigation applet (100×140 pixels) would require a source image of
700×140. The applet described here, ImageMenu, uses a source image that is two times
the applet width, or 200×140. Most web designers hate typing when they don’t have to,
which leads to the second significant difference between Navigation and ImageMenu:
abbreviated applet parameters.
While ImageMenu is many times more efficient, using a smaller source image and
fewer bytes of parameters, Welch’s Navigation has one inimitable trait—it can display
individually selected “states” that bleed over into the space of the next menu item. The
ImageMenu applet requires that each menu item be self-contained in a rectangular area
that cannot overlap with adjacent items. This would prohibit, for example, ascending
letters (like h) from overlapping descending letters (such as j) in the line above.
The Source Image
While you won’t see the code for Navigation here, looking at its GIF image shows clearly
what it does. The source image for Navigation in Figure 30-2 shows seven columns,
each of which provides a visual representation of a possible selection. However, each
selectable item only has two states, so each row has five redundant copies of the
unselected state.
The source image for ImageMenu is shown in Figure 30-3. Given this image, it is
simple to render any of the seven possible states of a six-choice menu. First, drawImage( )
displays the left half of the source image. This is the state where no items are selected.
If any of the items is selected, then the clipping rectangle is simply set to the bounds of
the selected item, and drawImage( ) is used to display the right-hand side. This will
paint just the selected cell through the clipping rectangle.
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1049
A
P
P
LY
IN
G
JA
V
A
Figure 30-2. The source image for the Navigation applet
The APPLET Tag
The APPLET tag for ImageMenu contains many pieces of information. We will
use java.util.StringTokenizer to read the urlList and the frame targetList parameters
whose values are plus sign–delimited lists of values. We’ll also infer the coordinates of
each menu item by dividing the height of the applet by the number of URLs parsed in
urlList. For readability in the APPLET tag, we also allow a prefix and suffix, which will
be concatenated with a URL when it’s time to move to a new page.
<applet code="ImageMenu" width=140 height=180 hspace=0 vspace=0>
<param name="img" value="menu.jpg">
<param name="urlPrefix"
value="http://www.osborne.com/">
<param name="urlList"
value="pressroom/pressroom.shtml+aboutus/aboutus.shtml+
1050 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 30-3. The source image for ImageMenu
downloads/downloads.shtml+errata/errata.shtml">
<param name="targetList"
value="_self+_self+_self+_self+_self+_self">
<param name="urlSuffix" value="">
</applet>
The Methods
This is a small applet—about 100 lines of Java source. We will walk through all eight
methods here and then show all the source together at the end of the chapter.
init( )
When the applet is being initialized, init( ) saves the size in the Dimension variable d
and parses the applet param tags. It then uses a StringTokenizer to parse strings delimited
by the plus sign to create the string arrays url and target. The number of URLs that are
parsed is the number that is used to divide the vertical space into menu cells. From this
calculation, init( ) saves the number and height of the cells in cells and cellH, respectively.
update( )
We nullify the update( ) method of Applet to avoid flashing. As mentioned in Chapter 23,
the update( ) method in the Applet superclass fills a rectangle with the background color
before calling paint( ). Since we’re not going to use repaint( ), we can just eliminate
update completely.
lateInit( )
The lateInit( ) private method creates the offscreen Image object that will be used for
double buffering the display of the menu. This method also employs a MediaTracker
object to synchronously get the source image.
paint( )
The paint( ) method is quite simple. First, it checks to see if the offscreen buffer has been
created yet. If it hasn’t, lateInit( ) is called to create the buffer and load the menu image.
After that, it draws the left half of the image on the offscreen buffer. This requires,
of course, that the menu image be twice the width of the applet. That way, the applet
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1051
A
P
P
LY
IN
G
JA
V
A
will simply clip away the right half of the menu image when drawImage(img, 0, 0,
null) is called. Then, if any cell is selected (selectedCell >= 0), it sets the clip rectangle
to the bounds of that menu item. You’ll notice that paint( ) gets the graphics context of
the offscreen image every time. This has the effect of resetting the clipping rectangle to
the bounds of the image. AWT’s lack of a resetClip( ) method requires some strange
coding style.
Next, the entire image is painted again, but this time, it is offset by the width of the
applet to the left, via drawImage(img, -d.width, 0, null). This has the effect of placing
just the right highlighted menu item in the clip rectangle. Lastly, the offscreen buffer is
copied to the applet window.
The speed of most graphic displays is largely throttled by the speed of the CPU’s
access directly to the screen. Additionally, many modern display cards are optimized for
copying rectangular areas from memory to the display in support of windowing systems.
Therefore, you are much better off doing all your drawing on an offscreen buffer rather
than copying the bits to the screen. On similar PC systems, we have seen between 10
and 400 buffer changes a second, depending on pixel depth and display card architecture.
mouseExited( )
Special handling is needed for mouseExited( ), because it causes all of the menu items
to be unselected. All we have to do is set selectedCell and oldCell to –1, which makes
the subsequent paint( ) call show all the items as unselected. Having oldCell set to –1
means that the next time the mouse enters the applet and causes a mouseMoved( ) call,
the first item will paint properly.
mouseDragged( )
The mouseDragged( ) method is called when the mouse moves with any of its buttons
pressed. In this applet, we want to do the same thing on drag or move, so we just call
mouseMoved( ) directly, passing in the same parameters we received.
mouseMoved( )
Whenever the mouse moves, mouseMoved( ) checks the y coordinate to see which of the
cells was selected. If the selectedCell is different from oldCell, meaning the user moved
from one cell to another, the menu is repainted. This is an optimization that avoids the
constant repainting of identical screen bits every time the mouse moves. You will notice
that repaint( ) is not called here. We are taking a shortcut through the normal applet
protocol by calling paint( ) directly after fetching the Graphics context from
1052 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
getGraphics( ). This makes for a much snappier response. After the menu is painted,
the status line is set to reflect the newly selected item, which is also saved in oldCell.
mouseReleased( )
mouseReleased( ) sends the browser to the URL that corresponds to the currently selected
menu item. The desired URL is then constructed. If the URL was improperly formatted
in the APPLET tag, the exception is displayed on the status line and returned without
attempting to switch documents. The showDocument( ) method puts the document
described in the URL into the frame listed in the target array. As a final feature, the
state of this SHIFT key is checked by calling the isShiftDown( ) method of MouseEvent.
If SHIFT was pressed, the URL is opened into a new blank browser window instead of
the one specified in target.
The Code
The source code for ImageMenu is shown here:
import java.awt.* ;
import java.awt.event.*;
import java.applet.*;
import java.util.*;
import java.net.*;
public class ImageMenu extends Applet {
Dimension d;
Image img, off;
Graphics offg;
int MAXITEMS = 64;
String url[] = new String[MAXITEMS];
String target[] = new String[MAXITEMS];
String urlPrefix, urlSuffix;
int selectedCell = -1;
int oldCell = -1;
int cellH;
int cells;
public void init() {
d = getSize();
urlPrefix = getParameter("urlPrefix");
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1053
A
P
P
LY
IN
G
JA
V
A
urlSuffix = getParameter("urlSuffix");
StringTokenizer st;
st = new StringTokenizer(getParameter("urlList"), "+");
int i=0;
while(st.hasMoreTokens() && i < MAXITEMS)
url[i++] = st.nextToken();
cells = i;
cellH = d.height/cells;
st = new StringTokenizer(getParameter("targetList"), "+");
i=0;
while(st.hasMoreTokens() && i < MAXITEMS)
target[i++] = st.nextToken();
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
private void lateInit() {
off = createImage(d.width, d.height);
try {
img = getImage(getDocumentBase(), getParameter("img"));
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
} catch(Exception e) {
showStatus("error: " + e);
}
}
public void update(Graphics g) {}
public void paint(Graphics g) {
if(off == null)
lateInit();
offg = off.getGraphics();
offg.drawImage(img, 0, 0, this);
if (selectedCell >= 0) {
offg.clipRect(0, selectedCell * cellH, d.width, cellH)
offg.drawImage(img, -d.width, 0, this);
}
1054 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
g.drawImage(off, 0, 0, this);
}
class MyMouseMotionAdapter extends MouseMotionAdapter {
public void mouseDragged(MouseEvent me) {
mouseMoved(me);
}
public void mouseMoved(MouseEvent me) {
int y = me.getY();
selectedCell = (int)(y/(double)d.height*cells);
if (selectedCell != oldCell) {
paint(getGraphics());
showStatus(urlPrefix + url[selectedCell] + urlSuffix);
oldCell = selectedCell;
}
}
}
class MyMouseAdapter extends MouseAdapter {
public void mouseExited(MouseEvent me) {
selectedCell = oldCell = -1;
paint(getGraphics());
showStatus("");
}
public void mouseReleased(MouseEvent me) {
URL u = null;
try {
u = new URL(urlPrefix + url[selectedCell] + urlSuffix);
} catch(Exception e) {
showStatus("error: " + e);
}
if (me.isShiftDown())
getAppletContext().showDocument(u, "_blank");
else
getAppletContext().showDocument(u, target[selectedCell]);
}
}
}
C h a p t e r 3 0 : I m a g e M e n u : A n I m a g e - B a s e d W e b M e n u 1055
A
P
P
LY
IN
G
JA
V
A
Summary
In use, the ImageMenu applet can look great and it provides a lot of leverage for a very
small program. Use of the showDocument(URL u, String target) in this applet allows
for a subtle optimization in web page design. If you put an ImageMenu applet in a
frame in an HTML frameset and use it to send documents to a second frame, the applet
never has to be reloaded, which makes the user’s experience better.
1056 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Chapter 31
The Lavatron Applet:
A Sports Arena Display
1057
Lavatron is a sports arena lightbulb display. Normally, an applet doesn’thave much of a history, but this one does. David LaVallée, the author of theImageMenu applet from Chapter 30, wanted to achieve this kind of effect for a
long time. The history of Lavatron begins way back in 1974, when LaVallée was the
stick boy for the California Golden Seals of the NHL. David recalls, “Our scoreboard
just displayed, well, the score. The game was the thing; there wasn’t much to distract
hockey fans other than the dah-dah-dah-dat-dah-dah of the organ player.”
In 1979, LaVallée became fascinated with the idea of a graphical programmable
scoreboard when he was the repair guy for the Digital Equipment Corporation PDP
11/34 that ran the scoreboard at the Canadian National Exhibition Stadium (where
the Toronto Blue Jays used to play). That scoreboard was based on plain old 100-watt
lightbulbs like you use at home. In 1991, Toronto was treated to the Sony Jumbotron
HDTV scoreboard at the Skydome: true color, images, video, and three times the height
of the Hard Rock Cafe. In 1992, LaVallée wrote the first version of Lavatron in Objective-
C and PostScript. Finally, in 1995, Lavatron was written again from scratch to run under
Java, and it has undergone several performance tweaks and iterations since. The version
shown here has been updated for Java 2.
There are many possible enhancements to Lavatron (see Figure 31-1) that you
might want to try, such as drawing the source image dynamically in memory rather
than downloading it, or scrolling an animated sequence. But it’s an interesting
animated display applet that you may find useful as is.
1058 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 31-1. The Lavatron applet in action. The source image contains a bitmap
of the title Java 2: The Complete Reference on a white background.
How Lavatron Works
Lavatron is able to present an interesting image onscreen because of a small trick that it
employs, and its side effect allows the applet to load very quickly. The reason it loads
so quickly is that there isn’t much data transmitted over the Net. The source image is a
JPEG image that is 64 times smaller than the displayed image. Each pixel in the source
image is scaled up to an 8×8-pixel square. Here is the trick that Lavatron uses to
produce the lightbulb effect. An 8×8-pixel image of a transparent circle surrounded by
a black bezel, with a white highlight for a dash of style, is painted over the scaled-up
color pixel. As an optimization, the bulbs are preassembled into an image that can be
painted once for each column. Figure 31-2 shows what the bulb mask looks like blown
up. The two white pixels are the highlight. The black pixels in the corner are opaque.
Finally, all of the gray pixels in the middle are transparent, to allow the lightbulb color
to show through.
Lavatron paints so fast because it doesn’t have to repaint what it has already drawn.
The technique of copying the area of the screen that’s good and painting just the portion
that’s new is used in many common operations involving scrolling. The awt.Graphics
function copyArea( ) takes a portion of an image defined by a rectangle and moves it
by an x,y offset from its starting location. As a graphics speed optimization, copyArea( )
is hard to beat. It consistently outperforms any other technique of image rendering,
such as the use of drawImage( ), or drawImage( ) through a clipRect( ). Building an
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1059
A
P
P
LY
IN
G
JA
V
A
Figure 31-2. A blown-up light bulb image
image much larger than your applet, which has several source images concatenated
into a single image, and then using copyArea to move them into place and clipping the
result onscreen is a very fast Java rendering technique.
The Source Code
Lavatron starts by initializing data, which includes loading the source image and
creating the column of bulb images. The last stage of the initialization is painting the
offscreen (double buffer) image full of dimmed (black) lightbulbs to start the display
with a clean image. Subsequent painting of the offscreen image begins by using
copyArea( ) to move the existing portion of the image to the left by the width of the
column of bulbs about to be added on the right edge. Then the pixel values for the next
column are read and used as the color to fill a column of 8×8 rectangles at the right
edge of the applet. The transparent column of bulbs is painted, and then the whole
backing image is drawn to the screen. Since this applet doesn’t have to do much except
scroll the image, it avoids the normal repaint( ) loop by forking a thread that repeatedly
calls paint( ), pausing only to call yield( ) to allow other threads to run.
The APPLET Tag
The source code starts with the APPLET tag for Lavatron, shown here. This applet
looks best when the width is an even multiple of the bulb size and the height is the
bulb size times the source image height. The only parameter is for the name of the
source image file, named in img.
<applet code=Lavatron.class width=560 height=128>
<param name="img" value="swsm.jpg">
</applet>
Lavatron.java
The main applet is small, about 100 lines of Java source code. However, there is also
a support class that is required, which is described in the next section.
init( )
The init( ) method first determines the size of the applet by using getSize( ), and then
rounds up the size to a multiple of the bulb size, specified by bulbS, and stores it in
offw,offh. It then creates an image that size, called offscreen, for use as a double
buffer for the display. The Graphics object used for drawing on offscreen is saved
in offGraphics. The size of the applet, in bulb units rather than pixels, is stored in
bulbsW,bulbsH.
Next, the image of a column of bulbs is created by calling createBulbs( ), passing in
the size of the image to create. Then the image named in the img applet parameter is
1060 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
loaded. This is done by passing the result of getImage( ) to MediaTracker’s addImage( )
method, and then calling waitForID( ), which waits until the image is fully loaded
before returning.
To draw the blown-up version of this image, init( ) needs to retrieve the color
information for each pixel in the image. First, it obtains the size of the image, using
getWidth( ) and getHeight( ), saving the width in pixscan. It then assigns pixels to a
new array of pixscan * h integers. Then a PixelGrabber is created. When grabPixels( )
is called, the array is filled in with the color values.
The final step of init( ) is to paint black bulbs on the offscreen image, which makes
the effect more dramatic as the image scrolls from the right side revealing lighted bulbs.
createBulbs( )
The createBulbs( ) method is a helper to init( ). It returns an Image of a stack of bulb
images that can be used to mask out a column of colored squares to make them look
like lit lightbulbs. It is a little tricky, but quite elegant.
First, it allocates the right number of ints in an array to store the pixels. Then, it
declares another array, which is a picture of a single bulb, represented by the numbers
0, 1, and 2. The 0s represent black, the 1s transparent pixels, and the 2s represent the
white highlight. Next, a short array is declared—bulbCLUT (bulb Color Look Up Table).
This maps the 0, 1, and 2 just mentioned into full 32-bit pixel values. The 0xff000000 is
opaque black. The high-order byte is alpha, or transparency. The 0x00c0c0c0 is a fully
transparent light gray, and the 0xffffffff is opaque white.
The for loop runs through each pixel, loading the appropriate 0, 1, or 2 from bulbBits
based on the position in the column. This is achieved by use of the mod (%) operator.
This value is then used to look up the color from bulbCLUT. Given this array of pixels,
createBulbs( ) returns the output of createImage( ), passing in a MemoryImageSource
object prepared with the pixels we just constructed.
color( )
The color( ) method returns the color of the pixel at the x,y position in the source image
as a Color object. Since this applet runs continuously, we decided not to simply create
a new Color object each time a single bulb was painted. This would be abusive of the
garbage-collected heap. Instead, unique Color objects are stored in a hash table. The
maximum number of Color objects in the hash table can be as much as the width times
the height of the source image, but in practice, it is usually much less.
update( )
Lavatron overrides update( ) to do nothing, because we don’t want AWT’s implementation
to cause flicker.
paint( )
The paint( ) method is quite simple. The first step calls copyArea( ) to move all of the
columns to the left by one column’s width. Then a for loop is used to fill the rightmost
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1061
A
P
P
LY
IN
G
JA
V
A
column with rectangles in the Color of the appropriate pixel, using color( ). The bulb
image strip is then painted over the new column. Then the current scrolled position,
scrollX, is updated to be one more to the right, modulo the width, pixscan.
start( ), stop( ), and run( )
When the applet starts, it creates and starts a new Thread called t. This thread will call
run( ), which will keep calling paint( ) as fast as possible, while maintaining the courtesy
of calling yield( ) so that other threads can run. When the applet stop( ) method is
called, stopFlag is set to true. This variable is checked by the infinite loop in the run( )
method. Program control breaks from the loop when stopFlag is true.
A useful enhancement would be to introduce a threshold frame rate, say 30 fps (frames
per second), and change the call to the yield( ) into an appropriate call to sleep( ) if the
rendering is too fast.
The Code
Here is the source code for the Lavatron class:
import java.applet.*;
import java.awt.* ;
import java.awt.image.* ;
public class Lavatron extends Applet implements Runnable {
int scrollX;
int bulbsW, bulbsH;
int bulbS = 8;
Dimension d;
Image offscreen, bulb, img;
Graphics offgraphics;
int pixels[];
int pixscan;
IntHash clut = new IntHash();
boolean stopFlag;
public void init() {
d = getSize();
int offw = (int) Math.ceil(d.width/bulbS) * bulbS;
int offh = (int) Math.ceil(d.height/bulbS) * bulbS;
offscreen = createImage(offw, offh);
offgraphics = offscreen.getGraphics();
bulbsW = offw/bulbS;
bulbsH = offh/bulbS;
1062 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
bulb = createBulbs(bulbS, bulbsH*bulbS);
try {
img = getImage(getDocumentBase(), getParameter("img"));
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
pixscan = img.getWidth(null);
int h = img.getHeight(null);
pixels = new int[pixscan * h];
PixelGrabber pg = new PixelGrabber(img, 0, 0, pixscan, h,
pixels, 0, pixscan);
pg.grabPixels();
} catch (InterruptedException e) { };
scrollX = 0;
// paint black bulbs on the offscreen image
offgraphics.setColor(Color.black);
offgraphics.fillRect(0, 0, d.width, d.height);
for (int x=0; x<bulbsW; x++)
offgraphics.drawImage(bulb, x*bulbS, 0, null);
}
Image createBulbs(int w, int h) {
int pixels[] = new int[w*h];
int bulbBits[] = {
0,0,1,1,1,1,0,0,
0,1,2,1,1,1,1,0,
1,2,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
0,1,1,1,1,1,1,0,
0,0,1,1,1,1,0,0
};
int bulbCLUT[] = { 0xff000000, 0x00c0c0c0, 0xffffffff };
for (int i=0; i<w*h; i++)
pixels[i] = bulbCLUT[bulbBits[i%bulbBits.length]];
return createImage(new MemoryImageSource(w, h, pixels, 0, w));
}
public final Color color(int x, int y) {
int p = pixels[y*pixscan+x];
Color c;
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1063
A
P
P
LY
IN
G
JA
V
A
if ((c=(Color)clut.get(p)) == null)
clut.put(p, c = new Color(p));
return c;
}
public void update() {}
public void paint(Graphics g) {
offgraphics.copyArea(bulbS, 0, bulbsW*bulbS-bulbS, d.height,
-bulbS, 0);
for (int y=0; y<bulbsH; y++) {
offgraphics.setColor(color(scrollX, y));
offgraphics.fillRect(d.width-bulbS, y*bulbS, bulbS, bulbS);
}
offgraphics.drawImage(bulb, d.width-bulbS, 0, null);
g.drawImage(offscreen, 0, 0, null);
scrollX = (scrollX + 1) % pixscan;
}
Thread t;
public void run() {
while (true) {
paint(getGraphics());
try{t.yield();} catch(Exception e) { };
if(stopFlag)
break;
}
}
public void start() {
t = new Thread(this);
t.setPriority(Thread.MIN_PRIORITY);
stopFlag = false;
t.start();
}
public void stop() {
stopFlag = true;
}
}
1064 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
IntHash( )
As mentioned in the preceding section, Color objects are stored in a hash table rather
than creating the same ones over and over. As a further optimization, we created our
own version of Java’s Hashtable class, which uses normal ints as keys rather than
requiring an Object handle.
Integer data needs much less room to store in the pixel array than Color objects,
so we use a hash table as a mechanism to look up Color objects from the integer value
of any individual pixel. Creating Color objects on the fly from the integer value of
each pixel is very expensive, because it creates a lot of memory garbage that must be
collected. One possible solution would be to use a Java Hashtable, except that doing so
would create just as much garbage, since only objects can be used as keys in a standard
Java hash table. Thus, to store an int in Java’s hash table, you would have to create a
new Integer object as a key to be matched. In a high duty cycle applet like Lavatron,
garbage Integer objects would be created by the thousands per second. This is not a
good solution.
The proper solution was to build our own hash table, IntHash, which uses the
integer data type values rather than the Integer object for its keys. IntHash is about 60
lines of code. The IntHash class duplicates the interface of the java.util.Hashtable class
with the exception that the type of the argument to put( ) and get( ) is an int data type
rather than an Object. There’s no need to explain how a hash table works in this
chapter, but suffice it to say that put(42, “Hello”) == get(42).
The Code
Here is the source code for the IntHash class:
class IntHash {
private int capacity;
private int size;
private float load = 0.7F;
private int keys[];
private Object vals[];
public IntHash(int n) {
capacity = n;
size = 0;
keys = new int[n];
vals = new Object[n];
}
public IntHash() {
this(101);
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1065
A
P
P
LY
IN
G
JA
V
A
}private void rehash() {
int newcapacity = capacity * 2 + 1;
Object newvals[] = new Object[newcapacity];
int newkeys[] = new int[newcapacity];
for (int i = 0; i < capacity; i++) {
Object o = vals[i];
if (o != null) {
int k = keys[i];
int newi = (k & 0x7fffffff) % newcapacity;
while (newvals[newi] != null)
newi = (newi + 1) % newcapacity;
newkeys[newi] = k;
newvals[newi] = o;
}
}
capacity = newcapacity;
keys = newkeys;
vals = newvals;
}
public void put(int k, Object o) {
int i = (k & 0x7fffffff) % capacity;
while (vals[i] != null && k != keys[i]) // hash collision.
i = (i + 1) % capacity;
if (vals[i] == null)
size++;
keys[i] = k;
vals[i] = o;
if (size > (int)(capacity * load))
rehash();
}
public final Object get(int k) {
int i = (k & 0x7fffffff) % capacity;
while (vals[i] != null && k != keys[i]) // hash miss
i = (i + 1) % capacity;
return vals[i];
}
1066 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public final boolean contains(int k) {
return get(k)!=null;
}
public int size() {
return size;
}
public int capacity() {
return capacity;
}
}
Hot Lava
This applet is another small example of the kind of amazing performance you can
squeeze out of Java if you are careful and diligent. David LaVallée uses many tricks
to avoid excessive memory allocation and unnecessary calls to AWT drawing
functions. Creating the lightbulb mask image from a small array of integers rather
than a loaded GIF image saves download time and increases flexibility. The use of
paint(getGraphics( )) rather than repaint( ) increases frame rate significantly. The
performance gains from using copyArea( ) over rerendering the image or calling
drawImage( ) are profound. Finally, the creation and use of IntHash makes for that
last performance boost by not forcing the system to garbage-collect as often.
C h a p t e r 3 1 : T h e L a v a t r o n A p p l e t : A S p o r t s A r e n a D i s p l a y 1067
A
P
P
LY
IN
G
JA
V
A
This page intentionally left blank.
Chapter 32
Scrabblet: A Multiplayer
Word Game
1069
Scrabblet is a complete multiplayer, networked, client/server game. It is the mostcomplicated applet in this book, and it handles some of the thorniest issues in Javaprogramming. Scrabblet consists of more than 1,400 lines of code in 11 classes.
Two of these classes are part of the server side of the applet. The other nine are
downloaded to a web browser and act as the simulation of the game. All of the code
elements used in the game have been described in detail in this book. In this chapter,
we will dissect each class and show how easy it is to build a multiplayer game.
Network Security Concerns
Most applets on the Net today don’t do much with the network after they have
been downloaded. One of the reasons is that networking has been made more difficult
in Java out of security concerns. Most Java applet environments, such as Netscape
Navigator and Microsoft Internet Explorer, severely restrict an applet’s use of the
network. This situation is created by TCP/IP’s lack of authentication in its most basic
protocols. This inherent limitation of the Internet is managed carefully by corporations
that want to protect their proprietary data through the use of firewalls. A firewall is a
computer that sits between a private network and the rest of the Internet. All Internet
connections flow through it, and it is able to filter and reject connections and packets,
both incoming and outgoing. This way, if a program on the outside of the firewall
attempts to attach to an internal network port, the firewall can block it. If it weren’t for
the firewall, system administrators would have to audit the security of each machine
on their internal network. In the case of a firewall-protected network, only the firewall
needs to be secure, and every machine inside is considered “friendly” and left
unprotected from every other machine inside.
This is where Java could have posed a security threat. If Java-enabled browsers
allowed applets to connect to arbitrary Internet addresses, then an applet could act as
a proxy to some malicious program on the outside of the firewall. Once an applet had
been downloaded and automatically run by the web browser, it could then connect to
the neighboring computers and servers. These computers would not expect anything
hostile to come from an internal computer, so they would accept the connections. The
applet would then be free to steal sensitive data and transmit it back through the
firewall to the malicious Internet host.
Because of this scenario, applets are only allowed to make network connections
to exactly one host: the one they were loaded from. This restricts the applet from
snooping around the internal network. One of the many well-publicized “Java security
attacks” from researchers at Princeton University was a way of tricking a Java run-time
system into allowing an applet to open network sockets on otherwise forbidden
machines. Thankfully, this problem was very difficult to reproduce and has
subsequently been addressed.
What does security have to do with a multiplayer game? Plenty. The easiest way to
program a multiplayer game would be to have the players communicate directly with
1070 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
each other, in a “peer-to-peer” network. This way, playing the game would not rely on
having any particular server software running. Unfortunately, the applet is only able to
connect back to the server that it was loaded from. This means that two players have to
communicate all of their messages to each other via the server.
In this chapter, you will see the source code to a simple server, which manages a list
of connected clients and passes messages between those clients. For the most part, this
server knows nothing about the game being played. It just passes the messages blithely
from point A to point B. This function is handled by two classes, Server and
ClientConnection. They will be described at the end of this chapter.
The Game
Before users can play a multiplayer game, they must choose somebody to play against.
Rather than forcing a phone call to arrange a game, this applet takes a different approach.
When it is first run, it prompts the user to enter his or her name (see Figure 32-1). This
name is passed to the server, which broadcasts the player’s name to all other potential
competitors. The user then sees a list of all available players (see Figure 32-2), selects
one, and clicks on the Challenge button. Currently, there is no way to confirm or deny
a challenge; they are automatically accepted. Once a challenge is made, both players
see the game board appear, and all other competitors simply see both players’ names
disappear from the available list.
It is quite an easy game to play, but it is very difficult to win against a skilled
opponent. Players are presented with a 15×15 grid of squares and given a set of seven
square tiles with letters of the alphabet engraved on them (see Figure 32-3). These tiles
are selected at random from a bag of 100 tiles. The tiles can be clicked on with the
mouse and dragged to a destination square on the grid. If the spot is already occupied,
the tile is returned to its original position. Tiles may be adjusted on the board during a
turn, but not when the turn is over.
The first player starts by placing several tiles in a line on the board to form a word
in the English language. The first word must cover the center square. Subsequent
words must touch at least one tile already played on the board. The player clicks on the
Done button to end the turn. If a player can’t find a valid word, the player can pass by
clicking on Done twice in a row without having any tiles on the board. The two players
take turns placing words until all of the tiles are used.
The board shown in Figure 32-3 is for smaller displays, and thus the multiplier
squares are marked with simple characters. 2L doubles the value of the letter on that
square. 3L triples the letter’s value. 2W means the whole word gets double the points;
3W means triple the word score. If you make the applet big enough, it will use more
descriptive labels for these squares, as shown in Figure 32-4.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1071
A
P
P
LY
IN
G
JA
V
A
1072 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-1. The user must type in his or her name to begin
Figure 32-2. The list of competitors
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1073
A
P
P
LY
IN
G
JA
V
A
Figure 32-3. Patrick and Herb are ready to play against each other
Figure 32-4. Everything is clearer with a larger applet (650x700)
Scoring
Scores are assessed at the end of each turn. Each tile has a small number engraved on
its face next to the letter. This score may be multiplied by two or three, depending on
the value (color) of the square on which it was placed. The entire sum for a word may
also be multiplied by two or three if any letter in the word covers the appropriate
square. If a word comes in contact with any other tiles to form additional words, they
are counted separately. If a player uses all seven tiles in a single turn, an additional 50
points are awarded. At the end of the game, the player with the highest score wins.
Figure 32-5 shows an example of a board after a few turns have been taken. Patrick
started with SIRE, worth eight points. That came from the four one-point tiles and the
double-word score on the center tile. Next, Herb played HIRE, using the I from SIRE.
This was worth seven points, the sum of the four tiles involved. Notice that Herb got
credit for reusing Patrick’s I but not the double-word score underneath it. At the point
shown in Figure 32-5, Patrick has played GREAT and is about to click the Done button
to complete his turn. Notice that the tiles in play are brighter than those that have
already been played (see Figure 32-6).
At any time during play, the players may converse by typing in the text entry area
at the top of the applet (see Figure 32-7). These messages will appear one at a time in
the other player’s browser’s status line, typically at the bottom of the browser (see
Figure 32-8).
1074 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-5. Scrabblet early in a game
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1075
A
P
P
LY
IN
G
JA
V
A
Figure 32-6. Herb is about to place the D to make HEATED
Figure 32-7. Patrick is complaining about being stuck with the Q without the U
One last word about game play before we get into the source code. The way to win
at this game is to come up with words that score in one direction and also make words
in the other direction. These secondary words tend to be short, two-letter words, but
they add up. In Figure 32-9, Patrick places the Y in DEITY, which will score 21 points
because he gets a face value of 9 doubled to 18, plus he gets to count the word AD,
which runs vertically, for 3 points. Remember that all of the words played with each
turn need to be real words. Eventually, this game will need either an undo for disputed
words or an automatic dictionary checker to resolve conflicts.
The Source Code
Now that you know how to play the game, it is time to examine the source code for the
game. Since several of the classes are quite long, we will sprinkle comments throughout
the code rather than leaving the code till the end.
The APPLET Tag
The APPLET tag for this game is simple. Just name the main class and set the size.
That’s it. There aren’t any <param> tags for Scrabblet. Remember, the bigger you
1076 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 32-8. Herb replies. Notice Patrick’s last message at the bottom
make the applet, the nicer the board looks. The aspect ratio should be a little taller than
it is wide.
<applet code=Scrabblet.class width=400 height=450>
</applet>
Scrabblet.java
The main applet class is found in Scrabblet.java. At almost 300 lines, this is a fairly
complicated applet class, even though most of the game logic is left to the Board class,
found later in this chapter.
We start with the usual collection of import statements, loading almost every
standard Java package. Then we declare Scrabblet to be a subclass of Applet that
implements ActionListener.
import java.io.*;
import java.net.*;
import java.awt.*;
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1077
A
P
P
LY
IN
G
JA
V
A
Figure 32-9. Patrick scores in two directions!
import java.awt.event.*;
import java.applet.*;
public class Scrabblet extends Applet implements ActionListener {
Next comes the declaration of a large collection of instance variables. The server
is our connection to the web server running our game server. This machine’s name
is stored in serverName. The bag represents the shared bag of letters for our game.
Our opponent has his or her own copy of the bag, which is initialized with the same
random sequence of tiles so the two bags stay in synch. The board is our copy of the
playing board. Our opponent also has a copy of the board, and the game keeps them
in synch after each turn.
If the network server can’t be accessed, the single flag is set, and the applet plays
the game in single-player mode. The boolean ourturn is true whenever it is our turn to
play. If a player can’t find a valid word, the player can pass by clicking on Done twice
in a row without having any tiles on the board. The seen_pass variable is used to mark
if the first Done has been clicked on.
To manage the synchronization of the remote player’s board, we keep a copy of the
tiles selected in theirs. Seeing what the other person has in his or her tray is cheating,
so no hacking this applet to display the contents of theirs! The two strings, name and
others_name, hold our name and our opponent’s name, respectively.
private ServerConnection server;
private String serverName;
private Bag bag;
private Board board;
private boolean single = false;
private boolean ourturn;
private boolean seen_pass = false;
private Letter theirs[] = new Letter[7];
private String name;
private String others_name;
Next, we declare eight variables used to manage the user interface. These are all
AWT components that must be manipulated by the applet in some way. topPanel
holds the prompt and the namefield for getting the user’s name at start-up. The done
button is used to signify that you are done with your turn. The chat TextField is used
to enter chat messages. idList is used to display available opponents. The challenge
button is used to attach us to our opponent. The ican Canvas holds the name and
copyright notice at start-up.
1078 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
private Panel topPanel;
private Label prompt;
private TextField namefield;
private Button done;
private TextField chat;
private List idList;
private Button challenge;
private Canvas ican;
init( )
The init( ) method is called once and simply sets up the BorderLayout, figures out
what Internet host the applet came from, and creates the splash screen canvas.
public void init() {
setLayout(new BorderLayout());
serverName = getCodeBase().getHost();
if (serverName.equals(""))
serverName = "localhost";
ican = new IntroCanvas();
}
start( )
The start( ) method is called whenever the browser redisplays the page in which the
applet is found. The large try block at the beginning is used to catch the case where the
network connection fails. If we succeed in making a new ServerConnection and we’ve
never run start( ) before, we then set up the screen to prompt for the user’s name.
While we are there, we put the splash screen, ican, in the center of the window. In the
case where name is not null, that means the user left the page and has now returned.
We presume we’ve already got the user’s name and jump right to nameEntered( ),
the method that is called when the user types return in the name entry field. The
validate( ) at the end makes sure all of the AWT components are updated properly.
If an exception was thrown, we presume that the net connection failed and go into
single-player mode. The call to start_game( ) gets things rolling.
public void start() {
try {
showStatus("Connecting to " + serverName);
server = new ServerConnection(this, serverName);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1079
A
P
P
LY
IN
G
JA
V
A
server.start();
showStatus("Connected: " + serverName);
if (name == null) {
prompt = new Label("Enter your name here:");
namefield = new TextField(20);
namefield.addActionListener(this);
topPanel = new Panel();
topPanel.setBackground(new Color(255, 255, 200));
topPanel.add(prompt);
topPanel.add(namefield);
add("North", topPanel);
add("Center", ican);
} else {
if (chat != null) {
remove(chat);
remove(board);
remove(done);
}
nameEntered(name);
}
validate();
} catch (Exception e) {
single = true;
start_Game((int)(0x7fffffff * Math.random()));
}
}
stop( )
The stop( ) method is called whenever the user leaves the page with the applet. Here,
we just tell the server that we’ve left. We re-create the network connection in start( ) if
the user returns to the page later.
public void stop() {
if (!single)
server.quit();
}
1080 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
add( )
The add( ) method is called by the ServerConnection whenever a new player enters
the game. We add the player’s name to our List object. Pay special attention to the
formatting of the string in add( ). We use that later to extract certain IDs from the list.
void add(String id, String hostname, String name) {
delete(id); // in case it is already there.
idList.add("(" + id + ")  " + name + "@" + hostname);
showStatus("Choose a player from the list");
}
delete( )
The delete( ) method is called when a player no longer wants to be identified as
available for play. This happens when a player quits or decides to play with someone
else. Here, we hunt down the id string in our list by extracting the values inside
parentheses. If there are no more names on the list (and we aren’t playing the game
already: bag == null), then we display a special message telling the user to hang out
until someone comes to make a challenge.
void delete(String id) {
for (int i = 0; i < idList.getItemCount(); i++) {
String s = idList.getItem(i);
s = s.substring(s.indexOf("(") + 1, s.indexOf(")"));
if (s.equals(id)) {
idList.remove(i);
break;
}
}
if (idList.getItemCount() == 0 && bag == null)
showStatus("Wait for other players to arrive.");
}
getName( )
The getName( ) method is very similar to delete( ), except it simply extracts the name
part of the item and returns it. If the id is not found, then null is returned.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1081
A
P
P
LY
IN
G
JA
V
A
private String getName(String id) {
for (int i = 0; i < idList.getItemCount(); i++) {
String s = idList.getItem(i);
String id1 = s.substring(s.indexOf("(") + 1, s.indexOf(")"));
if (id1.equals(id)) {
return s.substring(s.indexOf(" ") + 3, s.indexOf("@"));
}
}
return null;
}
challenge( )
The challenge( ) method is called by the ServerConnection whenever another player
challenges us to a game. We could have made this method more complicated, so that it
would prompt the user to accept or refuse the challenge, but instead the challenge is
automatically accepted. Notice that the random seed we use to start the game is passed
back to the other player in the accept( ) method. This is used by both sides to initialize
the random state of the tile bag to ensure a synchronous game. We call server.delete( )
to ensure that we are no longer solicited by other players wanting to play against us.
Notice also that we cede the starting turn to the challenger by setting ourturn to false.
// we've been challenged to a game by "id".
void challenge(String id) {
ourturn = false;
int seed = (int)(0x7fffffff * Math.random());
others_name = getName(id);   // who was it?
showStatus("challenged by " + others_name);
// put some confirmation here...
server.accept(id, seed);
server.delete();
start_Game(seed);
}
accept( )
accept( ) is the method called on the remote side in response to the server.accept( )
call just mentioned. Just as the other player deleted himself or herself from the list of
1082 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
available players, so must we call server.delete( ). We take the first turn by setting
ourturn to true.
// our challenge was accepted.
void accept(String id, int seed) {
ourturn = true;
others_name = getName(id);
server.delete();
start_Game(seed);
}
chat( )
The chat( ) method is called by the server whenever the opponent types in his or her
chat window. In this implementation, the method simply shows the chat message in
the browser’s status message. In the future, it might be nice to log these into a
TextArea.
void chat(String id, String s) {
showStatus(others_name + ": " + s);
}
move( )
The move( ) method is called once for each tile your opponent plays. It looks through
the letters saved in theirs to find the one used. If the square is already occupied, the tile
is returned to the player’s tray. Otherwise, the opponent’s letter is moved onto the
board permanently. Next, the tile is replaced in theirs by bag.takeOut( ). If the bag is
empty, a status message appears. The board is repainted to show the new tiles on it.
Note that no scoring is done based on the placement of these tiles. The applet waits
until turn( ) is called to give the score.
// the other guy moved, and placed 'letter' at (x, y).
void move(String letter, int x, int y) {
for (int i = 0; i < 7; i++) {
if (theirs[i] != null && theirs[i].getSymbol().equals(letter)) {
Letter already = board.getLetter(x, y);
if (already != null) {
board.moveLetter(already, 15, 15); // on the tray.
}
board.moveLetter(theirs[i], x, y);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1083
A
P
P
LY
IN
G
JA
V
A
board.commitLetter(theirs[i]);
theirs[i] = bag.takeOut();
if (theirs[i] == null)
showStatus("No more letters");
break;
}
}
board.repaint();
}
turn( )
The turn( ) method is called after all of the opponent’s tiles are moved. The remote
instance of Scrabblet computes the score and sends it to us, so our copy doesn’t have
to redo it. Then the score is reported in the status line, and the setEnabled method
allows us to take a turn. othersTurn( ) tells the board about the score. The board will
reflect the new score at this point.
void turn(int score, String words) {
showStatus(others_name + " played: " + words + " worth " +
score);
done.setEnabled(true);
board.othersTurn(score);
}
quit( )
When the other side quits cleanly, quit( ) is called. It removes the AWT components of
the game and jumps right back into nameEntered( ), described next, to get connected
back into the player list.
void quit(String id) {
showStatus(others_name + " just quit.");
remove(chat);
remove(board);
remove(done);
nameEntered(name);
}
1084 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
nameEntered( )
The nameEntered( ) method is called from actionPerformed( ) whenever ENTER is
pressed in the original prompt for the user’s name. Any AWT components that might
be in the way are removed, and then a new List object, idList, is created to store the
names of the other players. The method also adds a button at the top named challenge,
then notifies the server that we are here by calling setName( ).
private void nameEntered(String s) {
if (s.equals(""))
return;
name = s;
if (ican != null)
remove(ican);
if (idList != null)
remove(idList);
if (challenge != null)
remove(challenge);
idList = new List(10, false);
add("Center", idList);
challenge = new Button("Challenge");
challenge.addActionListener(this);
add("North", challenge);
validate();
server.setName(name);
showStatus("Wait for other players to arrive.");
if (topPanel != null)
remove(topPanel);
}
wepick( ) and theypick( )
The methods wepick( ) and theypick( ) are simply used to start off the game by
picking the seven tiles for each player. It is important that the caller do these in the
right order on each side of the challenge, depending on who goes first. The call to
bag.takeOut( ) gets a single letter permanently out of the shared bag. The call to
board.addLetter( ) places the tile on our tray. For the other side, theypick( ) simply
saves the letters in theirs.
private void wepick() {
for (int i = 0; i < 7; i++) {
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1085
A
P
P
LY
IN
G
JA
V
A
Letter l = bag.takeOut();
board.addLetter(l);
}
}
private void theypick() {
for (int i = 0; i < 7; i++) {
Letter l = bag.takeOut();
theirs[i] = l;
}
}
start_Game( )
In single-player mode, start_Game( ) pops up the splash screen in a Frame window.
It then creates a playing board, passing in no parameters to the constructor, which
indicates single-player mode.
In head-to-head mode, we remove the selection list components and add the chat
window to the applet. We then add the board and Done button to the applet. Next, we
create the bag, and if it is ourturn, wepick( ) is first, then theypick( ). In the case where
we don’t have the first turn, we disable the board and the Done button, and theypick( )
is first. We then force the board to repaint, which initializes it.
private void start_Game(int seed) {
if (single) {
Frame popup = new Frame("Scrabblet");
popup.setSize(400, 300);
popup.add("Center", ican);
popup.setResizable(false);
popup.show();
board = new Board();
showStatus("no server found, playing solo");
ourturn = true;
} else {
remove(idList);
remove(challenge);
board = new Board(name, others_name);
chat = new TextField();
chat.addActionListener(this);
add("North", chat);
1086 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
showStatus("playing against " + others_name);
}
add("Center", board);
done = new Button("Done");
done.addActionListener(this);
add("South", done);
validate();
bag = new Bag(seed);
if (ourturn) {
wepick();
if (!single)
theypick();
} else {
done.setEnabled(false);
theypick();
wepick();
}
board.repaint();
}
challenge_them( )
The challenge_them( ) method is called when the challenge button is clicked. It simply
takes the player you had selected in the idList and sends him or her a challenge( )
message. It removes the list and button to be ready for the game to start.
private void challenge_them() {
String s = idList.getSelectedItem();
if (s == null) {
showStatus("Choose a player from the list then press Challenge");
} else {
remove(challenge);
remove(idList);
String destid = s.substring(s.indexOf('(')+1,
s.indexOf(')'));
showStatus("challenging: " + destid);
server.challenge(destid);  // accept will get called if
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1087
A
P
P
LY
IN
G
JA
V
A
// they accept.
validate();
}
}
our_turn( )
When the Done button is clicked, our_turn( ) is called. First, it checks to see if we’ve
placed tiles in valid locations by calling board.findwords( ) and storing the result in
word. If word is null, then something is amiss with the tiles, and the method shows
that in the status line. If word is ““, then it knows that there were no tiles in play at the
time. In single-player mode, this is ignored. In competition mode, if we click Done
twice in a row without any tiles in play, we will pass our turn to our opponent.
If you have played tiles and they are in legal positions, you have finished your turn,
so ourturn( ) commits the letters to the board. Notice that commit( ) takes the server as
a parameter. It will use this to tell the remote side about the position of each new letter.
Then the method replaces the letters you used. In multiplayer mode, we disable
ourselves and call server.turn( ) to tell the other player it is his or her turn.
private void our_turn() {
String word = board.findwords();
if (word == null) {
showStatus("Illegal letter positions");
} else {
if ("".equals(word)) {
if (single)
return;
if (seen_pass) {
done.setEnabled(false);
server.turn("pass", 0);
showStatus("You passed");
seen_pass = false;
} else {
showStatus("Press done again to pass");
seen_pass = true;
return;
}
} else {
seen_pass = false;
}
showStatus(word);
1088 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
board.commit(server);
for (int i = 0; i < 7; i++) {
if (board.getTray(i) == null) {
Letter l = bag.takeOut();
if (l == null)
showStatus("No more letters");
else
board.addLetter(l);
}
}
if (!single) {
done.setEnabled(false);
server.turn(word, board.getTurnScore());
}
board.repaint();
}
}
actionPerformed( )
The actionPerformed( ) method is used to grab input from the various components the
applet uses. It handles the Challenge and Done buttons, as well as the name entry field
and the chat entry field.
public void actionPerformed(ActionEvent ae) {
Object source = ae.getSource();
if(source == chat) {
server.chat(chat.getText());
chat.setText("");
}
else if(source == challenge) {
challenge_them();
}
else if(source == done) {
our_turn();
}
else if(source == namefield) {
TextComponent tc = (TextComponent)source;
nameEntered(tc.getText());
}
}
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1089
A
P
P
LY
IN
G
JA
V
A
IntroCanvas.java
The IntroCanvas subclass of Canvas is very simple. It just overrides paint( ) to draw
the name of the applet and a brief copyright notice. It creates some custom colors and
fonts. The display strings are held in static variables simply for clarity.
import java.awt.*;
import java.awt.event.*;
class IntroCanvas extends Canvas {
private Color pink = new Color(255, 200, 200);
private Color blue = new Color(150, 200, 255);
private Color yellow = new Color(250, 220, 100);
private int w, h;
private int edge = 16;
private static final String title = "Scrabblet";
private static final String name =
"Copyright 1999 - Patrick Naughton";
private static final String book =
"Chapter 32 from 'Java: The Complete Reference'";
private Font namefont, titlefont, bookfont;
IntroCanvas() {
setBackground(yellow);
titlefont = new Font("SansSerif", Font.BOLD, 58);
namefont = new Font("SansSerif", Font.BOLD, 18);
bookfont = new Font("SansSerif", Font.PLAIN, 12);
addMouseListener(new MyMouseAdapter());
}
d( )
The private method d( ) is a convenience method that paints centered text with an
optional isometric offset. This is used to give the main title a highlight/shadow effect
by drawing a white string up and to the left by 1, a black string down and to the right
by 1, and then drawing the string one last time in pink, not offset at all.
private void d(Graphics g, String s, Color c, Font f, int y,
int off) {
g.setFont(f);
FontMetrics fm = g.getFontMetrics();
g.setColor(c);
1090 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
g.drawString(s, (w - fm.stringWidth(s)) / 2 + off, y + off);
}
public void paint(Graphics g) {
Dimension d = getSize();
w = d.width;
h = d.height;
g.setColor(blue);
g.fill3DRect(edge, edge, w - 2 * edge, h - 2 * edge, true);
d(g, title, Color.black, titlefont, h / 2, 1);
d(g, title, Color.white, titlefont, h / 2, -1);
d(g, title, pink, titlefont, h / 2, 0);
d(g, name, Color.black, namefont, h * 3 / 4, 0);
d(g, book, Color.black, bookfont, h * 7 / 8, 0);
}
mousePressed( )
In the following code fragment, notice that MyMouseAdapter is an inner class that
extends MouseAdapter. It overrides the mousePressed( ) method to cause this canvas’
parent to hide( ) if it is clicked on. This is only useful in single-player mode to dismiss
the pop-up frame.
class MyMouseAdapter extends MouseAdapter {
public void mousePressed(MouseEvent me) {
((Frame)getParent()).setVisible(false);
}
}
}
Board.java
The Board class encapsulates most of the game logic as well as the look and feel of the
board. It is the biggest class in the game, weighing in at over 500 lines of code. There
are several private variables that store the game state. The 15×15 array of Letters
named board is used to store the tiles on each square of the board. The tray array holds
the Letters that are currently on our tray. Remember that the Scrabblet applet class
holds the seven Letters from our opponent. The Point objects orig and here are used to
remember letter positions. The name and others_name variables are used simply to
display names for the scoreboard. In single-player mode, both will be null. The two
players’ scores are stored in total_score and others_score, while our last turn’s result is
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1091
A
P
P
LY
IN
G
JA
V
A
stored in turn_score. The two constructors set up the names of the players, or leave
them blank in single-player mode.
import java.awt.*;
import java.awt.event.*;
class Board extends Canvas {
private Letter board[][] = new Letter[15][15];
private Letter tray[] = new Letter[7];
private Point orig = new Point(0,0);
private Point here = new Point(0,0);
private String name;
private int total_score = 0;
private int turn_score = 0;
private int others_score = 0;
private String others_name = null;
Board(String our_name, String other_name) {
name = our_name;
others_name = other_name;
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
Board() {
addMouseListener(new MyMouseAdapter());
addMouseMotionListener(new MyMouseMotionAdapter());
}
othersTurn( ), getTurnScore( ), and getTray( )
These three methods are used to control the access to several private variables.
First, othersTurn( ) is called by the applet when the other player finishes a turn. It
increments the player’s score and repaints that area of the board to reflect the change.
The getTurnScore( ) method simply returns the saved last turn’s score, after making
sure the scoreboard is painted with the correct value. The applet uses this method to
pass the score to our opponent, where it will eventually call othersTurn( ) on the
remote machine. The getTray( ) method simply provides a read-only access to the
private tray array.
1092 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
void othersTurn(int score) {
others_score += score;
paintScore();
repaint();
}
int getTurnScore() {
paintScore();
return turn_score;
}
Letter getTray(int i) {
return tray[i];
}
addLetter( )
The addLetter( ) method is used to place a letter on the tray. The letter is placed in the
first slot that is empty. If the method can’t find an empty slot, it returns false.
synchronized boolean addLetter(Letter l) {
for (int i = 0; i < 7; i++) {
if (tray[i] == null) {
tray[i] = l;
moveLetter(l, i, 15);
return true;
}
}
return false;
}
existingLetterAt( )
The private method existingLetterAt( ) is used to check a board position to see if it has
a letter in it that is not currently in play. This is used by findwords( ) next to make sure
that at least one letter in a turn is touching an already existing letter.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1093
A
P
P
LY
IN
G
JA
V
A
private boolean existingLetterAt(int x, int y) {
Letter l = null;
return (x >= 0 && x <= 14 && y >= 0 && y <= 14
&& (l = board[y][x]) != null && l.recall() == null);
}
findwords( )
findwords( ) is a very large method used to examine the state of the board for a legal
turn. If the rules for letter placement are broken, then null is returned. If no tiles were
in play, then ““ is returned. If all of the tiles played in this turn are legal, then the list of
words they formed is returned as a string containing the space-separated words. The
instance variables turn_score and total_score are updated to reflect the value of the
words that were just played.
First findwords( ) counts the tiles at play, ntiles, storing them in a separate array
called atplay. Next, it looks at the first two tiles (if more than one was played) to
determine if they are vertically or horizontally oriented. Then it inspects all of the other
tiles at play, to make sure they are along the same line. If any of the tiles is out of that
row or column, the method returns null.
synchronized String findwords() {
String res = "";
turn_score = 0;
int ntiles = 0;
Letter atplay[] = new Letter[7];
for (int i = 0; i < 7; i++) {
if (tray[i] != null && tray[i].recall() != null) {
atplay[ntiles++] = tray[i];
}
}
if (ntiles == 0)
return res;
boolean horizontal = true; // if there's one tile,
// call it horizontal
boolean vertical = false;
if (ntiles > 1) {
int x = atplay[0].x;
int y = atplay[0].y;
horizontal = atplay[1].y == y;
1094 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
vertical = atplay[1].x == x;
if (!horizontal && !vertical) // diagonal...
return null;
for (int i = 2; i < ntiles; i++) {
if (horizontal && atplay[i].y != y
|| vertical && atplay[i].x != x)
return null;
}
}
Next, it looks at each tile to be sure that at least one of them is touching an existing
tile on one of its four sides. A special case is made for the beginning of the game: if the
center tile is covered and more than one tile is played, it is legal.
// make sure that at least one played tile is
// touching at least one existing tile.
boolean attached = false;
for (int i = 0; i < ntiles; i++) {
Point p = atplay[i].recall();
int x = p.x;
int y = p.y;
if ((x == 7 && y == 7 && ntiles > 1) ||
existingLetterAt(x-1, y) || existingLetterAt(x+1, y) ||
existingLetterAt(x, y-1) || existingLetterAt(x, y+1)) {
attached = true;
break;
}
}
if (!attached) {
return null;
}
This next loop iterates over every letter in the main word, (i == –1), then comes
back again for each letter (i == 0..ntiles), which might also create a word orthogonal to
the main direction, which is managed via horizontal.
// we use -1 to mean check the major direction first
// then 0..ntiles checks for words orthogonal to it.
for (int i = -1; i < ntiles; i++) {
Point p = atplay[i==-1?0:i].recall(); // where is it?
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1095
A
P
P
LY
IN
G
JA
V
A
int x = p.x;
int y = p.y;
int xinc, yinc;
if (horizontal) {
xinc = 1;
yinc = 0;
} else {
xinc = 0;
yinc = 1;
}
int mult = 1;
String word = "";
int word_score = 0;
The method then picks each tile and moves left or up from it to find the first tile
in each word. Once at the beginning of the word, it moves right or down from it,
inspecting every letter. It counts the letters in letters_seen. For each letter, it determines
the point contribution based on the bonus multiplier beneath it. If the square is played
for the first time, the multiplier value is applied; otherwise the tile is counted at face
value. This score is accumulated in word_score.
// here we back up to the top/left-most letter
while (x >= xinc && y >= yinc &&
board[y-yinc][x-xinc] != null) {
x -= xinc;
y -= yinc;
}
int n = 0;
int letters_seen = 0; // letters we've just played.
Letter l;
while (x < 15 && y < 15 && (l = board[y][x]) != null) {
word += l.getSymbol();
int lscore = l.getPoints();
if (l.recall() != null) {  // one we just played...
Color t = tiles[y < 8 ? y : 14 - y][x < 8 ? x : 14 - x];
if (t == w3)
mult *= 3;
else if (t == w2)
1096 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
mult *= 2;
else if (t == l3)
lscore *= 3;
else if (t == l2)
lscore *= 2;
if (i == -1) {
letters_seen++;
}
}
word_score += lscore;
n++;
x += xinc;
y += yinc;
}
word_score *= mult;
One last error check is done on the main word only. Since the loop ends whenever
it hits a blank square or the edge of the board, it should cover all of the freshly played
tiles, as well as some previously played ones. If it sees fewer tiles, then there must have
been a gap in them, which is an illegal position, so it returns null. If that test is passed,
it checks to see if all seven tiles were played, awarding a 50-point bonus if they were.
After inspecting the main word, findwords( ) inverts the sense of horizontal and looks
for orthogonal words on the subsequent passes.
if (i == -1) {     // first pass...
// if we didn't see all the letters, then there was a gap,
// which is an illegal tile position.
if (letters_seen != ntiles) {
return null;
}
if (ntiles == 7) {
turn_score += 50;
}
// after the first pass, switch to looking the other way.
horizontal = !horizontal;
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1097
A
P
P
LY
IN
G
JA
V
A
As findwords( ) walks across the word, it needs to make sure that it only scores
letters that form at least two-letter words. In this case, it adds the word_score to the
turn_score and appends this word to the result string. Once all of the letters have been
inspected, it totals the score and returns.
if (n < 2)  // don't count single letters twice.
continue;
turn_score += word_score;
res += word + " ";
}
total_score += turn_score;
return res;
}
commit( ) and commitLetter( )
The commit( ) and commitLetter( ) methods commit the letters that were tentatively
placed on the board. These letters are removed from the tray and painted in a darker
color on the board. As each letter is committed, commit( ) notifies the server of the
position of each letter by calling move( ) so that the opponent’s board can be updated.
synchronized void commit(ServerConnection s) {
for (int i = 0 ; i < 7 ; i++) {
Point p;
if (tray[i] != null && (p = tray[i].recall()) != null) {
if (s != null)  // there's a server connection
s.move(tray[i].getSymbol(), p.x, p.y);
commitLetter(tray[i]);  // marks this as not in play.
tray[i] = null;
}
}
}
void commitLetter(Letter l) {
if (l != null && l.recall() != null) {
l.paint(offGraphics, Letter.DIM);
l.remember(null);   // marks this as not in play.
}
}
1098 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
update( ) and paint( )
Many private variables are declared here to provide easy access to the dimensions of
the board. This code also declares two offscreen buffers, one to be used as the image of
the board and all of the permanently set tiles and another to use as a double buffer for
the display. The update( ) method simply calls paint( ) to avoid flicker. The paint( )
method makes a quick call to checksize( ) to make sure all of the buffers have been
created, then checks to see if we are dragging a letter around by means of pick != null.
If so, then paint( ) makes a copy of the offscreen graphics context and clips it to the
bounds of the letter it is painting, x0, y0, w0, h0. Next, it clips the onscreen graphics
context to the same rectangle. This will minimize the number of pixels it will have to
move for each move of the mouse.
To paint, we copy the background image, offscreen, then call paint on each
letter in the tray with the setting of NORMAL. We paint the letter we are dragging
around in the BRIGHT mode. Finally, we copy the double buffer image,
offscreen2, to the screen.
private Letter pick;  // the letter being dragged around.
private int dx, dy;   // offset to topleft corner of pick.
private int lw, lh;   // letter width and height.
private int tm, lm;   // top and left margin.
private int lt;       // line thickness (between tiles).
private int aw, ah;   // letter area size.
private Dimension offscreensize;
private Image offscreen;
private Graphics offGraphics;
private Image offscreen2;
private Graphics offGraphics2;
public void update(Graphics g) {
paint(g);
}
public synchronized void paint(Graphics g) {
Dimension d = checksize();
Graphics gc = offGraphics2;
if (pick != null) {
gc = gc.create();
gc.clipRect(x0, y0, w0, h0);
g.clipRect(x0, y0, w0, h0);
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1099
A
P
P
LY
IN
G
JA
V
A
gc.drawImage(offscreen, 0, 0, null);
for (int i = 0 ; i < 7 ; i++) {
Letter l = tray[i];
if (l != null && l != pick)
l.paint(gc, Letter.NORMAL);
}
if (pick != null)
pick.paint(gc, Letter.BRIGHT);
g.drawImage(offscreen2, 0, 0, null);
}
LetterHit( )
LetterHit( ) returns the letter that is under the point x,y and returns null if no letter
is there.
Letter LetterHit(int x, int y) {
for (int i = 0; i < 7; i++) {
if (tray[i] != null && tray[i].hit(x, y)) {
return tray[i];
}
}
return null;
}
unplay( )
This simple method removes a letter from play that was placed on the board but was
not yet committed.
private void unplay(Letter let) {
Point p = let.recall();
if (p != null) {
board[p.y][p.x] = null;
let.remember(null);
}
}
1100 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
moveToTray( )
The moveToTray( ) method is just a simple convenience to compute the screen position
of a letter in a given tray slot.
private void moveToTray(Letter l, int i) {
int x = lm + (lw + lt) * i;
int y = tm + ah - 2 * lt;
l.move(x, y);
}
dropOnTray( )
The dropOnTray( ) method is used whenever we drop a letter over the tray area or off
the board anywhere. This allows us to shuffle the contents of the tray as well as simply
return tiles from the board.
private void dropOnTray(Letter l, int x) {
unplay(l); // unhook where we were.
// find out what slot this letter WAS in.
int oldx = 0;
for (int i = 0 ; i < 7 ; i++) {
if (tray[i] == l) {
oldx = i;
break;
}
}
// if the slot we dropped on was empty,
// find the rightmost occupied slot.
if (tray[x] == null) {
for (int i = 6 ; i >= 0 ; i--) {
if (tray[i] != null) {
x = i;
break;
}
}
}
// if the slot we dropped on was from a tile already
// played on the board, just swap slots with it.
if (tray[x].recall() != null) {
tray[oldx] = tray[x];
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1101
A
P
P
LY
IN
G
JA
V
A
} else {
// we are just rearranging a tile already on the tray.
if (oldx < x) {   // shuffle left.
for (int i = oldx ; i < x ; i++) {
tray[i] = tray[i+1];
if (tray[i].recall() == null)
moveToTray(tray[i], i);
}
} else {          // shuffle right.
for (int i = oldx ; i > x ; i--) {
tray[i] = tray[i-1];
if (tray[i].recall() == null)
moveToTray(tray[i], i);
}
}
}
tray[x] = l;
moveToTray(l, x);
}
getLetter( )
getLetter( ) is a simple read-only wrapper on the board array.
Letter getLetter(int x, int y) {
return board[y][x];
}
moveLetter( )
The moveLetter( ) method handles the cases where we want to move tiles to board
positions or set them on the tray. If the x,y position is out of range for the board, then
the tray is used. When a letter is moved to the board, it must be a blank slot, otherwise
the letter is sent back to the value stored in orig.
void moveLetter(Letter l, int x, int y) {
if (y > 14 || x > 14 || y < 0 || x < 0) {
// if we are off the board.
if (x > 6)
x = 6;
if (x < 0)
1102 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
x = 0;
dropOnTray(l, x);
} else {
if (board[y][x] != null) {
x = orig.x;
y = orig.y;
} else {
here.x = x;
here.y = y;
unplay(l);
board[y][x] = l;
l.remember(here);
// turn it back into pixels
x = lm + (lw + lt) * x;
y = tm + (lh + lt) * y;
}
l.move(x, y);
}
}
checksize( )
This method has a misleading name. checksize( ) does a lot more than verify the size of
the applet, but it is convenient to do this kind of initialization once, when we confirm
the size of the applet. This method contains the drawing code for the main board
pattern. It paints all of the squares, including the colors and the bonus score text.
private Color bg = new Color(175, 185, 175);
private Color w3 = new Color(255, 50, 100);
private Color w2 = new Color(255, 200, 200);
private Color l3 = new Color(75, 75, 255);
private Color l2 = new Color(150, 200, 255);
private Color tiles[][] = {
{w3, bg, bg, l2, bg, bg, bg, w3},
{bg, w2, bg, bg, bg, l3, bg, bg},
{bg, bg, w2, bg, bg, bg, l2, bg},
{l2, bg, bg, w2, bg, bg, bg, l2},
{bg, bg, bg, bg, w2, bg, bg, bg},
{bg, l3, bg, bg, bg, l3, bg, bg},
{bg, bg, l2, bg, bg, bg, l2, bg},
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1103
A
P
P
LY
IN
G
JA
V
A
{w3, bg, bg, l2, bg, bg, bg, w2}
};
private Dimension checksize() {
Dimension d = getSize();
int w = d.width;
int h = d.height;
if (w < 1 || h < 1)
return d;
if ((offscreen == null) ||
(w != offscreensize.width) ||
(h != offscreensize.height)) {
System.out.println("updating board: " + w + " x " + h + "\r");
offscreen = createImage(w, h);
offscreensize = d;
offGraphics = offscreen.getGraphics();
offscreen2 = createImage(w, h);
offGraphics2 = offscreen2.getGraphics();
offGraphics.setColor(Color.white);
offGraphics.fillRect(0,0,w,h);
// lt is the thickness of the white lines between tiles.
// gaps is the sum of all the whitespace.
// lw, lh are the dimensions of the tiles.
// aw, ah are the dimensions of the entire board
// lm, tm are the left and top margin to center aw, ah in the applet.
lt = 1 + w / 400;
int gaps = lt * 20;
lw = (w - gaps) / 15;
lh = (h - gaps - lt * 2) / 16; // compensating for tray height;
aw = lw * 15 + gaps;
ah = lh * 15 + gaps;
lm = (w - aw) / 2 + lt;
tm = (h - ah - (lt * 2 + lh)) / 2 + lt;
1104 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
offGraphics.setColor(Color.black);
offGraphics.fillRect(lm,tm,aw-2*lt,ah-2*lt);
lm += lt;
tm += lt;
offGraphics.setColor(Color.white);
offGraphics.fillRect(lm,tm,aw-4*lt,ah-4*lt);
lm += lt;
tm += lt;
int sfh = (lh > 30) ? lh / 4 : lh / 2;
Font font = new Font("SansSerif", Font.PLAIN, sfh);
offGraphics.setFont(font);
for (int j = 0, y = tm; j < 15; j++, y += lh + lt) {
for (int i = 0, x = lm; i < 15; i++, x += lw + lt) {
Color c = tiles[j < 8 ? j : 14 - j][i < 8 ? i : 14 - i];
offGraphics.setColor(c);
offGraphics.fillRect(x, y, lw, lh);
offGraphics.setColor(Color.black);
if (lh > 30) {
String td = (c == w2 || c == l2) ? "DOUBLE" :
(c == w3 || c == l3) ? "TRIPLE" : null;
String wl = (c == l2 || c == l3) ? "LETTER" :
(c == w2 || c == w3) ? "WORD" : null;
if (td != null) {
center(offGraphics, td, x, y + 2 + sfh, lw);
center(offGraphics, wl, x, y + 2 * (2 + sfh), lw);
center(offGraphics, "SCORE", x, y + 3 * (2 + sfh), lw);
}
} else {
String td = (c == w2 || c == l2) ? "2" :
(c == w3 || c == l3) ? "3" : null;
String wl = (c == l2 || c == l3) ? "L" :
(c == w2 || c == w3) ? "W" : null;
if (td != null) {
center(offGraphics, td + wl, x,
y + (lh - sfh) * 4 / 10 + sfh, lw);
}
}
}
}
Color c = new Color(255, 255, 200);
offGraphics.setColor(c);
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1105
A
P
P
LY
IN
G
JA
V
A
offGraphics.fillRect(lm, tm + ah - 3 * lt, 7 * (lw + lt), lh +
2 * lt);
Letter.resize(lw, lh);
// if we already have some letters, place them.
for (int i = 0; i < 7; i++) {
if (tray[i] != null) {
moveToTray(tray[i], i);
}
}
paintScore();
}
return d;
}
center( )
center( ) is a convenience routine that checksize( ) uses to center the “Double Letter
Score” text.
private void center(Graphics g, String s, int x, int y, int w) {
x += (w - g.getFontMetrics().stringWidth(s)) / 2;
g.drawString(s, x, y);
}
paintScore( )
The paintScore( ) method paints the two players’ scores or just the one score in
single-player mode.
private void paintScore() {
int x = lm + (lw + lt) * 7 + lm;
int y = tm + ah - 3 * lt;
int h = lh + 2 * lt;
Font font = new Font("TimesRoman", Font.PLAIN, h/2);
offGraphics.setFont(font);
FontMetrics fm = offGraphics.getFontMetrics();
offGraphics.setColor(Color.white);
offGraphics.fillRect(x, y, aw, h);
offGraphics.setColor(Color.black);
1106 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
if (others_name == null) {
int y0 = (h - fm.getHeight()) / 2 + fm.getAscent();
offGraphics.drawString("Score: " + total_score, x, y + y0);
} else {
h/=2;
int y0 = (h - fm.getHeight()) / 2 + fm.getAscent();
offGraphics.drawString(name + ": " + total_score, x, y + y0);
offGraphics.drawString(others_name + ": " + others_score,
x, y + h + y0);
}
}
private int x0, y0, w0, h0;
selectLetter( )
The selectLetter( ) method checks the mouse position to see if the cursor is over a letter.
If so, it stores that in pick and computes how far the mouse was from the upper-left
corner of the letter, which is stored in dx, dy. It also remembers the original position of
this letter in orig.
private void selectLetter(int x, int y) {
pick = LetterHit(x, y);
if(pick != null) {
dx = pick.x - x;
dy = pick.y - y;
orig.x = pick.x;
orig.y = pick.y;
}
repaint();
}
dropLetter( )
In dropLetter( ), the user has dropped the letter if he or she was carrying one. It
determines which square on the board the letter was over when it was dropped. It then
calls moveLetter( ) to attempt to move the letter to that square.
private void dropLetter(int x, int y) {
if(pick != null) {
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1107
A
P
P
LY
IN
G
JA
V
A
// find the center of the tile
x += dx + lw / 2;
y += dy + lh / 2;
// find the tile index
x = (x - lm) / (lw + lt);
y = (y - tm) / (lh + lt);
moveLetter(pick, x, y);
pick = null;
repaint();
}
}
dragLetter( )
The dragLetter( ) method is handled differently than the other mouse-related events.
This is mainly due to performance considerations. The goal is to have as smooth an
interaction with the user as possible. dragLetter( ) goes to some length to compute the
bounding box of where the tile was before this drag plus where it is now. It then
directly calls paint(getGraphics( )). This is nonstandard Java applet programming, but
it performs much more reliably.
private void dragLetter(int x, int y) {
if (pick != null) {
int ox = pick.x;
int oy = pick.y;
pick.move(x + dx, y + dy);
x0 = Math.min(ox, pick.x);
y0 = Math.min(oy, pick.y);
w0 = pick.w + Math.abs(ox - pick.x);
h0 = pick.h + Math.abs(oy - pick.y);
paint(getGraphics());
}
}
mousePressed( )
In the following code fragment, notice that MyMouseAdapter is an inner class that
extends MouseAdapter. It overrides the mousePressed( ) and mouseReleased( )
methods.
1108 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The mousePressed( ) method invokes the selectLetter( ) method to do the
necessary processing. The x and y coordinates of the current mouse position are
obtained from the argument supplied to the mousePressed( ) method.
class MyMouseAdapter extends MouseAdapter {
public void mousePressed(MouseEvent me) {
selectLetter(me.getX(), me.getY());
}
mouseReleased( )
The mouseReleased( ) method invokes the dropLetter( ) method to do the necessary
processing. The x and y coordinates of the current mouse position are obtained from
the argument supplied to the mouseReleased( ) method.
public void mouseReleased(MouseEvent me) {
dropLetter(me.getX(), me.getY());
}
}
mouseDragged( )
In the following code fragment, notice that MyMouseMotionAdapter is an inner class
that extends MouseMotionAdapter. It overrides the mouseDragged( ) method.
The mouseDragged( ) method invokes the dragLetter( ) method to do the necessary
processing. The x and y coordinates of the current mouse position are obtained from
the argument supplied to the mouseDragged( ) method.
class MyMouseMotionAdapter extends MouseMotionAdapter {
public synchronized void mouseDragged(MouseEvent me) {
dragLetter(me.getX(), me.getY());
}
}
}
Bag.java
The Bag class is very clean compared with Board. It is a simple abstraction for the bag
of letters. When you create a Bag, you pass in a random seed, which allows you to
create two bags that are random but the same by passing in the same random seed. The
random number generator is stored in rand. There are two somewhat strange arrays of
integers, named letter_counts and letter_points. Both arrays are 27 slots long. They
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1109
A
P
P
LY
IN
G
JA
V
A
represent the blank tile in slot 0, and A through Z in 1 through 26. The letter_counts
array says how many of each letter are in a full bag. For example, letter_counts[1] is 9,
which says there are nine A tiles in the bag. Similarly, the letter_points array maps
each letter to its point value. The A tiles are worth only 1 point, and the lone Z is worth
10. There are 100 letters stored in the array called letters. The number of letters actually
left in the bag during game play is stored in n.
import java.util.Random;
class Bag {
private Random rand;
private int letter_counts[] = {
2, 9, 2, 2, 4, 12, 2, 3, 2, 9, 1, 1, 4, 2,
6, 8, 2, 1, 6, 4, 6, 4, 2, 2, 1, 2, 1
};
private int letter_points[] = {
0, 1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3,
1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10
};
private Letter letters[] = new Letter[100];
private int n = 0;
Bag( )
The Bag constructor takes the seed and makes a Random object out of it. It then scans
through the letter_counts array, making the right number of new Letter objects, being
careful to replace the blank tile with an asterisk. It then calls putBack( ) for each letter,
to put them in the bag.
Bag(int seed) {
rand = new Random(seed);
for (int i = 0; i < letter_counts.length; i++) {
for (int j = 0; j < letter_counts[i]; j++) {
Letter l = new Letter(i == 0 ? '*' : (char)('A' + i - 1),
letter_points[i]);
putBack(l);
}
}
}
1110 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
takeOut( )
This next method is slightly clever and a little inefficient, but in a noncritical way.
takeOut( ) picks a random number between 0 and n –1. It then extracts the letter at
that offset from the letters array. It closes the hole over that slot in letters using
System.arraycopy( ). Then it decrements n and returns the letter.
synchronized Letter takeOut() {
if (n == 0)
return null;
int i = (int)(rand.nextDouble() * n);
Letter l = letters[i];
if (i != n - 1)
System.arraycopy(letters, i + 1, letters, i, n - i - 1);
n--;
return l;
}
putBack( )
The putBack( ) method is used by the constructor to put the tiles in the bag originally.
It could also be used by a future game enhancement that would let players trade in
tiles they were unhappy with in exchange for losing a turn. It simply puts the letter
back at the end of the array.
synchronized void putBack(Letter l) {
letters[n++] = l;
}
}
Letter.java
The Letter class is fairly clean in that it doesn’t know anything about the game or the
board. It merely encapsulates the position and visual rendering of a single letter. It uses
several static variables to hold information about fonts and sizes. This is done so that
the applet doesn’t end up with 100 fonts in memory at once. This has the side effect
that a browser page cannot contain two instances of the Scrabblet applet if they each
have different sizes. The second one to initialize will overwrite the values in these
static variables.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1111
A
P
P
LY
IN
G
JA
V
A
The w and h variables hold the constant width and height of every letter. The font
and smfont variables are the AWT font objects for the big letter and the smaller point
value. The ints y0 and ys0 store the offset of the baseline of the letter and the points,
respectively. A few constants are provided to be passed back into paint( ) to describe
which color state to paint in: NORMAL, DIM, and BRIGHT mode.
import java.awt.*;
class Letter {
static int w, h;
private static Font font, smfont;
private static int y0, ys0;
private static int lasth = -1;
static final int NORMAL = 0;
static final int DIM = 1;
static final int BRIGHT = 2;
colors[ ], mix( ), gain( ), and clamp( )
The colors array is initialized statically with nine color objects—three sets of three
colors. The mix( ) method is used to take a set of RGB values like 250, 220, 100 and turn
them into three colors, which can be used to provide 3-D–like highlights and lowlights.
The mix( ) method calls on gain( ) to boost or decimate the brightness of a given color
and calls on clamp( ) to make sure it remains in the legal range.
private static Color colors[][] = {
mix(250, 220, 100),   // normal
mix(200, 150, 80),    // dim
mix(255, 230, 150)    // bright
};
private static Color mix(int r, int g, int b)[] {
Color arr[] = new Color[3];
arr[NORMAL] = new Color(r, g, b);
arr[DIM] = gain(arr[0], .71);
arr[BRIGHT] = gain(arr[0], 1.31);
return arr;
}
private static int clamp(double d) {
return (d < 0) ? 0 : ((d > 255) ? 255 : (int) d);
}
1112 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
private static Color gain(Color c, double f) {
return new Color(
clamp(c.getRed() * f),
clamp(c.getGreen() * f),
clamp(c.getBlue() * f));
}
Instance Variables
The valid flag is used to make sure that all of the sizing variables are set up exactly
once, the first time this Letter is painted. There are several variables cached here to
keep from having to do lots of computation each time the applet paints—such as, x0,
w0, xs0, ws0, and gap—which are all explained in the following comments. The tile
Point object is used to remember which square on the 15×15 board this Letter is on. If
this variable is null, then the Letter is not on the board. The x,y pair is used to exactly
locate the Letter.
private boolean valid = false;
// quantized tile position of Letter. (just stored here).
private Point tile = null;
int x, y;               // position of Letter.
private int x0;         // offset of symbol on tile.
private int w0;         // width in pixels of symbol.
private int xs0;        // offset of points on tile.
private int ws0;        // width in pixels of points.
private int gap = 1;    // pixels between symbol and points.
Letter( ), getSymbol( ), and getPoints( )
The symbol is a string that holds the letter displayed, and points is the point value of
this letter. These are both initialized by the only constructor and returned by the
wrapper methods getSymbol( ) and getPoints( ), respectively.
private String symbol;
private int points;
Letter(char s, int p) {
symbol = "" + s;
points = p;
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1113
A
P
P
LY
IN
G
JA
V
A
String getSymbol() {
return symbol;
}
int getPoints() {
return points;
}
move( ), remember( ), and recall( )
The move( ) method is used to tell this tile where to draw. The remember( ) method,
however, is more complicated. It can be called with a null, which means that this tile
should “forget” where it was. This indicates that the letter is not in play. Otherwise, it
tells which coordinate on the board this letter is occupying. This state is inspected by a
call to recall( ).
void move(int x, int y) {
this.x = x;
this.y = y;
}
void remember(Point t) {
if (t == null) {
tile = t;
} else {
tile = new Point(t.x, t.y);
}
}
Point recall() {
return tile;
}
resize( )
The resize( ) method is called once by the board in order to tell every letter how big to
be. Remember, w and h are static, so this affects all Letter instances at once.
static void resize(int w0, int h0) {
w = w0;
h = h0;
}
1114 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
hit( )
The hit( ) method returns true if the xp,yp pair passed in falls inside the bounds of
this Letter.
boolean hit(int xp, int yp) {
return (xp >= x && xp < x + w && yp >= y && yp < y + h);
}
validate( )
The validate( ) method is used to load the fonts to find out how big the letters are,
to decide where to paint them. This information is cached in the private variables
discussed earlier. The results of these calculations are used next in paint( ).
private int font_ascent;
void validate(Graphics g) {
FontMetrics fm;
if (h != lasth) {
font = new Font("SansSerif", Font.BOLD, (int)(h * .6));
g.setFont(font);
fm = g.getFontMetrics();
font_ascent = fm.getAscent();
y0 = (h - font_ascent) * 4 / 10 + font_ascent;
smfont = new Font("SansSerif", Font.BOLD, (int)(h * .3));
g.setFont(smfont);
fm = g.getFontMetrics();
ys0 = y0 + fm.getAscent() / 2;
lasth = h;
}
if (!valid) {
valid = true;
g.setFont(font);
fm = g.getFontMetrics();
w0 = fm.stringWidth(symbol);
g.setFont(smfont);
fm = g.getFontMetrics();
ws0 = fm.stringWidth("" + points);
int slop = w - (w0 + gap + ws0);
x0 = slop / 2;
if (x0 < 1)
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1115
A
P
P
LY
IN
G
JA
V
A
x0 = 1;
xs0 = x0 + w0 + gap;
if (points > 9)
xs0--;
}
}
paint( )
The paint( ) method is called by the board. It passes in an integer, i, which is one of
NORMAL, BRIGHT, or DIM from this class. That is used as an index into the colors
array to select the base color. A sequence of rectangles is filled to create the appearance
of a 3-D highlighted and shadowed button. If points is greater than zero, indicating a
nonblank letter, then the main letter is drawn, and its point value is drawn next to it.
void paint(Graphics g, int i) {
Color c[] = colors[i];
validate(g);
g.setColor(c[NORMAL]);
g.fillRect(x, y, w, h);
g.setColor(c[BRIGHT]);
g.fillRect(x, y, w - 1, 1);
g.fillRect(x, y + 1, 1, h - 2);
g.setColor(Color.black);
g.fillRect(x, y + h - 1, w, 1);
g.fillRect(x + w - 1, y, 1, h - 1);
g.setColor(c[DIM]);
g.fillRect(x + 1, y + h - 2, w - 2, 1);
g.fillRect(x + w - 2, y + 1, 1, h - 3);
g.setColor(Color.black);
if (points > 0) {
g.setFont(font);
g.drawString(symbol, x + x0, y + y0);
g.setFont(smfont);
g.drawString("" + points, x + xs0, y + ys0);
}
}
}
1116 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
ServerConnection.java
The last class in the client side of this applet is ServerConnection, which encapsulates
the communication with the server and our opponent. There are several variables
declared at the beginning of the class. The socket port number to attach to on the server
is 6564. CRLF is the Internet constant string representing end-of-line. The I/O streams
from and to the server are in and out, respectively. The unique ID by which this
connection is known on the server is stored in id. The ID that we are connected to as
an opponent is stored in toid. The Scrabblet applet we are connecting for is scrabblet.
import java.io.*;
import java.net.*;
import java.util.*;
class ServerConnection implements Runnable {
private static final int port = 6564;
private static final String CRLF = "\r\n";
private BufferedReader in;
private PrintWriter out;
private String id, toid = null;
private Scrabblet scrabblet;
ServerConnection( )
The ServerConnection constructor takes the name of an Internet site to attach to and
attempts to open a socket to the right port on that host. If that succeeds, it wraps an
InputStreamReader and a BufferedReader around the input and a PrintWriter around
the output. If the connection fails, an exception is thrown to the caller.
public ServerConnection(Scrabblet sc, String site) throws
IOException {
scrabblet = sc;
Socket server = new Socket(site, port);
in = new BufferedReader(new
InputStreamReader(server.getInputStream()));
out = new PrintWriter(server.getOutputStream(), true);
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1117
A
P
P
LY
IN
G
JA
V
A
readline( )
The readline( ) method is merely a convenience function that converts the IOException
from a readLine( ) into a simple null return.
private String readline() {
try {
return in.readLine();
} catch (IOException e) {
return null;
}
}
setName( ) and delete( )
The setName( ) method tells the server to associate this name with us, and the delete( )
method is used to remove us from any lists the server is keeping.
void setName(String s) {
out.println("name " + s);
}
void delete() {
out.println("delete " + id);
}
setTo( ) and send( )
The setTo( ) method binds the ID of the opponent. Future send( ) calls will go to this
player.
void setTo(String to) {
toid = to;
}
void send(String s) {
if (toid != null)
out.println("to " + toid + " " + s);
}
1118 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
challenge( ), accept( ), chat( ), move( ), turn( ), and quit( )
The following short methods send one-line messages from this client to the server,
which will in turn send those messages on to our opponent. The challenge message is
used to initiate starting a game, and accept is sent in response to a challenge. For each
letter that moves, the move message is sent, and then the turn message is sent at the
end of each turn. If the client quits or leaves the page with the applet on it, it sends the
quit message.
void challenge(String destid) {
setTo(destid);
send("challenge " + id);
}
void accept(String destid, int seed) {
setTo(destid);
send("accept " + id + " " + seed);
}
void chat(String s) {
send("chat " + id + " " + s);
}
void move(String letter, int x, int y) {
send("move " + letter + " " + x + " " + y);
}
void turn(String words, int score) {
send("turn " + score + " " + words);
}
void quit() {
send("quit " + id);  // tell other player
out.println("quit"); // unhook
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1119
A
P
P
LY
IN
G
JA
V
A
start( )
The next method simply starts the thread that manages the client side of the network.
// reading from server...
private Thread t;
void start() {
t = new Thread(this);
t.start();
}
Keywords
The static variables and static block shown here are used to initialize the keys
Hashtable with a mapping between the strings in keystrings and their position in
the array—for example, keys.get(“move”) == MOVE. The lookup( ) method takes
care of unpacking the Integer objects into the right int, with –1 meaning the keyword
was not found.
private static final int ID = 1;
private static final int ADD = 2;
private static final int DELETE = 3;
private static final int MOVE = 4;
private static final int CHAT = 5;
private static final int QUIT = 6;
private static final int TURN = 7;
private static final int ACCEPT = 8;
private static final int CHALLENGE = 9;
private static Hashtable keys = new Hashtable();
private static String keystrings[] = {
"", "id", "add", "delete", "move", "chat",
"quit", "turn", "accept", "challenge"
};
static {
1120 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
for (int i = 0; i < keystrings.length; i++)
keys.put(keystrings[i], new Integer(i));
}
private int lookup(String s) {
Integer i = (Integer) keys.get(s);
return i == null ? -1 : i.intValue();
}
run( )
run( ) is the main loop of the game’s connection to the server. It goes into a blocking
call to readline( ) that will return with a String whenever a line of text comes from the
server. It uses a StringTokenizer to break the line into words. The switch statement
dispatches us to the right code, based on the first word in the input line. Each of the
keywords in the protocol parses the input line differently, and most of them make
method calls back into the Scrabblet class to do their work.
public void run() {
String s;
StringTokenizer st;
while ((s = readline()) != null) {
st = new StringTokenizer(s);
String keyword = st.nextToken();
switch (lookup(keyword)) {
default:
System.out.println("bogus keyword: " + keyword + "\r");
break;
case ID:
id = st.nextToken();
break;
case ADD: {
String id = st.nextToken();
String hostname = st.nextToken();
String name = st.nextToken(CRLF);
scrabblet.add(id, hostname, name);
}
break;
case DELETE:
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1121
A
P
P
LY
IN
G
JA
V
A
scrabblet.delete(st.nextToken());
break;
case MOVE: {
String ch = st.nextToken();
int x = Integer.parseInt(st.nextToken());
int y = Integer.parseInt(st.nextToken());
scrabblet.move(ch, x, y);
}
break;
case CHAT: {
String from = st.nextToken();
scrabblet.chat(from, st.nextToken(CRLF));
}
break;
case QUIT: {
String from = st.nextToken();
scrabblet.quit(from);
}
break;
case TURN: {
int score = Integer.parseInt(st.nextToken());
scrabblet.turn(score, st.nextToken(CRLF));
}
break;
case ACCEPT: {
String from = st.nextToken();
int seed = Integer.parseInt(st.nextToken());
scrabblet.accept(from, seed);
}
break;
case CHALLENGE: {
String from = st.nextToken();
scrabblet.challenge(from);
}
break;
}
}
}
}
1122 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The Server Code
These last two classes are not part of this applet. Rather, they must be installed and
run separately on the web server that the applet classes are to be loaded from. This
will require the security rights to install and run so-called daemon processes on the
web site, which not many people have. Fortunately, most users of this game will not
be setting up their own servers; more likely, they will just play games connected to
existing ones.
Server.java
Server is the main class for the server side of Scrabblet. Once this is installed on the
web server, you have to run it using the command-line Java interpreter for that system,
as shown here:
C:\java\Scrabblet> java Server
Once running, Server will respond with the following message:
Server listening on port 6564
The Server class starts out by declaring a few variables. The port has to be the same
number, 6564, as we saw in ServerConnection. The idcon Hashtable is used to store
all of the connections to all of the clients. We use a hash table rather than an array to
manage frequent insertion and deletion, which require lots of array copying. The id is
incremented for each new connection. This corresponds to the id instance variable we
saw earlier in the client.
import java.net.*;
import java.io.*;
import java.util.*;
public class Server implements Runnable {
private int port = 6564;
private Hashtable idcon = new Hashtable();
private int id = 0;
static final String CRLF = "\r\n";
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1123
A
P
P
LY
IN
G
JA
V
A
addConnection( )
The addConnection( ) method is called every time a new client connects to our applet.
This method creates a new instance of ClientConnection, described next, to manage
the client. It passes in a reference to this Server, the socket the client connected with,
and the current value of id. Finally, it increments the id to have it ready for the next
connection.
synchronized void addConnection(Socket s) {
ClientConnection con = new ClientConnection(this, s, id);
// we will wait for the ClientConnection to do a clean
// handshake setting up its "name" before calling
// set() below, which makes this connection "live."
id++;
}
set( )
The set( ) method is called from ClientConnection in response to the client telling
us its “name.” set( ) tracks all of the connections in the idcon hash table, and first it
removes this id from the table so that it won’t get duplicates if the client sends its
name twice. The method calls setBusy(false) to signify that this connection is available
to play a game. Then it walks through all of the other connections by enumerating the
keys of the idcon hash table. For all nonbusy connections (those players waiting for
an opponent), set( ) sends an “add” protocol message so they will all know about this
connection.
synchronized void set(String the_id, ClientConnection con) {
idcon.remove(the_id) ;  // make sure we're not in there twice.
con.setBusy(false);
// tell this one about the other clients.
Enumeration e = idcon.keys();
while (e.hasMoreElements()) {
String id = (String)e.nextElement();
ClientConnection other = (ClientConnection) idcon.get(id);
if (!other.isBusy())
con.write("add " + other + CRLF);
}
idcon.put(the_id, con);
broadcast(the_id, "add " + con);
}
1124 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
sendto( )
sendto( ) is called in response to a “to” protocol message. It writes whatever is in the
body string directly to the connection identified by dest.
synchronized void sendto(String dest, String body) {
ClientConnection con = (ClientConnection)idcon.get(dest);
if (con != null) {
con.write(body + CRLF);
}
}
broadcast( )
The broadcast( ) method is used to send a single message, in body, to every single
connection except the one identified in exclude (typically, the sender).
synchronized void broadcast(String exclude, String body) {
Enumeration e = idcon.keys();
while (e.hasMoreElements()) {
String id = (String)e.nextElement();
if (!exclude.equals(id)) {
ClientConnection con = (ClientConnection) idcon.get(id);
con.write(body + CRLF);
}
}
}
delete( )
The delete( ) method is used to tell all of the connected clients to forget they ever heard
of the_id. This is used by clients that are engaged in a game to remove themselves from
other players’ eligibility lists.
synchronized void delete(String the_id) {
broadcast(the_id, "delete " + the_id);
}
kill( )
The kill( ) method is called whenever a client explicitly quits, sending the “quit”
message, or when a client simply dies if the browser quits.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1125
A
P
P
LY
IN
G
JA
V
A
synchronized void kill(ClientConnection c) {
if (idcon.remove(c.getId()) == c) {
delete(c.getId());
}
}
run( )
The run( ) method is the main loop of the server. It creates a new socket on port 6564
and goes into an infinite loop accepting socket connections from clients. It calls
addConnection( ) with each socket that it accepts.
public void run() {
try {
ServerSocket acceptSocket = new ServerSocket(port);
System.out.println("Server listening on port " + port);
while (true) {
Socket s = acceptSocket.accept();
addConnection(s);
}
} catch (IOException e) {
System.out.println("accept loop IOException: " + e);
}
}
main( )
main( ) is, of course, the method run by the Java command-line interpreter. It creates a
new instance of Server and launches a new Thread to run it.
public static void main(String args[]) {
new Thread(new Server()).start();
try {
Thread.currentThread().join();
} catch (InterruptedException e) { }
}
}
1126 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
ClientConnection.java
This class is the mirror image of ServerConnection in the applet. One of these is
created for each client. Its job is to manage all of the I/O to and from a client. The
private instance variables hold all of the states about this client. The Socket is stored in
sock. The buffered reader and output streams are stored in in and out. The host name
of the client machine is kept in host. A reference to the Server instance that created this
client is held in server. The name of the player on this client is stored in name, while
the player’s automatically assigned ID number is held in id. The busy Boolean variable
stores whether or not this client is actively engaged in a game.
import java.net.*;
import java.io.*;
import java.util.*;
class ClientConnection implements Runnable {
private Socket sock;
private BufferedReader in;
private OutputStream out;
private String host;
private Server server;
private static final String CRLF = "\r\n";
private String name = null;    // for humans
private String id;
private boolean busy = false;
ClientConnection( )
The constructor saves the reference to the server and socket and remembers the unique
ID. We wrap an InputStreamReader and a BufferedReader around the input so that it
can call readLine( ) on it. Then it writes the id back to the client to let it know what
number it is. Finally, it creates and starts a new Thread to handle this connection.
public ClientConnection(Server srv, Socket s, int i) {
try {
server = srv;
sock = s;
in = new BufferedReader(new
InputStreamReader(s.getInputStream()));
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1127
A
P
P
LY
IN
G
JA
V
A
out = s.getOutputStream();
host = s.getInetAddress().getHostName();
id = "" + i;
// tell the new one who it is...
write("id " + id + CRLF);
new Thread(this).start();
} catch (IOException e) {
System.out.println("failed ClientConnection " + e);
}
}
toString( )
We override toString( ) so that we can have a clean representation of this connection
for logging.
public String toString() {
return id + " " + host + " " + name;
}
getHost( ), getId( ), isBusy( ), and setBusy( )
We wrap host, id, and busy in public methods to allow read-only access.
public String getHost() {
return host;
}
public String getId() {
return id;
}
public boolean isBusy() {
return busy;
}
public void setBusy(boolean b) {
busy = b;
}
1128 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
close( )
The close( ) method is called if the client explicitly quits or if we get an exception
reading from the socket. We call kill( ) in the server, which removes us from any lists.
Then we close the socket, which also closes both the input and output streams.
public void close() {
server.kill(this);
try {
sock.close();   // closes in and out too.
} catch (IOException e) { }
}
write( )
To write a string to a stream, we have to convert it to an array of bytes, using
getBytes( ).
public void write(String s) {
byte buf[];
buf = s.getBytes();
try {
out.write(buf, 0, buf.length);
} catch (IOException e) {
close();
}
}
readline( )
The readline( ) method merely converts the IOException from readLine( ) into a null
return value.
private String readline() {
try {
return in.readLine();
} catch (IOException e) {
return null;
}
}
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1129
A
P
P
LY
IN
G
JA
V
A
Keywords
This section is very similar to the same part of the ServerConnection class, which
represents the other end of the wire. The static variables and static block shown here
are used to initialize the keys Hashtable with a mapping between the strings in
keystrings and their position in the array—for example, keys.get(“quit”) == QUIT.
The lookup( ) method takes care of unpacking the Integer objects into the right int,
with –1 meaning the keyword was not found.
static private final int NAME = 1;
static private final int QUIT = 2;
static private final int TO = 3;
static private final int DELETE = 4;
static private Hashtable keys = new Hashtable();
static private String keystrings[] = {
"", "name", "quit", "to", "delete"
};
static {
for (int i = 0; i < keystrings.length; i++)
keys.put(keystrings[i], new Integer(i));
}
private int lookup(String s) {
Integer i = (Integer) keys.get(s);
return i == null ? -1 : i.intValue();
}
run( )
run( ) has the loop that manages all of the communication with this client. It uses a
StringTokenizer to parse the input lines, keying off of the first word in each line. The
lookup( ) method just shown is used to look up these first words in the keys hash
table. We then switch, based on the integer value of the keyword. The NAME
message comes from clients when they first gain a human identity. We call set( ) in
the server to get this connection set up. The QUIT message is sent when the client
wants to end its server session. The TO message contains a destination ID and a
message body to be sent to that client. We call sendto( ) in the server to pass the
message along. The last message is DELETE, which is sent by clients that want to
continue being connected but no longer want to have their names listed as available
to play. run( ) sets the busy flag and calls delete( ) in the server, which notifies the
clients that we don’t want to be called.
1130 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public void run() {
String s;
StringTokenizer st;
while ((s = readline()) != null) {
st = new StringTokenizer(s);
String keyword = st.nextToken();
switch (lookup(keyword)) {
default:
System.out.println("bogus keyword: " + keyword + "\r");
break;
case NAME:
name = st.nextToken() +
(st.hasMoreTokens() ? " " + st.nextToken(CRLF) : "");
System.out.println("[" + new Date() + "] " + this + "\r");
server.set(id, this);
break;
case QUIT:
close();
return;
case TO:
String dest = st.nextToken();
String body = st.nextToken(CRLF);
server.sendto(dest, body);
break;
case DELETE:
busy = true;
server.delete(id);
break;
}
}
close();
}
}
Enhancing Scrabblet
This applet represents a complete client/server, multiplayer board game. In the future,
the code in Server and ServerConnection could be extended in many ways. It could be
used to support other turn-based games. It could track and maintain a high-score list
for each game. It could be dynamically extensible to understand new protocol verbs.
C h a p t e r 3 2 : S c r a b b l e t : A M u l t i p l a y e r W o r d G a m e 1131
A
P
P
LY
IN
G
JA
V
A
One such example for the game described in this chapter would be to have a lookup
function that checked a series of submitted words against a dictionary stored on the
server. The server could then be the arbiter for such disputes as whether xyzy is a valid
word. You could also construct a word robot, which would reside on the server but act
like another player and use the dictionary to generate the best word placement from its
current set of seven letters. It could even use a list of pithy quotes to throw into the chat
window after each move. You might want to try making some of these enhancements
yourself.
This applet is intended for entertainment and educational purposes. Any similarity
to any and all commercial products is merely coincidental.
1132 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Appendix A
Using Java’s
Documentation
Comments
1133
As explained in Part I, Java supports three types of comments. The first two arethe // and the /* */. The third type is called a documentation comment. It beginswith the character sequence /**. It ends with */. Documentation comments allow
you to embed information about your program into the program itself. You can then
use the javadoc utility program to extract the information and put it into an HTML file.
Documentation comments make it convenient to document your programs. You have
almost certainly seen documentation generated with javadoc, because that is the way
the Java API library was documented by Sun.
The javadoc Tags
The javadoc utility recognizes the following tags:
Tag Meaning
@author Identifies the author of a class.
@deprecated Specifies that a class or member is deprecated.
{@docRoot} Specifies the path to the root directory of the current
documentation (added by Java 2, version 1.3).
@exception Identifies an exception thrown by a method.
{@inheritDoc} Inherits a comment from the immediate superclass. (Added by
Java 2, version 1.4, but not currently implemented.)
{@link} Inserts an in-line link to another topic.
{@linkplain} Inserts an in-line link to another topic, but the link is displayed
in a plain-text font. (Added by Java 2, version 1.4.)
@param Documents a method’s parameter.
@return Documents a method’s return value.
@see Specifies a link to another topic.
@serial Documents a default serializable field.
@serialData Documents the data written by the writeObject( )
or writeExternal( ) methods.
@serialField Documents an ObjectStreamField component.
@since States the release when a specific change was introduced.
@throws Same as @exception.
{@value} Displays the value of a constant, which must be a static field.
(Added by Java 2, version 1.4.)
@version Specifies the version of a class.
1134 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
As you can see, all document tags begin with an at sign (@). You may also use
other, standard HTML tags in a documentation comment. However, some tags, such as
headings, should not be used, because they disrupt the look of the HTML file produced
by javadoc.
You can use documentation comments to document classes, interfaces, fields,
constructors, and methods. In all cases, the documentation comment must immediately
precede the item being documented. When you are documenting a variable, the
documentation tags you can use are @see, @since, @serial, @serialField, {@value},
and @deprecated. For classes, you can use @see, @author, @since, @deprecated, and
@version. Methods can be documented with @see, @return, @param, @since,
@deprecated, @throws, @serialData, {@inheritDoc}, and @exception. A {@link},
{@docRoot}, or {@linkplain} tag can be used anywhere. Each tag is examined next.
@author
The @author tag documents the author of a class. It has the following syntax:
@author description
Here, description will usually be the name of the person who wrote the class. The
@author tag can be used only in documentation for a class. You may need to specify
the -author option when executing javadoc in order for the @author field to be
included in the HTML documentation.
@deprecated
The @deprecated tag specifies that a class or a member is deprecated. It is recommended
that you include @see or {@link} tags to inform the programmer about available
alternatives. The syntax is the following:
@deprecated description
Here, description is the message that describes the deprecation. Information specified by
the @deprecated tag is recognized by the compiler and is included in the .class file that
is generated. Therefore, the programmer can be given this information when compiling
Java source files. The @deprecated tag can be used in documentation for variables,
methods, and classes.
{@docRoot}
{@docRoot} specifies the path to the root directory of the current documentation.
@exception
The @exception tag describes an exception to a method. It has the following syntax:
@exception exception-name explanation
A p p e n d i x A : U s i n g J a v a ’ s D o c u m e n t a t i o n C o m m e n t s 1135
Here, the fully qualified name of the exception is specified by exception-name;
explanation is a string that describes how the exception can occur. The @exception
tag can only be used in documentation for a method.
{@inheritDoc}
Inherits a comment from the immediate surperclass. (Not currently implemented by
Java 2, version 1.4)
{@link}
The {@link} tag provides an in-line link to additional information. It has the following
syntax:
{@link name text}
Here, name is the name of a class or method to which a link is added, and text is the
string that is displayed.
{@linkplain}
Inserts an in-line link to another topic. The link is displayed in plain-text font. Otherwise,
it is similar to {@link}.
@param
The @param tag documents a parameter to a method. It has the following syntax:
@param parameter-name explanation
Here, parameter-name specifies the name of a parameter to a method. The meaning of
that parameter is described by explanation. The @param tag can be used only in
documentation for a method.
@return
The @return tag describes the return value of a method. It has the following syntax:
@return explanation
Here, explanation describes the type and meaning of the value returned by a method.
The @return tag can be used only in documentation for a method.
@see
The @see tag provides a reference to additional information. Its most commonly used
forms are shown here.
1136 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
@see anchor
@see pkg.class#member text
In the first form, anchor is a link to an absolute or relative URL. In the second form,
pkg.class#member specifies the name of the item, and text is the text displayed for that
item. The text parameter is optional, and if not used, then the item specified by
pkg.class#member is displayed. The member name, too, is optional. Thus, you can
specify a reference to a package, class, or interface in addition to a reference to a
specific method or field. The name can be fully qualified or partially qualified.
However, the dot that precedes the member name (if it exists) must be replaced by
a hash character.
@serial
The @serial tag defines the comment for a default serializable field. It has the
following syntax:
@serial description
Here, description is the comment for that field.
@serialData
The @serialData tag documents the data written by the writeObject( ) and writeExternal( )
methods. It has the following syntax:
@serialData description
Here, description is the comment for that data.
@serialField
The @serialField tag provides comments for an ObjectStreamField component. It has
the following syntax:
@serialField name type description
Here, name is the name of the field, type is its type, and description is the comment for
that field.
@since
The @since tag states that a class or member was introduced in a specific release. It has
the following syntax:
@since release
A p p e n d i x A : U s i n g J a v a ’ s D o c u m e n t a t i o n C o m m e n t s 1137
Here, release is a string that designates the release or version in which this feature
became available. The @since tag can be used in documentation for variables, methods,
and classes.
@throws
The @throws tag has the same meaning as the @exception tag.
{@value}
Displays the value of a constant, which must be a static field.
@version
The @version tag specifies the version of a class. It has the following syntax:
@version info
Here, info is a string that contains version information, typically a version number,
such as 2.2. The @version tag can be used only in documentation for a class. You may
need to specify the -version option when executing javadoc in order for the @version
field to be included in the HTML documentation.
The General Form of a Documentation
Comment
After the beginning /**, the first line or lines become the main description of your class,
variable, or method. After that, you can include one or more of the various @ tags. Each
@ tag must start at the beginning of a new line or follow an asterisk (*) that is at the
start of a line. Multiple tags of the same type should be grouped together. For example,
if you have three @see tags, put them one after the other.
Here is an example of a documentation comment for a class:
/**
* This class draws a bar chart.
* @author Herbert Schildt
* @version 3.2
*/
What javadoc Outputs
The javadoc program takes as input your Java program’s source file and outputs
several HTML files that contain the program’s documentation. Information about each
1138 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
class will be in its own HTML file. javadoc will also output an index and a hierarchy
tree. Other HTML files can be generated. Since different implementations of javadoc
may work differently, you will need to check the instructions that accompany your
Java development system for details specific to your version.
An Example that Uses Documentation
Comments
Following is a sample program that uses documentation comments. Notice the way
each comment immediately precedes the item that it describes. After being processed
by javadoc, the documentation about the SquareNum class will be found in
SquareNum.html.
import java.io.*;
/**
* This class demonstrates documentation comments.
* @author Herbert Schildt
* @version 1.2
*/
public class SquareNum {
/**
* This method returns the square of num.
* This is a multiline description.  You can use
* as many lines as you like.
* @param num The value to be squared.
* @return num squared.
*/
public double square(double num) {
return num * num;
}
/**
* This method inputs a number from the user.
* @return The value input as a double.
* @exception IOException On input error.
* @see IOException
*/
public double getNumber() throws IOException {
// create a BufferedReader using System.in
InputStreamReader isr = new InputStreamReader(System.in);
A p p e n d i x A : U s i n g J a v a ’ s D o c u m e n t a t i o n C o m m e n t s 1139
BufferedReader inData = new BufferedReader(isr);
String str;
str = inData.readLine();
return (new Double(str)).doubleValue();
}
/**
* This method demonstrates square().
* @param args Unused.
* @return Nothing.
* @exception IOException On input error.
* @see IOException
*/
public static void main(String args[])
throws IOException
{
SquareNum ob = new SquareNum();
double val;
System.out.println("Enter value to be squared: ");
val = ob.getNumber();
val = ob.square(val);
System.out.println("Squared value is " + val);
}
}
1140 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Index
& (bitwise AND), 80, 82
& (Boolean logical AND), 92, 94
&& (short-circuit AND), 92
* (multiplication), 31, 74
* (regular expression quantifier),
861
* (used in import statement), 233
@ tags (javadoc), 1134–1138
| (bitwise OR), 80, 82
| (Boolean logical OR), 92
|| (short-circuit OR), 92
[ ], 38, 861, 866
^ (bitwise exclusive OR), 80, 82, 83
^ (Boolean logical exclusive OR), 92
:,  123
, (comma), 38, 116–117
{ }, 27, 28, 35, 38, 63, 254
=, 31, 94–95
= = (relational operator), 90, 91
versus equals( ), 359
= = (Boolean operator), 92
!, 92
!=, 90, 91, 92
/, 74
/* */, 27
/** */, 38, 1134
//, 27–28
<, 91
<<, 80, 84–86
<=, 91
–, 74
– –, 35, 74, 78–80
%, 74, 76
( ), 38, 96–98
. (dot operator), 132, 140, 177–178
. (regular expression wildcard
character), 861, 865
. (separator), 38, 232, 233
+ (addition), 74
+ (concatenation operator), 31, 185,
352–353, 372, 373
+ (regular expression quantifier),
861, 864–865
++, 34–35, 74, 78–80
? (regular expression quantifier),
861, 865–866
?:, 92, 95–96
>, 90
>>, 80, 86–87
>>>, 80, 87–89
>=, 91
; (semicolon), 29, 38, 110
~, 80, 82
A
abs( ), 159
abstract type modifier, 216, 220
Abstract Window Toolkit (AWT),
314, 329, 331, 628, 632, 688, 736
and applet architecture,
631–632
classes, table of, 688–691
components, extending,
790–797
creating stand-alone
windows with, 702–704
AbstractButton class, 927
AbstractCollection class, 448
AbstractList class, 448
AbstractMap class, 466, 467
AbstractSequentialList class, 448
AbstractSet class, 449
accept( ), 543, 545, 602
Access control, 172–176
example program, 229–232
and packages, 224, 227–228
Access specifiers, 28, 172, 227–228
Accessibility API, 948
acos( ), 420
ActionEvent class, 657, 658–659,
739, 752, 777
ActionListener interface, 669, 670,
739, 752, 777
actionPerformed( ), 670, 739
Adapter classes, 680–682
add( ), 443, 445, 446, 447, 454, 455,
692, 736–737, 748, 751, 767, 772,
777
addAll( ), 443, 445, 446
1141
addCookie( ), 965, 967, 975
addElement( ), 486, 488
addFirst( ), 453
addImage( ), 811
addLast( ), 453, 454
addMouseListener( ), 676
addMouseMotionListener( ), 676
addTypeListener( ), 655–656
AdjustmentEvent class, 657,
659–660, 756
AdjustmentListener interface, 669,
670, 756
adjustmentValueChanged( ), 670
after( ), 512, 514
Algorithms, collection, 441,
475–480
ALIGN, 644
allocate( ), 850, 851–852
ALT, 643
AND operator
bitwise (&), 80, 82
Boolean logical (&), 92, 94
short-circuit (&&), 92, 93–94
Animation, cell, 837–841
Apache Software Foundation, 951
append( ), 372–373, 762
Applet, 10, 328–331
architecture, 632
basics, 628–629
colors, setting and
obtaining, 636–638
executing, 330–331
and the Internet, 10
and main( ), 29, 131, 329, 331
outputting to console, 652
passing parameters to,
644–649
request for repaint, 638–641
skeleton, 632–635
and socket connections, 595
string output to, 636
versus application, 10
viewer, 330–331
Applet class, 329, 628–652, 692
methods, table of, 629–631
applet package, 314, 328
applet tag, 16
APPLET tag, HTML, 330–331,
628–629
full syntax for, 643–644
AppletContext interface, 628,
649–651, 1048
methods, table of, 650
AppletStub interface, 628, 652
appletviewer, 330, 628
status window, using, 642
Application builder tools, 887–888
Application versus applet, 10
AreaAveragingScaleFilter class, 821
areFieldsSet, 514
Arguments, 138, 143
command-line, 188
passing, 165–167
Arithmetic operators, 74–80
ArithmeticException, 252, 253, 265
Array(s), 28, 61–70
boundary checks, 64
copying, 408, 411
declaration syntax,
alternative, 70
dynamic, 449–451, 485
initializing, 63–64, 68–69
length instance variable of,
179–181
multidimensional, 64–70
one-dimensional, 61–64
of strings, 187
and strings, 52, 70
arraycopy( ), 408, 411
ArrayIndexOutOfBoundsExceptio
n, 256, 265, 482, 483
ArrayList class, 448, 449–452, 462
Arrays class, 480–484
ArrayStoreException, 265
ASCII character set, 47, 48, 51
and the Internet, 350, 356
asin( ), 420
asList( ), 480
Assembly language, 4, 5
assert( ), 16, 39, 340–343
Assertion, 340–344
AssertionError, 340
Assignment operator(s)
=, 31, 94–95
arithmetic (op=), 74, 76–78
bitwise, 80, 89–90
Boolean, 92
atan( ), 420
atan2( ), 420
AudioClip interface, 628, 651
available( ), 548
AWT. See Abstract Window Toolkit
AWTEvent class, 656–657
bit mask constants, 791
B
B, 4, 5
BASIC, 5
BCPL, 5
Bean Builder, 888, 911–920
Bean Developer Kit (BDK), 888–891
BeanBox, 888
BeanDescriptor class, 907, 909–911
BeanInfo interface, 903–904, 907,
910–911
Beans, Java. See Java Beans
before( ), 512, 514
Bell curve, 525
Berkeley Software Distribution
(BSD), 588
Berners-Lee, Tim, 597
Beyond Photography, The Digital
Darkroom (Holzmann), 816
binarySearch( ), 481
BitSet class, 508–511
methods, table of, 508–510
Bitwise operators, 80–90
Blocks, code. See Code blocks
Boolean
literals, 51
logical operators, 92–94
Boolean class, 401
methods, table of, 401
boolean data type, 42, 48–49
and relational operators, 91
BorderLayout class, 766–768
Borenstein, Nat, 602
break statement, 100, 104, 105–107,
120–124
as form of goto, 122–124
Buffer class, 847–850
methods, table of, 848
Buffer(s), NIO, 847–850
BufferedInputStream class, 316,
555–557
BufferedOutputStream class, 316,
557
BufferedReader class, 318–319, 320,
321, 569–570
BufferedWriter class, 570–571
Buffering, double, 807–811
Button class, 739
extending, 792
Buttons, Swing, 927–934
Byte class, 387, 396, 397
methods defined by, table
of, 387–389
byte data type, 42, 43, 44, 50
ByteArrayInputStream class,
552–553
ByteArrayOutputStream class,
553–554
ByteBuffer class, 848–850, 851, 852
get( ) and put( ) methods,
table of, 849
Bytecode, 11–12, 14, 26, 422
byteValue( ), 381
1142 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C
C, history of, 4–6
and Java, 4, 6, 8, 13
C Programming Language, The
(Kernighan and Ritchie), 5
C++
code, converting to Java,
985–1003
features not in Java, 982–983
history of, 6–7
and Java, 4, 7, 8, 9, 13
Java features not in, 984–985
C# and Java, 9
Calendar class, 514–518, 524
methods defined by, table
of, 515–517
Call-by-reference, 165, 166–167
Call-by-value, 165–166, 167
cancel( ), 532, 533
Canvas class, 693
capacity( ), 369–370
capacityIncrement Vector data
member, 485–486
CardLayout class, 772–775
Case-sensitivity and Java, 26, 28, 37
case statement, 104, 105, 107, 108
Casts, 57–59, 60
using instanceof with,
332–335
catch block(s), 250, 253–254
displaying exception
description within,
254–255
using multiple, 255–257
CGI (Common Gateway
Interface), 950
Channel(s), 550, 551, 562, 596, 602,
847, 850–851
char data type, 42, 47–48, 74
Character(s), 42, 47–48
changing case of, 367–368
classes (regular
expressions), 861, 866
escape sequences, table of, 51
extracting, 355–356
literals, 51
Character class, 397–401
methods, table of, 399–400
Character.Subset class, 380, 401
Character.Unicode class, 380, 401
CharArrayReader class, 566–567
CharArrayWriter class, 567–568
charAt( ), 186–187, 355, 371
CharBuffer class, 436
Charsets, 851
CharSequence interface, 345, 380,
436, 860
charValue( ), 397
Check boxes, 743–747
Swing, 930–932
checkAll( ), 812
Checkbox class, 743
extending, 793
CheckboxGroup class, 745–747
extending, 794
CheckboxMenuItem class, 775, 777
checkID( ), 812
Choice class, 748
extending, 795
Choice controls, 748–750
Class(es), 130–154
abstract, 216–219, 220, 239
access levels of, 228
adapter, 680–682
and code, 26, 228
in collections, storing
user-defined, 460–462
constructor. See
Constructor
definition of, 20
final, 220
general form of, 130–131
inner, 181–184, 682–685
and interfaces, 235, 236–237
libraries, 25, 39
member. See Member, class
name and source file
name, 26
nested, 181
packages as containers for,
224, 227
public, 228
scope, 54
Class class, 416–419, 869, 872
methods, table of, 416–417
.class file, 26, 133
class keyword, 27, 130
ClassCastException, 265, 400, 443,
445, 447, 463, 465, 471, 475, 481,
482, 483
ClassLoader class, 419
methods, table of, 419
ClassNotFoundException, 266
CLASSPATH, 226, 227
clear( ), 443, 445
Client/server model, 589
clone( ), 221, 412–415
Cloneable interface, 380,
412–415, 508
CloneNotSupportedException,
266, 412
close( ), 314, 325
COBOL, 5
CODE, 643
Code blocks, 35–37
CODEBASE, 643
Collection(s), 440–504
algorithms, 475–480
classes, 448–457
framework overview,
441–442
interfaces, 440, 441–448
and legacy classes and
interfaces, 484
modifiable vs unmodifiable,
442–443
storing user-defined classes
in, 460–462
and synchronization, 475, 484
when to use, 504
Collection interface, 442, 443–445
methods defined by, table
of, 443–444
Collections class, 441, 475–480
algorithms defined by, table
of, 476–479
Collection-view, 442, 464
Color class, 712–715
constants 636
ColorsBeanInfo class, 903
Combo boxes, Swing, 934–936
Comment, 27–28
documentation, 38,
1134–1140
Common Gateway interface
(CGI), 950
Comparable interface, 380, 436,
512, 514, 542
Comparator(s), 471–475
Comparator interface, 442, 471–472
compare( ), 471, 472–475
compareTo( ), 359–361, 400–401,
436, 514, 542
compareToIgnoreCase( ), 361
Compilation unit, 25
compile( ), 859–860
Compiler, Java, 26
Compiler class, 423
Component class, 629, 654, 691,
736, 801
componentAdded( ), 670
ComponentEvent class, 657, 660
componentHidden( ), 670
ComponentListener interface, 669,
670
componentMoved( ), 670
componentRemoved( ), 670
I n d e x 1143
componentResized( ), 670
componentShown( ), 670
concat( ), 364
Constants, 37
Constructor(s), 145–149
in class hierarchy, order of
calling, 207–208
default, 136, 147
object parameters for,
163–165
overloading, 159–162
parameterized, 147–149
and super, 197–202, 206
Constructor class, 869–870
Container class, 629, 692, 763
ContainerEvent class, 657, 660
ContainerListener interface,
669, 670
contains( ), 443, 445, 455
containsAll( ), 443, 445
Content pane, 923
contentEquals( ), 368
Context switching, 311
rules for, 275–276
continue statement, 100, 124–126
Control statements, 100–127
Controls, 736–775
fundamentals, 736–737
Convolution filters, 824, 831–837
Cookie class, 963, 967–968
methods, table of, 968–969
Cookies, example servlet using,
975–977
cos( ), 420
countStackFrames( ), 424
createImage( ), 801
CropImageFilter class, 821–823
Currency class, 534–535
methods, table of, 535
currentThread( ), 278
currentTimeMillis( ), 408, 410–411
D
Data type(s)
casting, 57–59, 60
class as, 130, 131
conversion, automatic, 42,
57, 157–159
conversion into string
representation, 353–354,
366–367, 397
promotion of, 44, 59–61
simple, 42–43
wrappers for simple,
380–398
DatagramPacket class, 624
Datagrams, 623–626
server/client example,
624–626
DatagramSocket class, 624, 626
DataInput interface, 561
DataInputStream class, 316
DataOutput interface, 561
DataOutputStream class, 316
Date class, 512–514
methods, table of, 512–513
object comparisons, 514
DateFormat class, 524, 878–879
Decrement operator (– –), 35, 74,
78–80
default statement, 104
DefaultMutableTreeNode class, 942
Delegation event model, 654–656
and Beans, 896–897
event listeners, 654, 656,
669–672
event sources, 654, 655–656,
668–669
using, 673–680
delete operator, 150
delete( ), 374–375, 541
deleteCharAt( ), 374–375
deleteOnExit( ), 541
destroy( ), 407, 632, 634, 635, 951,
955, 956
Destructors versus finalize( ), 151,
1003–1007
Dialog boxes, 782–790
file, 788–790
Dialog class, 783
Dictionary class, 492–494
abstract methods, table
of, 493
digit( ), 400
Dimension class, 689, 694, 711
Directories as File objects, 539,
542–543
creating, 545
dispose( ), 783
DLL, 339, 340
do-while loop, 111–114
Document/view, 531
Domain Naming Service (DNS), 591
DOS and Java, 25
Dot operator (.), 132, 140, 177–178
Double buffering, 807–811
Double class, 381–382, 386
methods, table of, 384–385
double data type, 42, 46–47, 50
doubleValue( ), 381
Drag-and-Drop API, 948
drawArc( ), 709–710
drawImage( ), 802, 809
drawLine( ), 705–706
drawOval( ), 708
drawPolygon( ), 710–711
drawRect( ), 706
drawRoundRect( ), 706–707
drawString( ), 329, 628, 636, 724
Dynamic link library (DLL), 339, 340
Dynamic method dispatch,
211–216
DynamicBillboard applet,
1012–1046
E
E (double constant), 420
Early binding, 220
echoCharIsSet( ), 759
Edit control, 758
elementAt( ), 486, 488
elementCount Vector data
member, 485–486
elementData[ ] Vector data
member, 485–486
elements( ), 493
else, 100–104
empty( ), 490, 491
EMPTY_LIST static variable, 479
EMPTY_MAP static variable, 479
EMPTY_SET static variable, 479
EmptyStackException, 490, 492
enableEvents( ), 790–791
Encapsulation, 19–20, 24–25,
151–152
and access control, 172
end( ), 860
Endian format, 44
endsWith( ), 358
ensureCapacity( ), 370, 451
entrySet( ), 463, 464, 466, 468
enumerate( ), 427, 432
Enumeration interface, 484–485
program demonstrating,
488–490
Environment properties, list of, 412
eolIsSignificant( ), 575
equals( ),  186–187, 221, 357, 401,
443, 445, 471, 472, 482, 494, 513,
514, 594
versus = =, 349
equalsIgnoreCase( ), 357
err, 318, 407
Error class, 251, 261, 270
Errors, run-time, 13, 14, 250
Event, definition of, 655
1144 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Event handling, 654–685
and adapter classes, 680–682
event classes, 656–668
by extending AWT
components, 655, 790–797
See also Delegation event
model
EventListener interface, 440
EventListenerProxy class, 441
EventObject class, 656, 657
EventSetDescriptor class, 908,
910–911
Exception class, 251, 267–269, 270
Exception handling, 13, 14, 114,
120, 250–271, 328
block, general form of,
250–251
and chained exceptions, 16,
250, 269–271
and creating custom
exceptions, 267–269
and default exception
handler, 251–252
Exceptions, built-in run-time, 250,
251, 265
checked, table of, 266
constructors for, 261
unchecked
RuntimeException, table
of, 265–266
exec( ), 402, 403, 406–407
exists( ), 540
exitValue( ), 407
exp( ), 420
Expressions, regular. See Regular
expressions
extends, 190, 246
Externalizable interface, 578
F
false, 39, 48, 51, 91
FALSE, 401
Field class, 869–870
fields, 514
File(s)
I/O, 324–328, 539–545
pointer, 561
source, 25–26, 131, 224
File class, 539–545
methods, demonstration of
some, 540–541
FileChannel class, 850–851
FileDialog class, 788–789
FileFilter interface, 539, 545
FileInputStream class, 316, 324,
325, 548–550
FilenameFilter interface, 539,
543–544
FileNotFoundException, 325, 548,
550, 563
FileOutputStream, 316, 324, 325,
326, 550–551
FileReader class, 562–565
FileWriter class, 565–566
fill( ), 482–483
fillArc( ), 709–710
fillOval( ), 708
fillPolygon( ), 710–711
fillRect( ), 706
fillRoundRect( ), 706–707
FilteredImageSource class, 815, 821
FilterInputStream class, 555
FilterOutputStream class, 555
final
to prevent class
inheritance, 220
to prevent method
overriding, 219–220
variables, 178–179
finalize( ), 150–151, 221
versus C++ destructors,
1003–1007
finally block, 250, 263–264
find( ), 860, 863–864, 865
Firewall, 10, 1070
first( ), 447, 772–773
firstElement( ), 486, 488
firstKey( ), 465
Float class, 381–382, 386
methods, table of, 382–383
float data type, 42, 46, 50
Floating-point(s), 42, 45–47
literals, 50
floatValue( ), 381
FlowLayout class, 764–766
flush( ), 557, 570
FocusEvent class, 657, 661
focusGained( ), 670
FocusListener interface, 669, 670
focusLost( ), 670
Font class, 717–718, 720
methods, table of, 718
FontMetrics class, 724–733
methods, table of, 724–725
Fonts, 717–733
creating and selecting,
720–722
determining available,
719–720
information, obtaining,
722–723
terminology to describe, 724
for loop, 33–35, 36, 114–119
variations, 117–119
forDigit( ), 400
format( ), 878–879
forName( ), 869
FORTRAN, 5, 6
Frame class, 691, 693
Frame window (s), 693–704
creating stand-alone,
702–704
handling events in, 697–702
within applet, creating,
695–697
Frank, Ed, 7
freeMemory( ), 404, 405–406
G
Garbage collection, 150, 151, 405, 437
gc( ), 404, 405–406
GenericServlet class, 953, 955, 960
get( ), 445, 446, 454, 464, 493
and buffers, 849–850
getActionCommand( ), 658, 740, 752
getAddress( ), 594, 624
getAdjustable( ), 659
getAdjustmentType( ), 659, 756
getAlignment( ), 738
getAllByName( ), 593
getAllFonts( ), 719
getAppletContext( ), 650
getAscent( ), 724, 725
getAttribute, 966, 978
getAttributeNames( ), 966, 978
getAudioClip( ), 651
getAvailableFontFamilyNames( ),
719
getBackground( ), 637
getBlue( ), 713–714
getByName( ), 593
getBytes( ), 356, 550
getCause( ), 267, 270
getChannel( ), 550, 551, 562, 596,
602, 850, 851, 853
getChars( ), 355–356, 371–372, 565
getChild( ), 661
getClass( ), 221, 416, 418–419, 872
getClickCount( ), 665
getCodeBase( ), 648–649
getColor( ), 714
getComponent( ), 660
getConstructors( ), 869
getContainer( ), 661
getCookies( ), 963, 976
getData( ), 624
getDateInstance( ), 878
getDateTimeInstance( ), 880
I n d e x 1145
getDeclaredMethods( ), 872
getDefault( ), 524
getDescent( ), 725
getDirectionality( ), 401
getDirectory( ), 789
getDisplayCountry( ), 524
getDisplayLanguage( ), 524
getDisplayName( ), 524
getDocumentBase( ), 648–649, 803
getEchoChar( ), 759
getEventSetDescriptors( ), 903
GetField inner class, 581
GetFieldID( ), 339
getFields( ), 869
getFile( ), 789
getFirst( ), 453
getFont( ), 722
getFontList( ), 720
getForeground( ), 637
getGraphics( ), 639, 705
getGreen( ), 713–714
getHeight( ), 725–726
getHostAddress( ), 594
getHostName( ), 594
getID( ), 657
getImage( ), 801–802, 803, 805
getInetAddress( ), 595
getInputStream( ), 407, 595
getInsets( ), 768–769
getInstance( ), 516, 519
GetIntField( ), 339
getItem( ), 663, 748, 752, 777
getItemCount( ), 748, 752
getItemSelectable( ), 663, 752
getKey( ), 468
getKeyChar( ), 664
getKeyCode( ), 664
getLabel( ), 739, 743, 776
getLast( ), 453
getLeading( ), 725
getLength( ), 624
getLocalGraphicsEnvironment( ),
719
getLocalHost( ), 593
getLocalPort( ), 595
getMaximum( ), 755
getMessage( ), 261, 267
getMethodDescriptors( ), 903
getMethods( ), 869
getMinimum( ), 755
getMinimumSize( ), 764
getModifiers( ), 658–659, 662, 872
getModifiersEx( ), 662
getN( ), 894, 895, 896
getName( ), 277, 279, 540, 873, 968,
971, 976
getNewState( ), 668
GetObjectClass( ), 339
getOldState( ), 668
getOppositeComponent( ), 661
getOppositeWindow( ), 668
getOutputStream( ), 407, 595
getParameter( ), 645, 646, 803
getParent( ), 540
getPoint( ), 665
getPort( ), 595, 624
getPreferredSize( ), 764
getPriority( ), 277, 290
getProperties( ), 408, 498
getProperty( ), 409, 412, 499, 500, 501
getPropertyDescriptors( ), 903
getRed( ), 713–714
getRGB( ), 714
getRuntime( ), 403, 404
getScrollAmount( ), 666
getScrollType( ), 666
getSelectedCheckbox( ), 746
getSelectedIndex( ), 748, 751
getSelectedIndexes( ), 751
getSelectedItem( ), 748, 751
getSelectedItems( ), 751
getSelectedText( ), 759
getServletConfig( ), 956
getServletInfo( ), 956
getSession( ), 971, 978
getSize( ), 694, 711
getSource( ), 656, 741
getStackTrace( ), 267, 435
getState( ), 743, 777
getStateChange( ), 663, 752
getSuperclass( ), 417, 418–419
getText( ), 738, 758
getTime( ), 513, 514
getTimeInstance( ), 879–880
getValue( ), 468, 660, 755, 968,
971, 976
getWheelRotation( ), 666
getWhen( ), 659
getWindow( ), 668
getWriter( ), 954
getX( ), 665
getY( ), 665
GIF image format, 800
Gosling, James, 7, 8
Goto statement, using labeled
break as form of, 122–124
grabPixels( ), 818, 819
Graphics class, 329, 636, 705
drawing methods, 705–711
Graphics
context, 705
sizing, 711–712
GraphicsEnvironment class, 719
GregorianCalendar class, 514,
519–520, 524
GridLayout class, 770–772
group( ), 860
GZIP file format, 536
H
hashCode( ), 221, 401, 494
Hashing, 455
HashMap class, 466, 467–468
HashSet( ), 449, 454–456
Hashtable class, 494–498
and iterators, 497
legacy methods, table of,
495–496
hasMoreElements( ), 485, 506, 507
hasMoreTokens( ), 506, 507
hasNext( ), 459
Header file, creating, 337–338
headMap( ), 465
headSet( ), 447
HEIGHT, 644
Hexadecimals, 50
as character values, 51
Hierarchical abstraction and
classification, 18–19
and inheritance, 20, 190
Histogram, 819
Hoare, C.A.R., 276
Holzmann, Gerard J., 816
HSB color model, 713
HSBtoRGB( ), 713
HSPACE, 644
HTML (Hypertext Markup
Language), 597, 950
file, 330
HTTP, 597, 950
GET requests, handling,
971–973
POST requests, handling,
971, 973–974
server example, caching
proxy, 602–623
server example transaction,
589–590
socket, 589
and URLConnection class,
599–601
HttpServlet class, 963, 969, 971
methods, table of, 969–970
HttpServletRequest interface, 962,
963, 978
methods, table of, 963–964
1146 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
HttpServletResponse interface,
962, 965, 978
methods, table of, 965–966
HttpSession interface, 962, 966
methods, table of, 966–967
HttpSessionBindingEvent class,
963, 971
HttpSessionBindingListener
interface, 962, 967
HttpSessionEvent class, 963, 970–971
I
Icon interface, 924
Icon, rollover, 927
Identifiers, 27, 37
IdentityHashMap class, 466, 471
IEEEremainder( ), 422
if statement, 31–33, 35, 100–104, 170
and boolean variables, 101
nested, 102
switch statement versus, 108
if-else-if ladder, 102–104
IllegalAccessException, 262, 266
IllegalArgumentException, 265,
482, 483
IllegalMonitorStateException, 265
IllegalStateException, 265, 860, 966
IllegalThreadStateException, 265
Image class, 800, 801
ImageConsumer interface, 800,
817–820
ImageFilter class, 821–837
ImageIcon class, 923–924
ImageMenu applet, 1048–1056
ImageObserver interface, 800, 802,
803–807
ImageProducer interface, 800, 801,
815–817
imageUpdate( ), 803, 804–805, 807
flags, table of, 804
Images, 800–841
animation of, 837–841
creating, loading,
displaying, 801–803
double buffering and,
807–811
implements clause, 236
import statement, 232–233
in, 318, 407
Increment operator (++), 34–35, 74,
78–80
indexOf( ), 361–363, 376–377, 445,
446, 486, 488
IndexOutOfBoundsException, 265
Inet4Address class, 592, 626
Inet6Address class, 592, 626
InetAddress class, 592–594, 626
Infinity (IEEE floating-point
specification value), 385
InheritableThreadLocal class,
380, 432
Inheritance, 20–22, 24–25, 176,
190–221
final and, 220
and interfaces, 235,
246–247
multilevel, 203–207
multiple superclass, 192,
1001–1003
init( ), 632, 634, 637, 951, 955, 956
initCause( ), 267, 270
Inline method calls, 220
Inner classes, 181–184, 682–685
InputEvent class, 657, 661–662
InputStream class, 315, 316, 318,
545, 546, 548
methods, table of, 546–547
objects, concatenating,
559–560
InputStreamReader class, 319
insert( ), 373, 762
Insets class, 768–770
Instance of a class, 20, 130
See also Object(s)
Instance variables
accessing, 132, 138, 140, 143
definition of, 20, 131
hiding, 149–150
static, 176–178
as unique to their object,
131, 133
using super to access
hidden, 202–203
instanceof operator, 332–335, 462
InstantiationException, 266
int, 30, 42, 43, 44
and integer literals, 50
Integer(s), 42, 43–45, 81
literals, 50
Integer class, 387, 396, 397
methods, table of, 391–393
Interface(s), 224, 235–247
converting C++ abstract
classes to Java, 995–999
general form of, 235–236
implementing, 236–239
inheritance of, 246–247
reference variables,
237–239, 243
variables, 236, 243–245
interface keyword, 224, 235
Internet, 4, 7, 8, 9, 11
addresses, obtaining, 594
addressing, 590–591
and portability, 10, 11
and security, 10–11,
1070–1071
Internet Protocol (IP)
addresses, 590–591
definition of, 588–589
InterNIC (Internet root server),
594, 596
Interpreter, Java, 26
and main( ), 28, 29
InterruptedException, 266, 278
Introspection, 894–897
Introspector class, 908, 909–911
I/O, 314–328, 538–585
channel-based, 16, 847
classes, list of, 538
console, 29, 114, 314, 318–324
error handling, 328
file, 324–328, 539–545
interfaces, list of, 539
new. See New I/O (NIO)
streams. See Streams
io package. See java.io package
IOException, 319, 325, 326, 546,
547, 548, 558, 562, 565, 571, 578,
580, 581, 595, 599, 601, 851
isAbsolute( ), 541
isAlive( ), 277, 286–289
isAltDown( ), 662
isAltGraphDown( ), 662
isControlDown( ), 662
isDirectory( ), 542
isEditable( ), 759
isEmpty( ), 444, 445, 493
isEnabled( ), 776
isFile( ), 541
isHidden( ), 541
isInfinite( ),  386
isLeapYear( ), 519
isMetaDown( ), 662
isMulticastAddress( ), 594
isN( ), 895
isNaN( ), 386
isPopupTrigger( ), 665
isSet, 514
isShiftDown( ), 662
isTemporary( ), 661
isTimeSet, 514
ItemEvent class, 657, 662–663, 744,
748, 777
ItemListener interface, 669, 671,
743, 748, 777
ItemSelectable interface, 663
I n d e x 1147
itemStateChanged( ), 671, 744, 748
Iteration statements, 109–119
Iterator interface, 441, 442, 457–460
methods, table of, 458
iterator( ), 444, 445, 457, 459
J
Jakarta Project, 951
JAR files, 536, 891–894
JApplet class, 923
Java
API packages, table of core,
844–846
and C, 4, 6, 13
and C++, 4, 7, 8, 9, 13
and C#, 9
design features, 12–15
and DOS and
Windows 3.1, 26
history of, 4, 7–9, 15–16
and the Internet, 4, 7, 11, 15
as interpreted language,
11, 14
keywords, 38–39
as strongly typed
language, 42
versions of, 15
and Windows 95/98 and
Windows NT, 26
and the World Wide Web, 7,
8, 13
Java 2 SDK (Software
Development Kit), 25
Java 2D API, 733, 948
Java Archive (JAR) files, 536,
891–894
Java Beans, 418, 437, 869, 886–920
advantages of, 887
API, 906–911
and constrained properties,
905
customizers, 906
introspection, 894–897
using the BDK to develop,
897–901
using Bean Builder to
develop, 911–920
using bound property of,
902–903
.java file, 25
Java Foundation Classes (JFC), 948
java (Java interpreter), 26
Java Native Interface (JNI), 336
java package, 234
Java Virtual Machine (JVM), 11, 12,
14, 403
java.applet package, 628
java.awt package, 628, 656, 688
classes, tables of, 688–691
java.awt.Dimension class, 869
java.awt.event package, 654, 656,
669, 680
classes, table of, 657–658
java.awt.image package, 800,
840–841
java.beans package, 906–911
classes, table of, 907–909
interfaces, tables of, 907
java.io package, 314, 538–539
java.io.IOException, 114
java.lang package, 234, 318, 380–437
java.lang.image, 818
java.lang.ref package, 437
java.lang.reflect package, 437, 844,
845, 869
classes, table of, 870
java.net package, 588
classes and interfaces, list
of, 592
java.nio package, 436, 538, 550, 551,
562, 596, 602, 844, 845, 847
java.nio.channels package, 845,
847, 850, 851
java.nio.channles.spi package, 845,
847
java.nio.charset package, 846, 847,
851
java.nio.charset.spi package, 846,
847
java.rmi package, 844, 846, 874
java.text package, 844, 846, 878
java.util package, 440–441, 506, 656
java.util.jar package, 506, 536
java.util.regex package, 846, 859
java.util.zip package, 506, 536, 892
javac (Java compiler), 26
javadoc utility program, 1134,
1138–1139
javah.exe, 337, 339
JavaSoft, 888
javax.imageio package, 841
javax.servlet package, 953, 954–960
interfaces and classes, list
of, 955
javax.servlet.http package, 954,
962–971
interfaces and classes, list
of, 962–963
javax.swing package, 923
javax.swing.tree package, 923
JButton class, 927–929
JCheckBox class, 930–932
JComboBox class, 934–936
JComponent class, 924
JFrame class, 913
JLabel class, 914, 924–925
jni.h, 339
jni_md.h, 339
join( ), 277, 286–289
Joy, Bill, 7, 588
JPanel class, 940
JPEG image format, 800
JRadioButton class, 932–934
JscrollBar class, 915
JScrollPane class, 939–940
JSlider class, 914, 915
JTabbedPane class, 936–939
JTable class, 946–948
JTextCompenent class, 925–926
JTextField class, 926
JToggleButton class, 930, 932
JTree class, 941–942
Jump statements, 119–127
Just In Time (JIT) compiler, 12
K
Kernighan, Brian, 5
KeyAdapter class, 681
Keyboard events, handling, 676–680
KeyEvent class, 658, 663–664
KeyListener interface, 669, 671, 676
keyPressed( ), 671, 676, 678
keyReleased( ), 671, 676
keys( ), 493
keySet( ), 464
keyTyped( ), 671, 676, 678
Keywords, table of Java, 39
L
Label, 123, 125
Swing, 924
Label class, 737–739
last( ), 447, 772, 773
lastElement( ), 487, 488
lastIndexOf( ), 361–363, 376–377,
445, 446, 487, 488
lastKey( ), 465
Late binding, 220
LaVallée, David, 1048, 1058
Lavatron applet, 1058–1067
Layout managers, 763–775
LayoutManager interface, 763–764
length( ), 186–187, 351, 369–370
1148 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
length instance variable of arrays,
179–181
Lexer, 506
Libraries, class, 25, 39
Lindholm, Tim, 7
LinkedHashMap class, 466, 470–471
LinkedHashSet class, 449, 456
LinkedList class, 448, 452–454
list( ) and directories, 539, 542–544
List class, 751
extending, 795–796
List controls, 751–754
List interface, 442, 445–447
methods, table of, 446
listFiles( ), 544–545
ListIterator interface, 442, 457–460
methods, table of, 458
ListResourceBundle class, 441
Literals, 37, 50–52
regular expression, 861
load( ), 404, 499, 502–504
loadLibrary( ), 337, 404
Locale class, 523–524, 878, 880
log( ), 420, 960
Logical operators, Boolean, 92–94
long, 42, 43, 45
literal, 50
Long class, 387, 396, 397
methods, table of, 393–395
lookup( ), 875
loop( ), 651
Loops
do-while, 111–114
for. See for loop
infinite, 118–119
nested, 119
and polling, event, 275, 297
while, 109–111
M
main( ), 28, 29, 131, 176
and applets, 329, 331
and command-line
arguments, 188
main (default name of main
thread), 279
MalformedURLException, 597
Manifest files, 892
Map interface, 463–464
methods, table of, 463–464
map( ), 851, 853–854, 856
Map.Entry interface, 466
methods, table of, 466
MappedByteBuffer class, 848, 854
Maps, 441, 462–471
mark( ), 546, 548, 552, 556, 557, 559,
569
markSupported( ), 556, 559, 569
Matcher class, 859, 860–861
matcher( ), 860
matches( ), 368, 860, 862–863,
868–869
Math class, 53, 159, 420–422
rounding methods, table of,
421
max( ), 476, 480
MAX_PRIORITY, 289, 423–424
MAX_RADIX, 398
MAX_VALUE, 382, 387, 398
MediaTracker class, 811–815
Member, class, 20, 158
access, table of, 228
Member interface, 869
Memory
allocation using new, 62, 63,
134–136
management, 13–14
and Runtime class, 405–406
MemoryImageSource class, 815–817
Menu applet, Image-based,
1048–1056
Menu bars and menus, 775–782
Menu class, 775, 776
MenuBar class, 775, 776, 777
MenuItem class, 775, 776, 777
Messaging system, 276–277
Method(s), 20, 131, 138–145
abstract, 216–219
calling, 140, 142
dispatch, dynamic, 211–216
factory, 593
final, 219–220
general form, 138
interface, 236, 237
native, 335–340
overloading, 156–162
overriding, 208–216
and parameters, 138, 142–145
passing object to, 166–167
recursive, 169–172
returning object from,
168–169
returning a value from,
140–142
scope defined by, 54–56
static, 176–178
synchronized, 276, 292–295
and throws clause, 261–262
Method class, 869–870, 872
MIME types, 602, 950
min( ), 477, 480
minimumLayoutSize( ), 764
MIN_PRIORITY, 289, 423–424
MIN_RADIX, 398
MIN_VALUE, 382, 387, 398
mkdir( ), 545
mkdirs( ), 545
Modifier class, 872
methods, table of, 872
Modulus operator (%), 74–76
Molecule Bean, 889–890
Monitor, 276, 292
Mouse events, handling, 673–676
MouseAdapter class, 680, 681
mouseClicked( ), 671, 680
mouseDragged( ), 671, 680
mouseEntered( ), 671
MouseEvent class, 658, 664–665
mouseExited( ), 671
MouseListener interface, 669,
671, 673
MouseMotionAdapter class,
680, 681
MouseMotionListener interface,
656, 669, 671, 673
mouseMoved( ), 671, 680
mousePressed( ), 671
mouseReleased( ), 671
MouseWheelEvent class, 658,
665–666
MouseWheelListener interface,
669, 672, 673
mouseWheelMoved( ), 672
Multitasking, 274, 276
Multithreaded programming, 14,
274–311
context switching rules for,
275–276
effectively using, 311
Observable class, Observer
interface and, 531
and synchronization. See
Synchronization
and threads. See Thread(s)
versus single-threaded
system, 275
MutableTreeNode interface, 942
Mutex, 292
N
NAME, 644
Name-space collisions
instance variables and local
variables, 149–150
packages and, 224
Naming class, 875
I n d e x 1149
NaN, 382, 385
native modifier, 336, 339
Naughton, Patrick, 7
Negative numbers in Java,
representation of, 81
NEGATIVE_INFINITY, 382
NegativeArraySizeException, 265
.Net Framework, 9
Networking, 588–626
new, 62, 63, 134–136, 145, 147,
260, 261
New I/O (NIO), 844, 847–859
copying a file using, 857–859
reading a file using, 851–855
writing to a file using,
855–857
next( ), 459, 772, 773
nextBoolean( ), 525
nextBytes( ), 525
nextDouble( ), 245, 525
nextElement( ), 485, 506, 507
nextFloat( ), 525
nextGaussian( ), 525
nextInt( ), 525
nextLong( ), 525
nextToken( ), 506, 507, 575
NIO. See New I/O (NIO)
NORM_PRIORITY, 289, 423–424
NoSuchElementException, 447,
463, 465
NoSuchFieldException, 266
NoSuchMethodException, 266
NOT operator
bitwise unary (~), 80, 82
Boolean logical unary (!), 92
notepad, 406–407
notify( ), 221, 297–298, 300–302
notifyAll( ), 221, 297–298
notifyObservers( ), 527, 528
null, 39
Null statement, 110
NullPointerException, 261, 266,
447, 463, 465
Number class, 381
NumberFormatException, 266
O
Oak, 7, 15
Object(s), 20, 130, 136
bitwise copy (clone) of,
412–415
creating, 132, 134–136
initialization with
constructor, 145, 147
to method, passing, 166–167
as parameters, 162–165
returning, 168–169
serialization of. See
Serialization
type at run time,
determining, 332–335
Object class, 220–221, 323, 412
methods, table of, 413
Object reference variables
assigning, 137
declaring, 134–136
and dynamic method
dispatch, 211–212
interface, 237–239
to superclass reference
variable, assigning
subclass, 196–197
OBJECT tag, 643
Object-oriented programming
(OOP), 6, 18–25
model in Java, 13
ObjectInput interface, 580
methods defined by, table
of, 580–581
ObjectInputStream class, 581
methods defined by, table
of, 581–583
ObjectOutput interface, 578
methods defined by, table
of, 578
ObjectOutputStream class, 579
methods defined by, table
of, 579–580
Observable class, 527–531
methods, table of, 527
Observer interface, 527, 528
Octals, 50
as character values, 51
openConnection( ), 598–599
Operator(s)
arithmetic, 74–80
assignment, 31, 94–95
bitwise, 80–90
Boolean logical, 92–94
parentheses and, 96–98
precedence, table of, 97
relational, 48, 90–91
ternary, 95–96
OR operator (|)
bitwise, 80, 82
Boolean, 92
OR operator, short-circuit (||), 92,
93–94
OurButton Bean, 890, 891
out output stream, 29, 318, 407
OutputStream class, 315, 316, 322,
323, 545, 547–548
methods, table of, 547
Overloading  methods, 156–162,
210–211
Overriding, method, 208–211
and dynamic method
dispatch, 211–216
using final to prevent,
219–220
P
Package(s), 172, 224–235, 247
access to classes contained
in, 227–228
core Java API, table of,
844–846
defining, 225
importing, 232–235
Package class, 380, 432–434
methods, table of, 433–434
package statement, 225, 232
paint( ), 329, 632, 634–635, 637, 638,
639, 705, 803
Paint mode, setting, 715–717
Panel class, 629, 691, 692, 772
PARAM NAME, 644
Parameters, 28, 138, 142–145
applets and, 645–648
objects as, 162–165
and overloaded
constructors, 160
and overloaded
methods, 156
reference, C++ versus Java,
991–994
parseByte( ), 396
parseInt( ), 396
parseLong( ), 396
parseShort( ), 396
Parsing, 506
Pascal, 5
Pattern class, 859–860
Payne, Jonathan, 7
peek( ), 490, 491
Persistence (Java Beans), 905–896
PI (double constant), 420
PixelGrabber class, 818–820
play( ), 651
Pointers, 71, 136, 982, 985–991
Polling, 275, 297
Polymorphism, 22–25
and dynamic method
dispatch, 211–216
and interfaces, 235,
238–239, 243
and overloaded methods,
156, 159
pop( ), 490, 491
1150 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
PopupMenu class, 782
Port, 589
Portability problem, 8, 10, 11, 14
and data types, 43
and native methods, 340
POSITIVE_INFINITY, 382
pow( ), 421
preferredLayoutSize( ), 764
previous( ), 772, 773
print( ), 31, 322, 323, 354, 561, 572
println( ), 29, 31, 322, 323, 354, 561,
572
PrintStream class, 316, 318, 322, 561
PrintWriter class, 317, 323, 572
private access specifier, 28, 172, 228
and inheritance, 192–193
Process class, 402
methods, table of, 402
Process-based versus thread-based
multitasking, 274
processActionEvent( ), 791,
792, 796
processAdjustmentEvent( ),
791, 797
processComponentEvent( ), 791
processFocusEvent( ), 791
processItemEvent( ), 791, 793,
795, 796
processKeyEvent( ), 791
processMouseEvent( ), 791
processMouseMotionEvent( ), 791
processMouseWheelEvent( ), 791
processTextEvent( ), 791
Programming
multithreaded. See
Multithreaded
programming
object-oriented. See
Object-oriented
programming
structured, 6
Properties, environment, 412
Properties class, 498–504
legacy methods, table
of, 499
PropertyChangeEvent, 902,
905, 908
PropertyDescriptor class, 903, 909,
910–911
PropertyResourceBundle class, 441
protected access specifier, 151,
172, 228
public access specifier, 28, 172, 228
push( ), 490, 491
Push buttons, 739–743
Pushback, 558
PushbackInputStream, 316, 558–559
PushbackReader class, 317, 571–572
put( ), 464, 468, 471, 493
and buffers, 849–850, 856
putAll( ), 464, 471
PutField inner class, 579
R
Radio buttons, 745
Swing, 932–934
random( ), 422
Random class, 245, 422, 524–526
methods, table of, 525
RandomAccess interface, 442, 462
RandomAccessFile class, 316,
561–562
read( ), 315, 319, 325–326, 328, 556,
558, 571. 850, 852
and end-of-file condition,
328
Reader class, 315, 319, 545, 562
methods defined by, table
of, 563
readLine( ), 320, 396, 581, 960
readObject( ), 580, 581
rebind( ), 875
Recursion, 169–172
Reference parameters, C++ versus
Java, 991–994
Reflection, 437, 869–872
regionMatches( ), 358
Regular expressions, 844, 859–869
syntax, 861
wildcards and quantifiers,
861, 864–866
Relational operators, 48, 90–91
Remote interface, 874
Remote method invocation (RMI),
15, 577, 844, 874–878
RemoteException, 874
remove( ), 444, 445, 455, 493, 737
removeAll( ), 444, 445, 737
removeAttribute( ), 967, 978
removeEldestEntry( ), 471
removeElement( ), 487, 488
removeElementAt( ), 487, 488
removeFirst( ), 453
removeLast( ), 453
removeTypeListener( ), 656
renameTo( ), 541
repaint( ), 638–639
demonstration program,
639–641
replace( ), 364–365, 375
replaceAll( ), 368, 861, 867
replaceFirst( ), 368
replaceRange( ), 762
ReplicateScaleFilter class, 821
requestFocus( ), 677
reset( ), 547, 548, 552, 554, 556,
559, 569
resetSyntax( ), 574
ResourceBundle class, 441
resume( ), 15, 305–308, 424, 426
retainAll( ), 444, 445
return statement, 126–127, 138
reverse( ), 373–374
reverseOrder( ), 477, 479
rewind( ), 853, 856
RGB color model, default, 815–816
RGBImageFilter class, 821, 823–837
RGBtoHSB( ), 713
Richards, Martin, 5
Ritchie, Dennis, 5, 588
RMI compiler (rmic), 876–877
rmiregistry (RMI registry), 877
run( ), 277, 280, 423, 531, 532
overriding, 282, 284, 531
using flag variable with,
308–310
runFinalizersOnExit( ), 403, 408
Runnable interface, 277, 380,
423, 531
implementing, 280–282, 284
Run-time
system, Java, 11
type information, 15,
333, 418
Runtime class, 402, 403–407
executing other programs
and, 406–407
memory management and,
405–406
methods, table of, 403–404
RuntimeException class, 251, 261,
265, 270
RuntimePermission class, 380, 434
S
save( ), 498
scanf( ) C function, 318
schedule( ), 532, 533
Scientific notation, 50
Scope(s) in Java, 54–56
Scrabblet applet, 1070–1132
Scroll bars, 754–758
Scroll panes, 939–941
Scrollbar class, 755
extending, 797
search( ), 490, 491
I n d e x 1151
Security problem, 10–11, 1070–1071
and native methods, 340
and servlets, 950–951, 979
SecurityException, 266, 403, 408
SecurityManager class, 434
seek( ), 561
select( ), 748, 752, 759
Selection statements, 100–108
Selectors, 851
Semaphore, 292
SequenceInputStream class, 316,
559–560
Serializable interface, 577
Serialization, 577–585
example program, 583–585
and static variables, 577
and transient variables, 577
Server, 589
proxy, 590
ServerSocket class, 595, 601–602
service( ), 951, 953, 955, 956
Servlet(s), 950–979
advantages of, 950–951
example of simple, 953–954
life cycle of, 951
parameters, reading,
960–962
and security, 950–951, 979
and session tracking,
977–979
using Tomcat to develop,
951–952
Servlet interface, 955–956
methods, table of, 956
ServletConfig interface, 955, 956
ServletContext interface, 955–957
methods, table of, 957
ServletException class, 955, 960
ServletInputStream class, 955, 960
ServletOutputStream class,
955, 960
ServletRequest interface, 953, 955,
957, 960
methods, table of, 958–959
ServletResponse interface, 953,
955, 957
methods, table of, 959
Session tracking, 977–979
Set interface, 442, 447
Set-view, obtaining, 497
set( ), 445, 446, 454
setAlignment( ), 738
setAttribute( ), 967, 978
setBackground( ), 636, 713
setBlockIncrement( ), 755
setBounds( ), 692, 764
setChanged( ), 527
setCharAt( ), 371
setColor( ), 714
setContentType( ), 953
setDefault( ), 524
setEchoCharacter( ), 759
setEditable( ), 759
setEnabled( ), 776
setFont( ), 720
setForeground( ), 636, 713
SetIntField( ), 339
setLabel( ), 739, 743, 776
setLastModified( ), 542
setLayout( ), 763–764
setLength( ), 370–371, 562
setLocation( ), 692
setMaxAge( ), 969, 977
setN( ), 894, 895, 896
setName( ), 278, 279
setPaintMode( ), 715
setPriority( ), 289
setReadOnly( ), 542
setSelectedCheckbox( ), 746
setSize( ), 692, 694, 695
setState( ), 743, 777
setText( ), 738, 758
setTitle( ), 704
setUnitIncrement( ), 755
setValue( ), 755
setValues( ), 755
setVisible( ), 694, 695
setXORMode( ), 715
Sheridan, Mike, 7
Shift operators, bitwise, 80, 84–89
Short class, 387, 396, 397
methods defined by, table
of, 389–390
short data type, 42, 43, 44, 50
show( ), 772, 773
showDocument( ), 649, 650–651,
1048, 1056
showStatus( ), 642, 681
shuffle( ), 477, 479
Sign extension, 87
SimpleBeanInfo class, 903, 909
SimpleDateFormat class, 524,
880–882
SimpleTimeZone class, 522–523
sin( ), 420
SingleThreadModel interface,
955, 957
size( ), 444, 445, 455, 493, 851
Skeletons (RMI), 876–877
skip( ), 548, 556, 558
sleep( ), 277, 278, 279
slice( ), 850
Socket(s)
example program of
client/server, 602–623
overview, 588–589
reserved, 589–590
TCP/IP client, 594–597
TCP/IP server, 601
Socket class, 595–596
SocketChannel class, 850
sort( ), 482
SortedMap interface, 465
methods, table of, 465
SortedSet interface, 442, 447–448
methods, table of, 447–448
Source code, 25–26
split( ), 368, 867–868
sqrt( ), 53, 421
Stack, definition of, 152
Stack class, 490–492
methods, table of, 491
Stack trace, 252, 435
StackTraceElement class, 435
methods, table of,  435
Standard Template Library (STL),
442
start( ), 277, 280, 282, 632, 634, 637,
860, 864
startsWith( ), 358–359
Statements, 29
null, 110
Statements, control
iteration, 100, 109–119
jump, 100, 119–127
selection, 100–108
static, 28, 176–178
stop( ), 15, 308, 632, 634, 635, 651
store( ), 498, 499, 502–504
Stream(s)
benefits, 585
buffered, 555–559
classes, byte, 315, 316,
545–562
classes, character, 315, 317,
545, 562–577
definition of, 314, 538
filtered, 555
predefined, 318
StreamTokenizer class, 574–577
strictfp, 39, 335
StrictMath class, 422
String(s)
arrays of, 187, 188
changing case of characters
in, 367
comparison, 356–361
1152 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
concatenating, 185–186,
352–353. 364, 372–373
creating, 348–351
extracting characters from,
355–356
length, obtaining,
186–187, 351
literals, 52, 351
modifying, 363–366
as objects, 52, 70–71,
181–182, 348
parsing formatted input, 506
reading, 320–322
representations of numbers,
converting, 392–393, 396
searching, 361–363
String class, 28, 185, 348
constructors, 348–350
StringBuffer class, 185, 348, 361,
369–377
StringBufferInputStream class, 539
StringIndexOutOfBounds
exception, 266
StringTokenizer class, 506–508
methods, table of, 507
stringWidth( ), 725, 726
Stroustrup, Bjarne, 7
Stubs (RMI), 876–877
Subclass, 190, 192
subList( ), 446, 447
subMap( ), 465
subSequence( ), 368, 376
subSet( ), 447, 448
substring( ), 363–364, 375
Sun Microsystems, 7, 588
super, 176, 197–203
and superclass constructors,
197–202, 206
and instance variables,
202–203
Superclass, 190, 192
suspend( ), 15, 305–307, 308,
424, 426
Swing, 922–948
and Bean Builder, 891
component classes, list of
some, 922
switch statement, 104–108
Synchronization, 276, 292–297
and collections, 475
and deadlock, 302–304
race condition and, 294
via synchronized block,
295–297
via synchronized method,
292–295
synchronized modifier, 292
used with method, 292,
295
used with object, 295–297
synchronizedList( ), 475, 478
synchronizedSet( ), 475, 478
System class, 29, 318, 407
methods, table of, 408–410
System.err standard error
stream, 318
System.in standard input stream,
318, 319
System.in.read( ), 114
System.out standard output
stream, 318, 322, 323, 324
T
Tabbed panes, 936–939
Tables, Swing, 946–948
tailMap( ), 465
tailSet( ), 447, 448
tan( ), 420
TCP/IP, 15, 588, 1070
client sockets, 594–597
disadvantages of, 623
reserved sockets, 589–590
server sockets, 601–602
See also Transmission
Control Protocol (TCP)
Temple, Robert, 1012
Ternary operator (?:), 92, 95–96
Text fields, 758–761
Swing, 925–926
Text formatting, 878–882
Text output, managing, 723–733
TextArea class, 761–763
textChanged( ), 672
TextComponent class, 758, 761
TextEvent class, 658, 666–667
TextField class, 758, 759
TextListener interface, 669, 672
this, 149–150, 176
Thompson, Ken, 5, 588
Thread(s)
creating, 280–286
daemon, 532
and deadlock, 302–304, 308
definition of, 274
group, 279, 426–432
main, 277, 282, 286
messaging, 276–277, 297–302
possible states of, 275
priorities, 275–276,
289–292, 423
resuming, 305–310, 426
stopping, 305–310
suspending, 277, 278, 279,
305–310, 426
synchronization. See
Synchronization
Thread class, 15, 277,
423–426, 531
constructors, 280, 284, 423
extending, 282–284
methods, table of, 424–426
ThreadGroup class, 426–432
methods, table of, 427–428
ThreadLocal class, 380, 432
throw, 250, 260–261
Throwable class, 251, 254, 267,
269–270, 434
methods defined by, table
of, 267
obtaining object of, 260–261
throws, 250, 261–262, 265
TickTock Bean, 902–903
Time. See Date class
Timer class, 531–534
TimerTask class, 531–534
Timestamps, 659
TimeZone class, 521–522
methods defined by, table
of, 521–522
toArray( ), 444, 445, 451–452
toBinaryString( ), 397
toCharArray( ), 356
toDegrees( ), 422
toHexString( ), 397
Tokens, 506
toLowerCase( ), 367
Tomcat, 951–952
toOctalString( ), 397
Toolkit class, 720
toRadians( ), 422
toString( ), 221, 254, 268, 323,
353–354, 366, 387, 456, 510,
511, 656
totalMemory( ), 404, 405–406
toUpperCase( ), 367
transient modifier, 331–332
translatePoint( ), 665
Transmission Control
Protocol (TCP)
definition of, 589
and stream-based I/O, 592
See also TCP/IP
TreeExpansionEvent class, 942
TreeExpansionListener
interface, 942
TreeMap class, 466, 468–470, 504
TreeNode class, 942
I n d e x 1153
Trees, Swing, 941–946
TreeSet class, 449, 455, 456–457, 504
TreePath class, 942
trim( ), 365–366
trimToSize( ), 451
true, 39, 48, 51, 91
TRUE, 401
True and false in Java, 51, 91
try block(s),  250, 253–254
nested, 257–259
Two's complement, 81
TYPE, 382, 387, 398, 401, 402
Type
casting, 57–59, 60
checking, 42
conversion, automatic, 42,
57, 157–159
promotion, 44, 59–61
Types, data. See Data types
U
UDP protocol, 589, 591–592, 624
UnavailableException class, 955,
960
unhand( ) macro, 342
UnicastRemoteObject, 874
Unicode, 47, 48, 51, 315, 350, 356,
401, 562
Uniform Resource Identifier
(URI), 626
UNIX, 5, 588
UnknownHostException,
593, 595
unmodifiable, 475
unread( ), 558, 571
UnsupportedOperationException,
266, 442–443, 445, 463, 475
update( ), 527, 528, 638, 639, 705
overriding, 635
URI class, 592, 626
URL (Uniform Resource
Locator), 597
specification format, 597
URL class, 597–599, 601
URLConnection class, 599–601
User Datagram Protocol (UDP),
589, 591–592, 624
V
valueBound( ), 967
valueOf( ), 353, 366–367
values( ), 464
valueUnbound( ), 967
van Hoff, Arthur, 7
Variable(s), 52–56
declaration, 30–31, 52–53
definition of, 29, 52
dynamic initialization of, 53
final, 178–179
instance. See Instance
variables
interface, 236
object reference. See Object
reference variables
scope and lifetime of, 54–56
Vector class, 462, 485–490
methods, table of, 486–488
Virtual functions (C++), 213
Virtual machine, Java, 400
void, 28, 138
Void class, 401
volatile modifier, 291–292, 331, 332
VSPACE 644
W
wait( ), 221, 297–298, 300–302
waitFor( ), 407
Warth, Chris, 7
wc( ), 572–577
WeakHashMap class, 466, 467
Web browser
executing applet in, 330,
331, 628
handling older, 644
using status window of, 642
Web server and servlets, 950, 951
while loop, 109–111
Whitespace, 37
from string, removing, 365
whitespaceChars( ), 575
Whois, 596–597
WIDTH, 644
Window
displaying information in,
704–705
frame. See Frame window
fundamentals, 691–693
status, using, 642
Window class, 693, 783
windowActivated( ), 672
windowClosed( ), 672
windowClosing( ), 672, 694, 695
windowDeactivated( ), 672
windowDeiconified( ), 672
WindowEvent class, 658, 667–668
WindowFocusListener interface,
669, 672
windowGainedFocus( ), 672
windowIconified( ), 672
WindowListener interface, 669,
672, 694
windowLostFocus( ), 672
windowOpened( ), 672
Windows 3.1 and Java, 26
Windows 95/98 and Windows NT
and Java, 26
wordChars( ), 575
World Wide Web, 7, 8, 597
wrap( ), 850
Wrappers, simple type, 380–401
write( ), 315, 322–323, 326–328, 850,
855–856
Writer class, 315, 545, 562
methods defined by, table
of, 564
writeObject( ), 578
writeTo( ), 554
X
XOR (exclusive OR) operator (^)
bitwise, 80, 82, 83
Boolean, 92
Y
Yellin, Frank, 7
Z
Zero crossing, 81
ZIP file format, 536
ZLIB file format, 536
1154 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
INTERNATIONAL CONTACT INFORMATION
AUSTRALIA
McGraw-Hill Book Company Australia Pty. Ltd.
TEL +61-2-9415-9899
FAX +61-2-9415-5687
http://www.mcgraw-hill.com.au
books-it_sydney@mcgraw-hill.com
CANADA
McGraw-Hill Ryerson Ltd.
TEL +905-430-5000
FAX +905-430-5020
http://www.mcgrawhill.ca
GREECE, MIDDLE EAST,
NORTHERN AFRICA
McGraw-Hill Hellas
TEL +30-1-656-0990-3-4
FAX +30-1-654-5525
MEXICO (Also serving Latin America)
McGraw-Hill Interamericana Editores S.A. de C.V.
TEL +525-117-1583
FAX +525-117-1589
http://www.mcgraw-hill.com.mx
fernando_castellanos@mcgraw-hill.com
SINGAPORE (Serving Asia)
McGraw-Hill Book Company
TEL +65-863-1580
FAX +65-862-3354
http://www.mcgraw-hill.com.sg
mghasia@mcgraw-hill.com
SOUTH AFRICA
McGraw-Hill South Africa
TEL +27-11-622-7512
FAX +27-11-622-9045
robyn_swanepoel@mcgraw-hill.com
UNITED KINGDOM & EUROPE
(Excluding Southern Europe)
McGraw-Hill Education Europe
TEL +44-1-628-502500
FAX +44-1-628-770224
http://www.mcgraw-hill.co.uk
computing_neurope@mcgraw-hill.com
ALL OTHER INQUIRIES Contact:
Osborne/McGraw-Hill
TEL +1-510-549-6600
FAX +1-510-883-7600
http://www.osborne.com
omg_international@mcgraw-hill.com
Herbert Schildt
0-07-213485-2
Chris H. Pappas & William 
H. Murray, III
0-07-212958-1
Jeffery R. Shapiro
0-07-213381-3
Complete References
For the answers to everything related to your technology, drill as deeply as you 
please into our Complete Reference series. Written by topical authorities, these 
comprehensive resources offer a full range of knowledge, including extensive product
information, theory, step-by-step tutorials, sample projects, and helpful appendixes.
Herbert Schildt
0-07-213084-9
Arthur Griffith
0-07-222405-3
Ron Ben-Natan & Ori Sasson
0-07-222394-4
For more information on these and other Osborne books, visit our Web site at www.osborne.com
