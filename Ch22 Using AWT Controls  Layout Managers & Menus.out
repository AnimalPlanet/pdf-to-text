Chapter 22
Using AWT Controls,
Layout Managers,
and Menus
735
736 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
This chapter continues our exploration of the Abstract Window Toolkit (AWT).It examines the standard controls and layout managers defined by Java. It alsodiscusses menus and the menu bar. The chapter includes a discussion of two
high-level components: the dialog box and the file dialog box. It concludes with
another look at event handling.
Controls are components that allow a user to interact with your application in
various ways—for example, a commonly used control is the push button. A layout
manager automatically positions components within a container. Thus, the appearance
of a window is determined by a combination of the controls that it contains and the
layout manager used to position them.
In addition to the controls, a frame window can also include a standard-style menu bar.
Each entry in a menu bar activates a drop-down menu of options from which the user can
choose. A menu bar is always positioned at the top of a window. Although different in
appearance, menu bars are handled in much the same way as are the other controls.
While it is possible to manually position components within a window, doing so is
quite tedious. The layout manager automates this task. For the first part of this chapter,
which introduces the various controls, the default layout manager will be used. This
displays components in a container using left-to-right, top-to-bottom organization.
Once the controls have been covered, the layout managers will be examined. There
you will see how to better manage the positioning of your controls.
Control Fundamentals
The AWT supports the following types of controls:
■ Labels
■ Push buttons
■ Check boxes
■ Choice lists
■ Lists
■ Scroll bars
■ Text editing
These controls are subclasses of Component.
Adding and Removing Controls
To include a control in a window, you must add it to the window. To do this, you must
first create an instance of the desired control and then add it to a window by calling add( ),
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 737
TH
E
JA
V
A
LIB
R
A
R
Y
which is defined by Container. The add( ) method has several forms. The following form
is the one that is used for the first part of this chapter:
Component add(Component compObj)
Here, compObj is an instance of the control that you want to add. A reference to
compObj is returned. Once a control has been added, it will automatically be visible
whenever its parent window is displayed.
Sometimes you will want to remove a control from a window when the control is
no longer needed. To do this, call remove( ). This method is also defined by Container.
It has this general form:
void remove(Component obj)
Here, obj is a reference to the control you want to remove. You can remove all controls
by calling removeAll( ).
Responding to Controls
Except for labels, which are passive controls, all controls generate events when they are
accessed by the user. For example, when the user clicks on a push button, an event is
sent that identifies the push button. In general, your program simply implements the
appropriate interface and then registers an event listener for each control that you need
to monitor. As explained in Chapter 20, once a listener has been installed, events are
automatically sent to it. In the sections that follow, the appropriate interface for each
control is specified.
Labels
The easiest control to use is a label. A label is an object of type Label, and it contains a
string, which it displays. Labels are passive controls that do not support any interaction
with the user. Label defines the following constructors:
Label( )
Label(String str)
Label(String str, int how)
The first version creates a blank label. The second version creates a label that contains
the string specified by str. This string is left-justified. The third version creates a label that
contains the string specified by str using the alignment specified by how. The value of how
must be one of these three constants: Label.LEFT, Label.RIGHT, or Label.CENTER.
You can set or change the text in a label by using the setText( ) method. You can
obtain the current label by calling getText( ). These methods are shown here:
void setText(String str)
String getText( )
For setText( ), str specifies the new label. For getText( ), the current label is returned.
You can set the alignment of the string within the label by calling setAlignment( ).
To obtain the current alignment, call getAlignment( ). The methods are as follows:
void setAlignment(int how)
int getAlignment( )
Here, how must be one of the alignment constants shown earlier.
The following example creates three labels and adds them to an applet:
// Demonstrate Labels
import java.awt.*;
import java.applet.*;
/*
<applet code="LabelDemo" width=300 height=200>
</applet>
*/
public class LabelDemo extends Applet {
public void init() {
Label one = new Label("One");
Label two = new Label("Two");
Label three = new Label("Three");
// add labels to applet window
add(one);
add(two);
add(three);
}
}
Following is the window created by the LabelDemo applet. Notice that the labels are
organized in the window by the default layout manager. Later, you will see how to
control more precisely the placement of the labels.
738 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 739
TH
E
JA
V
A
LIB
R
A
R
Y
Using Buttons
The most widely used control is the push button. A push button is a component that
contains a label and that generates an event when it is pressed. Push buttons are objects
of type Button. Button defines these two constructors:
Button( )
Button(String str)
The first version creates an empty button. The second creates a button that contains str
as a label.
After a button has been created, you can set its label by calling setLabel( ). You can
retrieve its label by calling getLabel( ). These methods are as follows:
void setLabel(String str)
String getLabel( )
Here, str becomes the new label for the button.
Handling Buttons
Each time a button is pressed, an action event is generated. This is sent to any listeners
that previously registered an interest in receiving action event notifications from that
component. Each listener implements the ActionListener interface. That interface defines
the actionPerformed( ) method, which is called when an event occurs. An ActionEvent
object is supplied as the argument to this method. It contains both a reference to the button
that generated the event and a reference to the string that is the label of the button. Usually,
either value may be used to identify the button, as you will see.
Here is an example that creates three buttons labeled “Yes,” “No,” and “Undecided.”
Each time one is pressed, a message is displayed that reports which button has been
pressed. In this version, the label of the button is used to determine which button has
been pressed. The label is obtained by calling the getActionCommand( ) method on the
ActionEvent object passed to actionPerformed( ).
// Demonstrate Buttons
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="ButtonDemo" width=250 height=150>
</applet>
*/
public class ButtonDemo extends Applet implements ActionListener {
String msg = "";
Button yes, no, maybe;
public void init() {
yes = new Button("Yes");
no = new Button("No");
maybe = new Button("Undecided");
add(yes);
add(no);
add(maybe);
yes.addActionListener(this);
no.addActionListener(this);
maybe.addActionListener(this);
}
public void actionPerformed(ActionEvent ae) {
String str = ae.getActionCommand();
if(str.equals("Yes")) {
msg = "You pressed Yes.";
}
else if(str.equals("No")) {
msg = "You pressed No.";
}
else {
msg = "You pressed Undecided.";
}
740 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
repaint();
}
public void paint(Graphics g) {
g.drawString(msg, 6, 100);
}
}
Sample output from the ButtonDemo program is shown in Figure 22-1.
As mentioned, in addition to comparing button labels, you can also determine
which button has been pressed, by comparing the object obtained from the getSource( )
method to the button objects that you added to the window. To do this, you must keep
a list of the objects when they are added. The following applet shows this approach:
// Recognize Button objects.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="ButtonList" width=250 height=150>
</applet>
*/
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 741
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 22-1. Sample output from the ButtonDemo applet
public class ButtonList extends Applet implements ActionListener {
String msg = "";
Button bList[] = new Button[3];
public void init() {
Button yes = new Button("Yes");
Button no = new Button("No");
Button maybe = new Button("Undecided");
// store references to buttons as added
bList[0] = (Button) add(yes);
bList[1] = (Button) add(no);
bList[2] = (Button) add(maybe);
// register to receive action events
for(int i = 0; i < 3; i++) {
bList[i].addActionListener(this);
}
}
public void actionPerformed(ActionEvent ae) {
for(int i = 0; i < 3; i++) {
if(ae.getSource() == bList[i]) {
msg = "You pressed " + bList[i].getLabel();
}
}
repaint();
}
public void paint(Graphics g) {
g.drawString(msg, 6, 100);
}
}
In this version, the program stores each button reference in an array when the buttons
are added to the applet window. (Recall that the add( ) method returns a reference to the
button when it is added.) Inside actionPerformed( ), this array is then used to determine
which button has been pressed.
For simple applets, it is usually easier to recognize buttons by their labels. However, in
situations in which you will be changing the label inside a button during the execution of
742 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 743
TH
E
JA
V
A
LIB
R
A
R
Y
your program, or using buttons that have the same label, it may be easier to determine
which button has been pushed by using its object reference.
Applying Check Boxes
A check box is a control that is used to turn an option on or off. It consists of a small box
that can either contain a check mark or not. There is a label associated with each check
box that describes what option the box represents. You change the state of a check box
by clicking on it. Check boxes can be used individually or as part of a group. Check
boxes are objects of the Checkbox class.
Checkbox supports these constructors:
Checkbox( )
Checkbox(String str)
Checkbox(String str, boolean on)
Checkbox(String str, boolean on, CheckboxGroup cbGroup)
Checkbox(String str, CheckboxGroup cbGroup, boolean on)
The first form creates a check box whose label is initially blank. The state of the check
box is unchecked. The second form creates a check box whose label is specified by str.
The state of the check box is unchecked. The third form allows you to set the initial
state of the check box. If on is true, the check box is initially checked; otherwise, it is
cleared. The fourth and fifth forms create a check box whose label is specified by str
and whose group is specified by cbGroup. If this check box is not part of a group, then
cbGroup must be null. (Check box groups are described in the next section.) The value
of on determines the initial state of the check box.
To retrieve the current state of a check box, call getState( ). To set its state, call
setState( ). You can obtain the current label associated with a check box by calling
getLabel( ). To set the label, call setLabel( ). These methods are as follows:
boolean getState( )
void setState(boolean on)
String getLabel( )
void setLabel(String str)
Here, if on is true, the box is checked. If it is false, the box is cleared. The string passed
in str becomes the new label associated with the invoking check box.
Handling Check Boxes
Each time a check box is selected or deselected, an item event is generated. This is sent to
any listeners that previously registered an interest in receiving item event notifications
from that component. Each listener implements the ItemListener interface. That interface
744 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
defines the itemStateChanged( ) method. An ItemEvent object is supplied as the argument
to this method. It contains information about the event (for example, whether it was
a selection or deselection).
The following program creates four check boxes. The initial state of the first box is
checked. The status of each check box is displayed. Each time you change the state of
a check box, the status display is updated.
// Demonstrate check boxes.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="CheckboxDemo" width=250 height=200>
</applet>
*/
public class CheckboxDemo extends Applet implements ItemListener {
String msg = "";
Checkbox Win98, winNT, solaris, mac;
public void init() {
Win98 = new Checkbox("Windows 98/XP", null, true);
winNT = new Checkbox("Windows NT/2000");
solaris = new Checkbox("Solaris");
mac = new Checkbox("MacOS");
add(Win98);
add(winNT);
add(solaris);
add(mac);
Win98.addItemListener(this);
winNT.addItemListener(this);
solaris.addItemListener(this);
mac.addItemListener(this);
}
public void itemStateChanged(ItemEvent ie) {
repaint();
}
// Display current state of the check boxes.
public void paint(Graphics g) {
msg = "Current state: ";
g.drawString(msg, 6, 80);
msg = "  Windows 98/XP: " + Win98.getState();
g.drawString(msg, 6, 100);
msg = "  Windows NT/2000: " + winNT.getState();
g.drawString(msg, 6, 120);
msg = "  Solaris: " + solaris.getState();
g.drawString(msg, 6, 140);
msg = "  MacOS: " + mac.getState();
g.drawString(msg, 6, 160);
}
}
Sample output is shown in Figure 22-2.
CheckboxGroup
It is possible to create a set of mutually exclusive check boxes in which one and only one
check box in the group can be checked at any one time. These check boxes are often called
radio buttons, because they act like the station selector on a car radio—only one station can
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 745
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 22-2. Sample output from the CheckboxDemo applet
be selected at any one time. To create a set of mutually exclusive check boxes, you must
first define the group to which they will belong and then specify that group when you
construct the check boxes. Check box groups are objects of type CheckboxGroup. Only
the default constructor is defined, which creates an empty group.
You can determine which check box in a group is currently selected by calling
getSelectedCheckbox( ). You can set a check box by calling setSelectedCheckbox( ).
These methods are as follows:
Checkbox getSelectedCheckbox( )
void setSelectedCheckbox(Checkbox which)
Here, which is the check box that you want to be selected. The previously selected check
box will be turned off.
Here is a program that uses check boxes that are part of a group:
// Demonstrate check box group.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="CBGroup" width=250 height=200>
</applet>
*/
public class CBGroup extends Applet implements ItemListener {
String msg = "";
Checkbox Win98, winNT, solaris, mac;
CheckboxGroup cbg;
public void init() {
cbg = new CheckboxGroup();
Win98 = new Checkbox("Windows 98/XP", cbg, true);
winNT = new Checkbox("Windows NT/2000", cbg, false);
solaris = new Checkbox("Solaris", cbg, false);
mac = new Checkbox("MacOS", cbg, false);
add(Win98);
add(winNT);
add(solaris);
add(mac);
Win98.addItemListener(this);
746 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
winNT.addItemListener(this);
solaris.addItemListener(this);
mac.addItemListener(this);
}
public void itemStateChanged(ItemEvent ie) {
repaint();
}
// Display current state of the check boxes.
public void paint(Graphics g) {
msg = "Current selection: ";
msg += cbg.getSelectedCheckbox().getLabel();
g.drawString(msg, 6, 100);
}
}
Output generated by the CBGroup applet is shown in Figure 22-3. Notice that the
check boxes are now circular in shape.
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 747
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 22-3. Sample output from the CBGroup applet
Choice Controls
The Choice class is used to create a pop-up list of items from which the user may
choose. Thus, a Choice control is a form of menu. When inactive, a Choice component
takes up only enough space to show the currently selected item. When the user clicks
on it, the whole list of choices pops up, and a new selection can be made. Each item
in the list is a string that appears as a left-justified label in the order it is added to the
Choice object. Choice only defines the default constructor, which creates an empty list.
To add a selection to the list, call add( ). It has this general form:
void add(String name)
Here, name is the name of the item being added. Items are added to the list in the order
in which calls to add( ) occur.
To determine which item is currently selected, you may call either getSelectedItem( )
or getSelectedIndex( ). These methods are shown here:
String getSelectedItem( )
int getSelectedIndex( )
The getSelectedItem( ) method returns a string containing the name of the item.
getSelectedIndex( ) returns the index of the item. The first item is at index 0. By
default, the first item added to the list is selected.
To obtain the number of items in the list, call getItemCount( ). You can set the
currently selected item using the select( ) method with either a zero-based integer
index or a string that will match a name in the list. These methods are shown here:
int getItemCount( )
void select(int index)
void select(String name)
Given an index, you can obtain the name associated with the item at that index by
calling getItem( ), which has this general form:
String getItem(int index)
Here, index specifies the index of the desired item.
Handling Choice Lists
Each time a choice is selected, an item event is generated. This is sent to any listeners
that previously registered an interest in receiving item event notifications from that
component. Each listener implements the ItemListener interface. That interface defines
the itemStateChanged( ) method. An ItemEvent object is supplied as the argument to
this method.
748 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 749
TH
E
JA
V
A
LIB
R
A
R
Y
Here is an example that creates two Choice menus. One selects the operating
system. The other selects the browser.
// Demonstrate Choice lists.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="ChoiceDemo" width=300 height=180>
</applet>
*/
public class ChoiceDemo extends Applet implements ItemListener {
Choice os, browser;
String msg = "";
public void init() {
os = new Choice();
browser = new Choice();
// add items to os list
os.add("Windows 98/XP");
os.add("Windows NT/2000");
os.add("Solaris");
os.add("MacOS");
// add items to browser list
browser.add("Netscape 3.x");
browser.add("Netscape 4.x");
browser.add("Netscape 5.x");
browser.add("Netscape 6.x");
browser.add("Internet Explorer 4.0");
browser.add("Internet Explorer 5.0");
browser.add("Internet Explorer 6.0");
browser.add("Lynx 2.4");
browser.select("Netscape 4.x");
// add choice lists to window
add(os);
add(browser);
// register to receive item events
os.addItemListener(this);
browser.addItemListener(this);
}
public void itemStateChanged(ItemEvent ie) {
repaint();
}
// Display current selections.
public void paint(Graphics g) {
msg = "Current OS: ";
msg += os.getSelectedItem();
g.drawString(msg, 6, 120);
msg = "Current Browser: ";
msg += browser.getSelectedItem();
g.drawString(msg, 6, 140);
}
}
Sample output is shown in Figure 22-4.
750 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 22-4. Sample output from the ChoiceDemo applet
Using Lists
The List class provides a compact, multiple-choice, scrolling selection list. Unlike the
Choice object, which shows only the single selected item in the menu, a List object can
be constructed to show any number of choices in the visible window. It can also be
created to allow multiple selections. List provides these constructors:
List( )
List(int numRows)
List(int numRows, boolean multipleSelect)
The first version creates a List control that allows only one item to be selected at any
one time. In the second form, the value of numRows specifies the number of entries in
the list that will always be visible (others can be scrolled into view as needed). In the
third form, if multipleSelect is true, then the user may select two or more items at a time.
If it is false, then only one item may be selected.
To add a selection to the list, call add( ). It has the following two forms:
void add(String name)
void add(String name, int index)
Here, name is the name of the item added to the list. The first form adds items to the
end of the list. The second form adds the item at the index specified by index. Indexing
begins at zero. You can specify –1 to add the item to the end of the list.
For lists that allow only single selection, you can determine which item is currently
selected by calling either getSelectedItem( ) or getSelectedIndex( ). These methods are
shown here:
String getSelectedItem( )
int getSelectedIndex( )
The getSelectedItem( ) method returns a string containing the name of the item. If
more than one item is selected or if no selection has yet been made, null is returned.
getSelectedIndex( ) returns the index of the item. The first item is at index 0. If more
than one item is selected, or if no selection has yet been made, –1 is returned.
For lists that allow multiple selection, you must use either getSelectedItems( ) or
getSelectedIndexes( ), shown here, to determine the current selections:
String[ ] getSelectedItems( )
int[ ] getSelectedIndexes( )
getSelectedItems( ) returns an array containing the names of the currently selected
items. getSelectedIndexes( ) returns an array containing the indexes of the currently
selected items.
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 751
TH
E
JA
V
A
LIB
R
A
R
Y
752 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
To obtain the number of items in the list, call getItemCount( ). You can set the
currently selected item by using the select( ) method with a zero-based integer index.
These methods are shown here:
int getItemCount( )
void select(int index)
Given an index, you can obtain the name associated with the item at that index by
calling getItem( ), which has this general form:
String getItem(int index)
Here, index specifies the index of the desired item.
Handling Lists
To process list events, you will need to implement the ActionListener interface.
Each time a List item is double-clicked, an ActionEvent object is generated. Its
getActionCommand( ) method can be used to retrieve the name of the newly selected
item. Also, each time an item is selected or deselected with a single click, an ItemEvent
object is generated. Its getStateChange( ) method can be used to determine whether a
selection or deselection triggered this event. getItemSelectable( ) returns a reference
to the object that triggered this event.
Here is an example that converts the Choice controls in the preceding section into
List components, one multiple choice and the other single choice:
// Demonstrate Lists.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="ListDemo" width=300 height=180>
</applet>
*/
public class ListDemo extends Applet implements ActionListener {
List os, browser;
String msg = "";
public void init() {
os = new List(4, true);
browser = new List(4, false);
// add items to os list
os.add("Windows 98/XP");
os.add("Windows NT/2000");
os.add("Solaris");
os.add("MacOS");
// add items to browser list
browser.add("Netscape 3.x");
browser.add("Netscape 4.x");
browser.add("Netscape 5.x");
browser.add("Netscape 6.x");
browser.add("Internet Explorer 4.0");
browser.add("Internet Explorer 5.0");
browser.add("Internet Explorer 6.0");
browser.add("Lynx 2.4");
browser.select(1);
// add lists to window
add(os);
add(browser);
// register to receive action events
os.addActionListener(this);
browser.addActionListener(this);
}
public void actionPerformed(ActionEvent ae) {
repaint();
}
// Display current selections.
public void paint(Graphics g) {
int idx[];
msg = "Current OS: ";
idx = os.getSelectedIndexes();
for(int i=0; i<idx.length; i++)
msg += os.getItem(idx[i]) + "  ";
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 753
TH
E
JA
V
A
LIB
R
A
R
Y
g.drawString(msg, 6, 120);
msg = "Current Browser: ";
msg += browser.getSelectedItem();
g.drawString(msg, 6, 140);
}
}
Sample output generated by the ListDemo applet is shown in Figure 22-5. Notice that
the browser list has a scroll bar, since all of the items won’t fit in the number of rows
specified when it is created.
Managing Scroll Bars
Scroll bars are used to select continuous values between a specified minimum and
maximum. Scroll bars may be oriented horizontally or vertically. A scroll bar is actually
a composite of several individual parts. Each end has an arrow that you can click to move
the current value of the scroll bar one unit in the direction of the arrow. The current value
of the scroll bar relative to its minimum and maximum values is indicated by the slider box
(or thumb) for the scroll bar. The slider box can be dragged by the user to a new position.
The scroll bar will then reflect this value. In the background space on either side of the
754 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 22-5. Sample output from the ListDemo applet
thumb, the user can click to cause the thumb to jump in that direction by some increment
larger than 1. Typically, this action translates into some form of page up and page down.
Scroll bars are encapsulated by the Scrollbar class.
Scrollbar defines the following constructors:
Scrollbar( )
Scrollbar(int style)
Scrollbar(int style, int initialValue, int thumbSize, int min, int max)
The first form creates a vertical scroll bar. The second and third forms allow you to
specify the orientation of the scroll bar. If style is Scrollbar.VERTICAL, a vertical scroll
bar is created. If style is Scrollbar.HORIZONTAL, the scroll bar is horizontal. In the
third form of the constructor, the initial value of the scroll bar is passed in initialValue.
The number of units represented by the height of the thumb is passed in thumbSize.
The minimum and maximum values for the scroll bar are specified by min and max.
If you construct a scroll bar by using one of the first two constructors, then you
need to set its parameters by using setValues( ), shown here, before it can be used:
void setValues(int initialValue, int thumbSize, int min, int max)
The parameters have the same meaning as they have in the third constructor just
described.
To obtain the current value of the scroll bar, call getValue( ). It returns the current
setting. To set the current value, call setValue( ). These methods are as follows:
int getValue( )
void setValue(int newValue)
Here, newValue specifies the new value for the scroll bar. When you set a value, the
slider box inside the scroll bar will be positioned to reflect the new value.
You can also retrieve the minimum and maximum values via getMinimum( ) and
getMaximum( ), shown here:
int getMinimum( )
int getMaximum( )
They return the requested quantity.
By default, 1 is the increment added to or subtracted from the scroll bar each
time it is scrolled up or down one line. You can change this increment by calling
setUnitIncrement( ). By default, page-up and page-down increments are 10. You can
change this value by calling setBlockIncrement( ). These methods are shown here:
void setUnitIncrement(int newIncr)
void setBlockIncrement(int newIncr)
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 755
TH
E
JA
V
A
LIB
R
A
R
Y
Handling Scroll Bars
To process scroll bar events, you need to implement the AdjustmentListener interface.
Each time a user interacts with a scroll bar, an AdjustmentEvent object is generated.
Its getAdjustmentType( ) method can be used to determine the type of the adjustment.
The types of adjustment events are as follows:
BLOCK_DECREMENT A page-down event has been generated.
BLOCK_INCREMENT A page-up event has been generated.
TRACK An absolute tracking event has been generated.
UNIT_DECREMENT The line-down button in a scroll bar has been pressed.
UNIT_INCREMENT The line-up button in a scroll bar has been pressed.
The following example creates both a vertical and a horizontal scroll bar. The
current settings of the scroll bars are displayed. If you drag the mouse while inside
the window, the coordinates of each drag event are used to update the scroll bars.
An asterisk is displayed at the current drag position.
// Demonstrate scroll bars.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="SBDemo" width=300 height=200>
</applet>
*/
public class SBDemo extends Applet
implements AdjustmentListener, MouseMotionListener {
String msg = "";
Scrollbar vertSB, horzSB;
public void init() {
int width = Integer.parseInt(getParameter("width"));
int height = Integer.parseInt(getParameter("height"));
vertSB = new Scrollbar(Scrollbar.VERTICAL,
0, 1, 0, height);
horzSB = new Scrollbar(Scrollbar.HORIZONTAL,
0, 1, 0, width);
756 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
add(vertSB);
add(horzSB);
// register to receive adjustment events
vertSB.addAdjustmentListener(this);
horzSB.addAdjustmentListener(this);
addMouseMotionListener(this);
}
public void adjustmentValueChanged(AdjustmentEvent ae) {
repaint();
}
// Update scroll bars to reflect mouse dragging.
public void mouseDragged(MouseEvent me) {
int x = me.getX();
int y = me.getY();
vertSB.setValue(y);
horzSB.setValue(x);
repaint();
}
// Necessary for MouseMotionListener
public void mouseMoved(MouseEvent me) {
}
// Display current value of scroll bars.
public void paint(Graphics g) {
msg = "Vertical: " + vertSB.getValue();
msg += ",  Horizontal: " + horzSB.getValue();
g.drawString(msg, 6, 160);
// show current mouse drag position
g.drawString("*", horzSB.getValue(),
vertSB.getValue());
}
}
Sample output from the SBDemo applet is shown in Figure 22-6.
TH
E
JA
V
A
LIB
R
A
R
Y
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 757
Using a TextField
The TextField class implements a single-line text-entry area, usually called an edit control.
Text fields allow the user to enter strings and to edit the text using the arrow keys, cut and
paste keys, and mouse selections. TextField is a subclass of TextComponent. TextField
defines the following constructors:
TextField( )
TextField(int numChars)
TextField(String str)
TextField(String str, int numChars)
The first version creates a default text field. The second form creates a text field that
is numChars characters wide. The third form initializes the text field with the string
contained in str. The fourth form initializes a text field and sets its width.
TextField (and its superclass TextComponent) provides several methods that allow
you to utilize a text field. To obtain the string currently contained in the text field, call
getText( ). To set the text, call setText( ). These methods are as follows:
String getText( )
void setText(String str)
Here, str is the new string.
758 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 22-6. Sample output from the SBDemo applet
The user can select a portion of the text in a text field. Also, you can select a portion
of text under program control by using select( ). Your program can obtain the currently
selected text by calling getSelectedText( ). These methods are shown here:
String getSelectedText( )
void select(int startIndex, int endIndex)
getSelectedText( ) returns the selected text. The select( ) method selects the characters
beginning at startIndex and ending at endIndex–1.
You can control whether the contents of a text field may be modified by the user
by calling setEditable( ). You can determine editability by calling isEditable( ). These
methods are shown here:
boolean isEditable( )
void setEditable(boolean canEdit)
isEditable( ) returns true if the text may be changed and false if not. In setEditable( ),
if canEdit is true, the text may be changed. If it is false, the text cannot be altered.
There may be times when you will want the user to enter text that is not displayed,
such as a password. You can disable the echoing of the characters as they are typed
by calling setEchoChar( ). This method specifies a single character that the TextField
will display when characters are entered (thus, the actual characters typed will not be
shown). You can check a text field to see if it is in this mode with the echoCharIsSet( )
method. You can retrieve the echo character by calling the getEchoChar( ) method.
These methods are as follows:
void setEchoChar(char ch)
boolean echoCharIsSet( )
char getEchoChar( )
Here, ch specifies the character to be echoed.
Handling a TextField
Since text fields perform their own editing functions, your program generally will not
respond to individual key events that occur within a text field. However, you may want
to respond when the user presses ENTER. When this occurs, an action event is generated.
Here is an example that creates the classic user name and password screen:
// Demonstrate text field.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 759
TH
E
JA
V
A
LIB
R
A
R
Y
<applet code="TextFieldDemo" width=380 height=150>
</applet>
*/
public class TextFieldDemo extends Applet
implements ActionListener {
TextField name, pass;
public void init() {
Label namep = new Label("Name: ", Label.RIGHT);
Label passp = new Label("Password: ", Label.RIGHT);
name = new TextField(12);
pass = new TextField(8);
pass.setEchoChar('?');
add(namep);
add(name);
add(passp);
add(pass);
// register to receive action events
name.addActionListener(this);
pass.addActionListener(this);
}
// User pressed Enter.
public void actionPerformed(ActionEvent ae) {
repaint();
}
public void paint(Graphics g) {
g.drawString("Name: " + name.getText(), 6, 60);
g.drawString("Selected text in name: "
+ name.getSelectedText(), 6, 80);
g.drawString("Password: " + pass.getText(), 6, 100);
}
}
Sample output from the TextFieldDemo applet is shown in Figure 22-7.
760 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Using a TextArea
Sometimes a single line of text input is not enough for a given task. To handle these
situations, the AWT includes a simple multiline editor called TextArea. Following are
the constructors for TextArea:
TextArea( )
TextArea(int numLines, int numChars)
TextArea(String str)
TextArea(String str, int numLines, int numChars)
TextArea(String str, int numLines, int numChars, int sBars)
Here, numLines specifies the height, in lines, of the text area, and numChars specifies its
width, in characters. Initial text can be specified by str. In the fifth form you can specify
the scroll bars that you want the control to have. sBars must be one of these values:
SCROLLBARS_BOTH SCROLLBARS_NONE
SCROLLBARS_HORIZONTAL_ONLY SCROLLBARS_VERTICAL_ONLY
TextArea is a subclass of TextComponent. Therefore, it supports the getText( ), setText( ),
getSelectedText( ), select( ), isEditable( ), and setEditable( ) methods described in the
preceding section.
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 761
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 22-7. Sample output from the TextFieldDemo applet
762 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
TextArea adds the following methods:
void append(String str)
void insert(String str, int index)
void replaceRange(String str, int startIndex, int endIndex)
The append( ) method appends the string specified by str to the end of the current
text. insert( ) inserts the string passed in str at the specified index. To replace text,
call replaceRange( ). It replaces the characters from startIndex to endIndex–1, with
the replacement text passed in str.
Text areas are almost self-contained controls. Your program incurs virtually no
management overhead. Text areas only generate got-focus and lost-focus events.
Normally, your program simply obtains the current text when it is needed.
The following program creates a TextArea control:
// Demonstrate TextArea.
import java.awt.*;
import java.applet.*;
/*
<applet code="TextAreaDemo" width=300 height=250>
</applet>
*/
public class TextAreaDemo extends Applet {
public void init() {
String val = "There are two ways of constructing " +
"a software design.\n" +
"One way is to make it so simple\n" +
"that there are obviously no deficiencies.\n" +
"And the other way is to make it so complicated\n" +
"that there are no obvious deficiencies.\n\n" +
"        -C.A.R. Hoare\n\n" +
"There's an old story about the person who wished\n" +
"his computer were as easy to use as his telephone.\n" +
"That wish has come true,\n" +
"since I no longer know how to use my telephone.\n\n" +
"        -Bjarne Stroustrup, AT&T, (inventor of C++)";
TextArea text = new TextArea(val, 10, 30);
add(text);
}
}
Here is sample output from the TextAreaDemo applet:
Understanding Layout Managers
All of the components that we have shown so far have been positioned by the default
layout manager. As we mentioned at the beginning of this chapter, a layout manager
automatically arranges your controls within a window by using some type of algorithm.
If you have programmed for other GUI environments, such as Windows, then you are
accustomed to laying out your controls by hand. While it is possible to lay out Java
controls by hand, too, you generally won’t want to, for two main reasons. First, it is very
tedious to manually lay out a large number of components. Second, sometimes the width
and height information is not yet available when you need to arrange some control, because
the native toolkit components haven’t been realized. This is a chicken-and-egg situation;
it is pretty confusing to figure out when it is okay to use the size of a given component to
position it relative to another.
Each Container object has a layout manager associated with it. A layout manager
is an instance of any class that implements the LayoutManager interface. The layout
manager is set by the setLayout( ) method. If no call to setLayout( ) is made, then the
default layout manager is used. Whenever a container is resized (or sized for the first
time), the layout manager is used to position each of the components within it.
The setLayout( ) method has the following general form:
void setLayout(LayoutManager layoutObj)
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 763
TH
E
JA
V
A
LIB
R
A
R
Y
Here, layoutObj is a reference to the desired layout manager. If you wish to disable the
layout manager and position components manually, pass null for layoutObj. If you do
this, you will need to determine the shape and position of each component manually,
using the setBounds( ) method defined by Component. Normally, you will want to
use a layout manager.
Each layout manager keeps track of a list of components that are stored by their
names. The layout manager is notified each time you add a component to a container.
Whenever the container needs to be resized, the layout manager is consulted via its
minimumLayoutSize( ) and preferredLayoutSize( ) methods. Each component
that is being managed by a layout manager contains the getPreferredSize( ) and
getMinimumSize( ) methods. These return the preferred and minimum size required
to display each component. The layout manager will honor these requests if at all
possible, while maintaining the integrity of the layout policy. You may override
these methods for controls that you subclass. Default values are provided otherwise.
Java has several predefined LayoutManager classes, several of which are described
next. You can use the layout manager that best fits your application.
FlowLayout
FlowLayout is the default layout manager. This is the layout manager that the preceding
examples have used. FlowLayout implements a simple layout style, which is similar to
how words flow in a text editor. Components are laid out from the upper-left corner, left
to right and top to bottom. When no more components fit on a line, the next one appears
on the next line. A small space is left between each component, above and below, as well
as left and right. Here are the constructors for FlowLayout:
FlowLayout( )
FlowLayout(int how)
FlowLayout(int how, int horz, int vert)
The first form creates the default layout, which centers components and leaves five
pixels of space between each component. The second form lets you specify how each
line is aligned. Valid values for how are as follows:
FlowLayout.LEFT
FlowLayout.CENTER
FlowLayout.RIGHT
These values specify left, center, and right alignment, respectively. The third form
allows you to specify the horizontal and vertical space left between components in
horz and vert, respectively.
Here is a version of the CheckboxDemo applet shown earlier in this chapter,
modified so that it uses left-aligned flow layout.
764 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
// Use left-aligned flow layout.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="FlowLayoutDemo" width=250 height=200>
</applet>
*/
public class FlowLayoutDemo extends Applet
implements ItemListener {
String msg = "";
Checkbox Win98, winNT, solaris, mac;
public void init() {
// set left-aligned flow layout
setLayout(new FlowLayout(FlowLayout.LEFT));
Win98 = new Checkbox("Windows 98/XP", null, true);
winNT = new Checkbox("Windows NT/2000");
solaris = new Checkbox("Solaris");
mac = new Checkbox("MacOS");
add(Win98);
add(winNT);
add(solaris);
add(mac);
// register to receive item events
Win98.addItemListener(this);
winNT.addItemListener(this);
solaris.addItemListener(this);
mac.addItemListener(this);
}
// Repaint when status of a check box changes.
public void itemStateChanged(ItemEvent ie) {
repaint();
}
// Display current state of the check boxes.
public void paint(Graphics g) {
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 765
TH
E
JA
V
A
LIB
R
A
R
Y
msg = "Current state: ";
g.drawString(msg, 6, 80);
msg = "  Windows 98/XP: " + Win98.getState();
g.drawString(msg, 6, 100);
msg = "  Windows NT/2000: " + winNT.getState();
g.drawString(msg, 6, 120);
msg = "  Solaris: " + solaris.getState();
g.drawString(msg, 6, 140);
msg = "  Mac: " + mac.getState();
g.drawString(msg, 6, 160);
}
}
Following is sample output generated by the FlowLayoutDemo applet:
Compare this with the output from the CheckboxDemo applet, shown earlier in
Figure 22-2.
BorderLayout
The BorderLayout class implements a common layout style for top-level windows. It
has four narrow, fixed-width components at the edges and one large area in the center.
The four sides are referred to as north, south, east, and west. The middle area is called
the center. Here are the constructors defined by BorderLayout:
BorderLayout( )
BorderLayout(int horz, int vert)
766 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The first form creates a default border layout. The second allows you to specify the
horizontal and vertical space left between components in horz and vert, respectively.
BorderLayout defines the following constants that specify the regions:
BorderLayout.CENTER BorderLayout.SOUTH
BorderLayout.EAST BorderLayout.WEST
BorderLayout.NORTH
When adding components, you will use these constants with the following form of
add( ), which is defined by Container:
void add(Component compObj, Object region);
Here, compObj is the component to be added, and region specifies where the component
will be added.
Here is an example of a BorderLayout with a component in each layout area:
// Demonstrate BorderLayout.
import java.awt.*;
import java.applet.*;
import java.util.*;
/*
<applet code="BorderLayoutDemo" width=400 height=200>
</applet>
*/
public class BorderLayoutDemo extends Applet {
public void init() {
setLayout(new BorderLayout());
add(new Button("This is across the top."),
BorderLayout.NORTH);
add(new Label("The footer message might go here."),
BorderLayout.SOUTH);
add(new Button("Right"), BorderLayout.EAST);
add(new Button("Left"), BorderLayout.WEST);
String msg = "The reasonable man adapts " +
"himself to the world;\n" +
"the unreasonable one persists in " +
"trying to adapt the world to himself.\n" +
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 767
TH
E
JA
V
A
LIB
R
A
R
Y
"Therefore all progress depends " +
"on the unreasonable man.\n\n" +
"        - George Bernard Shaw\n\n";
add(new TextArea(msg), BorderLayout.CENTER);
}
}
Sample output from the BorderLayoutDemo applet is shown here:
Using Insets
Sometimes you will want to leave a small amount of space between the container
that holds your components and the window that contains it. To do this, override
the getInsets( ) method that is defined by Container. This function returns an Insets
object that contains the top, bottom, left, and right inset to be used when the container
is displayed. These values are used by the layout manager to inset the components
when it lays out the window. The constructor for Insets is shown here:
Insets(int top, int left, int bottom, int right)
The values passed in top, left, bottom, and right specify the amount of space between the
container and its enclosing window.
768 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The getInsets( ) method has this general form:
Insets getInsets( )
When overriding one of these methods, you must return a new Insets object that contains
the inset spacing you desire.
Here is the preceding BorderLayout example modified so that it insets its components
ten pixels from each border. The background color has been set to cyan to help make the
insets more visible.
// Demonstrate BorderLayout with insets.
import java.awt.*;
import java.applet.*;
import java.util.*;
/*
<applet code="InsetsDemo" width=400 height=200>
</applet>
*/
public class InsetsDemo extends Applet {
public void init() {
// set background color so insets can be easily seen
setBackground(Color.cyan);
setLayout(new BorderLayout());
add(new Button("This is across the top."),
BorderLayout.NORTH);
add(new Label("The footer message might go here."),
BorderLayout.SOUTH);
add(new Button("Right"), BorderLayout.EAST);
add(new Button("Left"), BorderLayout.WEST);
String msg = "The reasonable man adapts " +
"himself to the world;\n" +
"the unreasonable one persists in " +
"trying to adapt the world to himself.\n" +
"Therefore all progress depends " +
"on the unreasonable man.\n\n" +
"        - George Bernard Shaw\n\n";
add(new TextArea(msg), BorderLayout.CENTER);
}
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 769
TH
E
JA
V
A
LIB
R
A
R
Y
770 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
// add insets
public Insets getInsets() {
return new Insets(10, 10, 10, 10);
}
}
Output from the InsetsDemo applet is shown here:
GridLayout
GridLayout lays out components in a two-dimensional grid. When you instantiate
a GridLayout, you define the number of rows and columns. The constructors
supported by GridLayout are shown here:
GridLayout( )
GridLayout(int numRows, int numColumns )
GridLayout(int numRows, int numColumns, int horz, int vert)
The first form creates a single-column grid layout. The second form creates a grid
layout with the specified number of rows and columns. The third form allows you
to specify the horizontal and vertical space left between components in horz and vert,
respectively. Either numRows or numColumns can be zero. Specifying numRows as zero
allows for unlimited-length columns. Specifying numColumns as zero allows for
unlimited-length rows.
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 771
TH
E
JA
V
A
LIB
R
A
R
Y
Here is a sample program that creates a 4×4 grid and fills it in with 15 buttons, each
labeled with its index:
// Demonstrate GridLayout
import java.awt.*;
import java.applet.*;
/*
<applet code="GridLayoutDemo" width=300 height=200>
</applet>
*/
public class GridLayoutDemo extends Applet {
static final int n = 4;
public void init() {
setLayout(new GridLayout(n, n));
setFont(new Font("SansSerif", Font.BOLD, 24));
for(int i = 0; i < n; i++) {
for(int j = 0; j < n; j++) {
int k = i * n + j;
if(k > 0)
add(new Button("" + k));
}
}
}
}
Following is the output generated by the GridLayoutDemo applet:
You might try using this example as the starting point for a 15-square puzzle.
CardLayout
The CardLayout class is unique among the other layout managers in that it stores
several different layouts. Each layout can be thought of as being on a separate index
card in a deck that can be shuffled so that any card is on top at a given time. This can
be useful for user interfaces with optional components that can be dynamically enabled
and disabled upon user input. You can prepare the other layouts and have them hidden,
ready to be activated when needed.
CardLayout provides these two constructors:
CardLayout( )
CardLayout(int horz, int vert)
The first form creates a default card layout. The second form allows you to specify the
horizontal and vertical space left between components in horz and vert, respectively.
Use of a card layout requires a bit more work than the other layouts. The cards are
typically held in an object of type Panel. This panel must have CardLayout selected as
its layout manager. The cards that form the deck are also typically objects of type Panel.
Thus, you must create a panel that contains the deck and a panel for each card in the deck.
Next, you add to the appropriate panel the components that form each card. You then add
these panels to the panel for which CardLayout is the layout manager. Finally, you add this
panel to the main applet panel. Once these steps are complete, you must provide some
way for the user to select between cards. One common approach is to include one push
button for each card in the deck.
When card panels are added to a panel, they are usually given a name. Thus, most
of the time, you will use this form of add( ) when adding cards to a panel:
void add(Component panelObj, Object name);
Here, name is a string that specifies the name of the card whose panel is specified
by panelObj.
After you have created a deck, your program activates a card by calling one of the
following methods defined by CardLayout:
void first(Container deck)
void last(Container deck)
void next(Container deck)
void previous(Container deck)
void show(Container deck, String cardName)
Here, deck is a reference to the container (usually a panel) that holds the cards, and
cardName is the name of a card. Calling first( ) causes the first card in the deck to be
772 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
shown. To show the last card, call last( ). To show the next card, call next( ). To show
the previous card, call previous( ). Both next( ) and previous( ) automatically cycle
back to the top or bottom of the deck, respectively. The show( ) method displays the
card whose name is passed in cardName.
The following example creates a two-level card deck that allows the user to select
an operating system. Windows-based operating systems are displayed in one card.
Macintosh and Solaris are displayed in the other card.
// Demonstrate CardLayout.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="CardLayoutDemo" width=300 height=100>
</applet>
*/
public class CardLayoutDemo extends Applet
implements ActionListener, MouseListener {
Checkbox Win98, winNT, solaris, mac;
Panel osCards;
CardLayout cardLO;
Button Win, Other;
public void init() {
Win = new Button("Windows");
Other = new Button("Other");
add(Win);
add(Other);
cardLO = new CardLayout();
osCards = new Panel();
osCards.setLayout(cardLO); // set panel layout to card layout
Win98 = new Checkbox("Windows 98/XP", null, true);
winNT = new Checkbox("Windows NT/2000");
solaris = new Checkbox("Solaris");
mac = new Checkbox("MacOS");
// add Windows check boxes to a panel
Panel winPan = new Panel();
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 773
TH
E
JA
V
A
LIB
R
A
R
Y
774 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
winPan.add(Win98);
winPan.add(winNT);
// Add other OS check boxes to a panel
Panel otherPan = new Panel();
otherPan.add(solaris);
otherPan.add(mac);
// add panels to card deck panel
osCards.add(winPan, "Windows");
osCards.add(otherPan, "Other");
// add cards to main applet panel
add(osCards);
// register to receive action events
Win.addActionListener(this);
Other.addActionListener(this);
// register mouse events
addMouseListener(this);
}
// Cycle through panels.
public void mousePressed(MouseEvent me) {
cardLO.next(osCards);
}
// Provide empty implementations for the other MouseListener methods.
public void mouseClicked(MouseEvent me) {
}
public void mouseEntered(MouseEvent me) {
}
public void mouseExited(MouseEvent me) {
}
public void mouseReleased(MouseEvent me) {
}
public void actionPerformed(ActionEvent ae) {
if(ae.getSource() == Win) {
cardLO.show(osCards, "Windows");
}
else {
cardLO.show(osCards, "Other");
}
}
}
Following is the output generated by the CardLayoutDemo applet. Each card is activated
by pushing its button. You can also cycle through the cards by clicking the mouse.
Menu Bars and Menus
A top-level window can have a menu bar associated with it. A menu bar displays
a list of top-level menu choices. Each choice is associated with a drop-down menu.
This concept is implemented in Java by the following classes: MenuBar, Menu, and
MenuItem. In general, a menu bar contains one or more Menu objects. Each Menu
object contains a list of MenuItem objects. Each MenuItem object represents something
that can be selected by the user. Since Menu is a subclass of MenuItem, a hierarchy of
nested submenus can be created. It is also possible to include checkable menu items.
These are menu options of type CheckboxMenuItem and will have a check mark next
to them when they are selected.
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 775
TH
E
JA
V
A
LIB
R
A
R
Y
776 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
To create a menu bar, first create an instance of MenuBar. This class only defines
the default constructor. Next, create instances of Menu that will define the selections
displayed on the bar. Following are the constructors for Menu:
Menu( )
Menu(String optionName)
Menu(String optionName, boolean removable)
Here, optionName specifies the name of the menu selection. If removable is true, the pop-up
menu can be removed and allowed to float free. Otherwise, it will remain attached to the
menu bar. (Removable menus are implementation-dependent.) The first form creates an
empty menu.
Individual menu items are of type MenuItem. It defines these constructors:
MenuItem( )
MenuItem(String itemName)
MenuItem(String itemName, MenuShortcut keyAccel)
Here, itemName is the name shown in the menu, and keyAccel is the menu shortcut for
this item.
You can disable or enable a menu item by using the setEnabled( ) method. Its form
is shown here:
void setEnabled(boolean enabledFlag)
If the argument enabledFlag is true, the menu item is enabled. If false, the menu item
is disabled.
You can determine an item’s status by calling isEnabled( ). This method is
shown here:
boolean isEnabled( )
isEnabled( ) returns true if the menu item on which it is called is enabled. Otherwise,
it returns false.
You can change the name of a menu item by calling setLabel( ). You can retrieve
the current name by using getLabel( ). These methods are as follows:
void setLabel(String newName)
String getLabel( )
Here, newName becomes the new name of the invoking menu item. getLabel( ) returns
the current name.
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 777
TH
E
JA
V
A
LIB
R
A
R
Y
You can create a checkable menu item by using a subclass of MenuItem called
CheckboxMenuItem. It has these constructors:
CheckboxMenuItem( )
CheckboxMenuItem(String itemName)
CheckboxMenuItem(String itemName, boolean on)
Here, itemName is the name shown in the menu. Checkable items operate as toggles.
Each time one is selected, its state changes. In the first two forms, the checkable entry
is unchecked. In the third form, if on is true, the checkable entry is initially checked.
Otherwise, it is cleared.
You can obtain the status of a checkable item by calling getState( ). You can set it to
a known state by using setState( ). These methods are shown here:
boolean getState( )
void setState(boolean checked)
If the item is checked, getState( ) returns true. Otherwise, it returns false. To check an
item, pass true to setState( ). To clear an item, pass false.
Once you have created a menu item, you must add the item to a Menu object by
using add( ), which has the following general form:
MenuItem add(MenuItem item)
Here, item is the item being added. Items are added to a menu in the order in which the
calls to add( ) take place. The item is returned.
Once you have added all items to a Menu object, you can add that object to the menu
bar by using this version of add( ) defined by MenuBar:
Menu add(Menu menu)
Here, menu is the menu being added. The menu is returned.
Menus only generate events when an item of type MenuItem or CheckboxMenuItem
is selected. They do not generate events when a menu bar is accessed to display a drop-down
menu, for example. Each time a menu item is selected, an ActionEvent object is generated.
Each time a check box menu item is checked or unchecked, an ItemEvent object is
generated. Thus, you must implement the ActionListener and ItemListener interfaces
in order to handle these menu events.
The getItem( ) method of ItemEvent returns a reference to the item that generated
this event. The general form of this method is shown here:
Object getItem( )
Following is an example that adds a series of nested menus to a pop-up window.
The item selected is displayed in the window. The state of the two check box menu
items is also displayed.
// Illustrate menus.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="MenuDemo" width=250 height=250>
</applet>
*/
// Create a subclass of Frame
class MenuFrame extends Frame {
String msg = "";
CheckboxMenuItem debug, test;
MenuFrame(String title) {
super(title);
// create menu bar and add it to frame
MenuBar mbar = new MenuBar();
setMenuBar(mbar);
// create the menu items
Menu file = new Menu("File");
MenuItem item1, item2, item3, item4, item5;
file.add(item1 = new MenuItem("New..."));
file.add(item2 = new MenuItem("Open..."));
file.add(item3 = new MenuItem("Close"));
file.add(item4 = new MenuItem("-"));
file.add(item5 = new MenuItem("Quit..."));
mbar.add(file);
Menu edit = new Menu("Edit");
MenuItem item6, item7, item8, item9;
edit.add(item6 = new MenuItem("Cut"));
edit.add(item7 = new MenuItem("Copy"));
edit.add(item8 = new MenuItem("Paste"));
edit.add(item9 = new MenuItem("-"));
Menu sub = new Menu("Special");
778 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 779
TH
E
JA
V
A
LIB
R
A
R
Y
MenuItem item10, item11, item12;
sub.add(item10 = new MenuItem("First"));
sub.add(item11 = new MenuItem("Second"));
sub.add(item12 = new MenuItem("Third"));
edit.add(sub);
// these are checkable menu items
debug = new CheckboxMenuItem("Debug");
edit.add(debug);
test = new CheckboxMenuItem("Testing");
edit.add(test);
mbar.add(edit);
// create an object to handle action and item events
MyMenuHandler handler = new MyMenuHandler(this);
// register it to receive those events
item1.addActionListener(handler);
item2.addActionListener(handler);
item3.addActionListener(handler);
item4.addActionListener(handler);
item5.addActionListener(handler);
item6.addActionListener(handler);
item7.addActionListener(handler);
item8.addActionListener(handler);
item9.addActionListener(handler);
item10.addActionListener(handler);
item11.addActionListener(handler);
item12.addActionListener(handler);
debug.addItemListener(handler);
test.addItemListener(handler);
// create an object to handle window events
MyWindowAdapter adapter = new MyWindowAdapter(this);
// register it to receive those events
addWindowListener(adapter);
}
public void paint(Graphics g) {
g.drawString(msg, 10, 200);
if(debug.getState())
g.drawString("Debug is on.", 10, 220);
else
g.drawString("Debug is off.", 10, 220);
if(test.getState())
g.drawString("Testing is on.", 10, 240);
else
g.drawString("Testing is off.", 10, 240);
}
}
class MyWindowAdapter extends WindowAdapter {
MenuFrame menuFrame;
public MyWindowAdapter(MenuFrame menuFrame) {
this.menuFrame = menuFrame;
}
public void windowClosing(WindowEvent we) {
menuFrame.setVisible(false);
}
}
class MyMenuHandler implements ActionListener, ItemListener {
MenuFrame menuFrame;
public MyMenuHandler(MenuFrame menuFrame) {
this.menuFrame = menuFrame;
}
// Handle action events
public void actionPerformed(ActionEvent ae) {
String msg = "You selected ";
String arg = (String)ae.getActionCommand();
if(arg.equals("New..."))
msg += "New.";
else if(arg.equals("Open..."))
msg += "Open.";
else if(arg.equals("Close"))
msg += "Close.";
else if(arg.equals("Quit..."))
msg += "Quit.";
else if(arg.equals("Edit"))
msg += "Edit.";
780 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
else if(arg.equals("Cut"))
msg += "Cut.";
else if(arg.equals("Copy"))
msg += "Copy.";
else if(arg.equals("Paste"))
msg += "Paste.";
else if(arg.equals("First"))
msg += "First.";
else if(arg.equals("Second"))
msg += "Second.";
else if(arg.equals("Third"))
msg += "Third.";
else if(arg.equals("Debug"))
msg += "Debug.";
else if(arg.equals("Testing"))
msg += "Testing.";
menuFrame.msg = msg;
menuFrame.repaint();
}
// Handle item events
public void itemStateChanged(ItemEvent ie) {
menuFrame.repaint();
}
}
// Create frame window.
public class MenuDemo extends Applet {
Frame f;
public void init() {
f = new MenuFrame("Menu Demo");
int width = Integer.parseInt(getParameter("width"));
int height = Integer.parseInt(getParameter("height"));
setSize(new Dimension(width, height));
f.setSize(width, height);
f.setVisible(true);
}
public void start() {
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 781
TH
E
JA
V
A
LIB
R
A
R
Y
f.setVisible(true);
}
public void stop() {
f.setVisible(false);
}
}
Sample output from the MenuDemo applet is shown in Figure 22-8.
There is one other menu-related class that you might find interesting: PopupMenu.
It works just like Menu but produces a menu that can be displayed at a specific location.
PopupMenu provides a flexible, useful alternative for some types of menuing situations.
Dialog Boxes
Often, you will want to use a dialog box to hold a set of related controls. Dialog boxes
are primarily used to obtain user input. They are similar to frame windows, except that
dialog boxes are always child windows of a top-level window. Also, dialog boxes don’t
have menu bars. In other respects, dialog boxes function like frame windows. (You can
add controls to them, for example, in the same way that you add controls to a frame
window.) Dialog boxes may be modal or modeless. When a modal dialog box is active,
782 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 22-8. Sample output from the MenuDemo applet
all input is directed to it until it is closed. This means that you cannot access other parts
of your program until you have closed the dialog box. When a modeless dialog box is
active, input focus can be directed to another window in your program. Thus, other
parts of your program remain active and accessible. Dialog boxes are of type Dialog.
Two commonly used constructors are shown here:
Dialog(Frame parentWindow, boolean mode)
Dialog(Frame parentWindow, String title, boolean mode)
Here, parentWindow is the owner of the dialog box. If mode is true, the dialog box is modal.
Otherwise, it is modeless. The title of the dialog box can be passed in title. Generally, you
will subclass Dialog, adding the functionality required by your application.
Following is a modified version of the preceding menu program that displays a
modeless dialog box when the New option is chosen. Notice that when the dialog box
is closed, dispose( ) is called. This method is defined by Window, and it frees all system
resources associated with the dialog box window.
// Demonstrate Dialog box.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
<applet code="DialogDemo" width=250 height=250>
</applet>
*/
// Create a subclass of Dialog.
class SampleDialog extends Dialog implements ActionListener {
SampleDialog(Frame parent, String title) {
super(parent, title, false);
setLayout(new FlowLayout());
setSize(300, 200);
add(new Label("Press this button:"));
Button b;
add(b = new Button("Cancel"));
b.addActionListener(this);
}
public void actionPerformed(ActionEvent ae) {
dispose();
}
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 783
TH
E
JA
V
A
LIB
R
A
R
Y
public void paint(Graphics g) {
g.drawString("This is in the dialog box", 10, 70);
}
}
// Create a subclass of Frame.
class MenuFrame extends Frame {
String msg = "";
CheckboxMenuItem debug, test;
MenuFrame(String title) {
super(title);
// create menu bar and add it to frame
MenuBar mbar = new MenuBar();
setMenuBar(mbar);
// create the menu items
Menu file = new Menu("File");
MenuItem item1, item2, item3, item4;
file.add(item1 = new MenuItem("New..."));
file.add(item2 = new MenuItem("Open..."));
file.add(item3 = new MenuItem("Close"));
file.add(new MenuItem("-"));
file.add(item4 = new MenuItem("Quit..."));
mbar.add(file);
Menu edit = new Menu("Edit");
MenuItem item5, item6, item7;
edit.add(item5 = new MenuItem("Cut"));
edit.add(item6 = new MenuItem("Copy"));
edit.add(item7 = new MenuItem("Paste"));
edit.add(new MenuItem("-"));
Menu sub = new Menu("Special", true);
MenuItem item8, item9, item10;
sub.add(item8 = new MenuItem("First"));
sub.add(item9 = new MenuItem("Second"));
sub.add(item10 = new MenuItem("Third"));
edit.add(sub);
784 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
// these are checkable menu items
debug = new CheckboxMenuItem("Debug");
edit.add(debug);
test = new CheckboxMenuItem("Testing");
edit.add(test);
mbar.add(edit);
// create an object to handle action and item events
MyMenuHandler handler = new MyMenuHandler(this);
// register it to receive those events
item1.addActionListener(handler);
item2.addActionListener(handler);
item3.addActionListener(handler);
item4.addActionListener(handler);
item5.addActionListener(handler);
item6.addActionListener(handler);
item7.addActionListener(handler);
item8.addActionListener(handler);
item9.addActionListener(handler);
item10.addActionListener(handler);
debug.addItemListener(handler);
test.addItemListener(handler);
// create an object to handle window events
MyWindowAdapter adapter = new MyWindowAdapter(this);
// register it to receive those events
addWindowListener(adapter);
}
public void paint(Graphics g) {
g.drawString(msg, 10, 200);
if(debug.getState())
g.drawString("Debug is on.", 10, 220);
else
g.drawString("Debug is off.", 10, 220);
if(test.getState())
g.drawString("Testing is on.", 10, 240);
else
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 785
TH
E
JA
V
A
LIB
R
A
R
Y
g.drawString("Testing is off.", 10, 240);
}
}
class MyWindowAdapter extends WindowAdapter {
MenuFrame menuFrame;
public MyWindowAdapter(MenuFrame menuFrame) {
this.menuFrame = menuFrame;
}
public void windowClosing(WindowEvent we) {
menuFrame.dispose();
}
}
class MyMenuHandler implements ActionListener, ItemListener {
MenuFrame menuFrame;
public MyMenuHandler(MenuFrame menuFrame) {
this.menuFrame = menuFrame;
}
// Handle action events
public void actionPerformed(ActionEvent ae) {
String msg = "You selected ";
String arg = (String)ae.getActionCommand();
// Activate a dialog box when New is selected.
if(arg.equals("New...")) {
msg += "New.";
SampleDialog d = new
SampleDialog(menuFrame, "New Dialog Box");
d.setVisible(true);
}
// Try defining other dialog boxes for these options.
else if(arg.equals("Open..."))
msg += "Open.";
else if(arg.equals("Close"))
msg += "Close.";
else if(arg.equals("Quit..."))
msg += "Quit.";
else if(arg.equals("Edit"))
msg += "Edit.";
else if(arg.equals("Cut"))
msg += "Cut.";
786 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
else if(arg.equals("Copy"))
msg += "Copy.";
else if(arg.equals("Paste"))
msg += "Paste.";
else if(arg.equals("First"))
msg += "First.";
else if(arg.equals("Second"))
msg += "Second.";
else if(arg.equals("Third"))
msg += "Third.";
else if(arg.equals("Debug"))
msg += "Debug.";
else if(arg.equals("Testing"))
msg += "Testing.";
menuFrame.msg = msg;
menuFrame.repaint();
}
public void itemStateChanged(ItemEvent ie) {
menuFrame.repaint();
}
}
// Create frame window.
public class DialogDemo extends Applet {
Frame f;
public void init() {
f = new MenuFrame("Menu Demo");
int width = Integer.parseInt(getParameter("width"));
int height = Integer.parseInt(getParameter("height"));
setSize(width, height);
f.setSize(width, height);
f.setVisible(true);
}
public void start() {
f.setVisible(true);
}
public void stop() {
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 787
TH
E
JA
V
A
LIB
R
A
R
Y
f.setVisible(false);
}
}
Here is sample output from the DialogDemo applet:
On your own, try defining dialog boxes for the other options presented by the menus.
FileDialog
Java provides a built-in dialog box that lets the user specify a file. To create a file dialog
box, instantiate an object of type FileDialog. This causes a file dialog box to be displayed.
Usually, this is the standard file dialog box provided by the operating system. FileDialog
provides these constructors:
FileDialog(Frame parent, String boxName)
FileDialog(Frame parent, String boxName, int how)
FileDialog(Frame parent)
Here, parent is the owner of the dialog box, and boxName is the name displayed in
the box’s title bar. If boxName is omitted, the title of the dialog box is empty. If how is
FileDialog.LOAD, then the box is selecting a file for reading. If how is FileDialog.SAVE,
the box is selecting a file for writing. The third constructor creates a dialog box for selecting
a file for reading.
788 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
FileDialog( ) provides methods that allow you to determine the name of the file
and its path as selected by the user. Here are two examples:
String getDirectory( )
String getFile( )
These methods return the directory and the filename, respectively.
The following program activates the standard file dialog box:
/* Demonstrate File Dialog box.
This is an application, not an applet.
*/
import java.awt.*;
import java.awt.event.*;
// Create a subclass of Frame
class SampleFrame extends Frame {
SampleFrame(String title) {
super(title);
// create an object to handle window events
MyWindowAdapter adapter = new MyWindowAdapter(this);
// register it to receive those events
addWindowListener(adapter);
}
}
class MyWindowAdapter extends WindowAdapter {
SampleFrame sampleFrame;
public MyWindowAdapter(SampleFrame sampleFrame) {
this.sampleFrame = sampleFrame;
}
public void windowClosing(WindowEvent we) {
sampleFrame.setVisible(false);
}
}
// Create frame window.
class FileDialogDemo {
public static void main(String args[]) {
Frame f = new SampleFrame("File Dialog Demo");
f.setVisible(true);
f.setSize(100, 100);
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 789
TH
E
JA
V
A
LIB
R
A
R
Y
FileDialog fd = new FileDialog(f, "File Dialog");
fd.setVisible(true);
}
}
The output generated by this program is shown here. (The precise configuration of the
dialog box may vary.)
Handling Events by Extending AWT
Components
Before concluding our look at the AWT, one more topic needs to be discussed: handling
events by extending AWT components. The delegation event model was introduced in
Chapter 20, and all of the programs in this book so far have used that design. But Java also
allows you to handle events by subclassing AWT components. Doing so allows you to
handle events in much the same way as they were handled under the original 1.0 version
of Java. Of course, this technique is discouraged, because it has the same disadvantages of
the Java 1.0 event model, the main one being inefficiency. Handling events by extending
AWT components is described in this section for completeness. However, this technique
is not used in any other sections of this book.
To extend an AWT component, you must call the enableEvents( ) method of
Component. Its general form is shown here:
protected final void enableEvents(long eventMask)
790 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The eventMask argument is a bit mask that defines the events to be delivered to this
component. The AWTEvent class defines int constants for making this mask. Several
are shown here:
ACTION_EVENT_MASK KEY_EVENT_MASK
ADJUSTMENT_EVENT_MASK MOUSE_EVENT_MASK
COMPONENT_EVENT_MASK MOUSE_MOTION_EVENT_MASK
CONTAINER_EVENT_MASK MOUSE_WHEEL_EVENT_MASK
FOCUS_EVENT_MASK TEXT_EVENT_MASK
INPUT_METHOD_EVENT_MASK WINDOW_EVENT_MASK
ITEM_EVENT_MASK
You must also override the appropriate method from one of your superclasses in
order to process the event. Table 22-1 lists the methods most commonly used and the
classes that provide them.
The following sections provide simple programs that show how to extend several
AWT components.
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 791
TH
E
JA
V
A
LIB
R
A
R
Y
Class Processing Methods
Button processActionEvent( )
Checkbox processItemEvent( )
CheckboxMenuItem processItemEvent( )
Choice processItemEvent( )
Component processComponentEvent( ), processFocusEvent( ),
processKeyEvent( ), processMouseEvent( ),
processMouseMotionEvent( ), processMouseWheelEvent ( )
List processActionEvent( ), processItemEvent( )
MenuItem processActionEvent( )
Scrollbar processAdjustmentEvent( )
TextComponent processTextEvent( )
Table 22-1. Event Processing Methods
Extending Button
The following program creates an applet that displays a button labeled “Test Button”.
When the button is pressed, the string “action event: ” is displayed on the status line
of the applet viewer or browser, followed by a count of the number of button presses.
The program has one top-level class named ButtonDemo2 that extends Applet. A
static integer variable named i is defined and initialized to zero. This records the number
of button pushes. The init( ) method instantiates MyButton and adds it to the applet.
MyButton is an inner class that extends Button. Its constructor uses super to pass
the label of the button to the superclass constructor. It calls enableEvents( ) so that
action events may be received by this object. When an action event is generated,
processActionEvent( ) is called. That method displays a string on the status line and
calls processActionEvent( ) for the superclass. Because MyButton is an inner class, it
has direct access to the showStatus( ) method of ButtonDemo2.
/*
* <applet code=ButtonDemo2 width=200 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
public class ButtonDemo2 extends Applet {
MyButton myButton;
static int i = 0;
public void init() {
myButton = new MyButton("Test Button");
add(myButton);
}
class MyButton extends Button {
public MyButton(String label) {
super(label);
enableEvents(AWTEvent.ACTION_EVENT_MASK);
}
protected void processActionEvent(ActionEvent ae) {
showStatus("action event: " + i++);
super.processActionEvent(ae);
}
}
}
792 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Extending Checkbox
The following program creates an applet that displays three check boxes labeled
“Item 1”, “Item 2”, and “Item 3”. When a check box is selected or deselected, a string
containing the name and state of that check box is displayed on the status line of the
applet viewer or browser.
The program has one top-level class named CheckboxDemo2 that extends Applet.
Its init( ) method creates three instances of MyCheckbox and adds these to the applet.
MyCheckbox is an inner class that extends Checkbox. Its constructor uses super to
pass the label of the check box to the superclass constructor. It calls enableEvents( )
so that item events may be received by this object. When an item event is generated,
processItemEvent( ) is called. That method displays a string on the status line and
calls processItemEvent( ) for the superclass.
/*
* <applet code=CheckboxDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
public class CheckboxDemo2 extends Applet {
MyCheckbox myCheckbox1, myCheckbox2, myCheckbox3;
public void init() {
myCheckbox1 = new MyCheckbox("Item 1");
add(myCheckbox1);
myCheckbox2 = new MyCheckbox("Item 2");
add(myCheckbox2);
myCheckbox3 = new MyCheckbox("Item 3");
add(myCheckbox3);
}
class MyCheckbox extends Checkbox {
public MyCheckbox(String label) {
super(label);
enableEvents(AWTEvent.ITEM_EVENT_MASK);
}
protected void processItemEvent(ItemEvent ie) {
showStatus("Checkbox name/state: " + getLabel() +
"/" + getState());
super.processItemEvent(ie);
}
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 793
TH
E
JA
V
A
LIB
R
A
R
Y
794 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}
}
Extending a Check Box Group
The following program reworks the preceding check box example so that the check
boxes form a check box group. Thus, only one of the check boxes may be selected at
any time.
/*
* <applet code=CheckboxGroupDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
public class CheckboxGroupDemo2 extends Applet {
CheckboxGroup cbg;
MyCheckbox myCheckbox1, myCheckbox2, myCheckbox3;
public void init() {
cbg = new CheckboxGroup();
myCheckbox1 = new MyCheckbox("Item 1", cbg, true);
add(myCheckbox1);
myCheckbox2 = new MyCheckbox("Item 2", cbg, false);
add(myCheckbox2);
myCheckbox3 = new MyCheckbox("Item 3", cbg, false);
add(myCheckbox3);
}
class MyCheckbox extends Checkbox {
public MyCheckbox(String label, CheckboxGroup cbg,
boolean flag) {
super(label, cbg, flag);
enableEvents(AWTEvent.ITEM_EVENT_MASK);
}
protected void processItemEvent(ItemEvent ie) {
showStatus("Checkbox name/state: " + getLabel() +
"/" + getState());
super.processItemEvent(ie);
}
}
}
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 795
TH
E
JA
V
A
LIB
R
A
R
Y
Extending Choice
The following program creates an applet that displays a choice list with items labeled
“Red”, “Green”, and “Blue”. When an entry is selected, a string that contains the name
of the color is displayed on the status line of the applet viewer or browser.
There is one top-level class named ChoiceDemo2 that extends Applet. Its init( )
method creates a choice element and adds it to the applet. MyChoice is an inner class
that extends Choice. It calls enableEvents( ) so that item events may be received by this
object. When an item event is generated, processItemEvent( ) is called. That method
displays a string on the status line and calls processItemEvent( ) for the superclass.
/*
* <applet code=ChoiceDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
public class ChoiceDemo2 extends Applet {
MyChoice choice;
public void init() {
choice = new MyChoice();
choice.add("Red");
choice.add("Green");
choice.add("Blue");
add(choice);
}
class MyChoice extends Choice {
public MyChoice() {
enableEvents(AWTEvent.ITEM_EVENT_MASK);
}
protected void processItemEvent(ItemEvent ie) {
showStatus("Choice selection: " + getSelectedItem());
super.processItemEvent(ie);
}
}
}
Extending List
The following program modifies the preceding example so that it uses a list instead of
a choice menu. There is one top-level class named ListDemo2 that extends Applet. Its
init( ) method creates a list element and adds it to the applet. MyList is an inner class
796 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
that extends List. It calls enableEvents( ) so that both action and item events may be
received by this object. When an entry is selected or deselected, processItemEvent( )
is called. When an entry is double-clicked, processActionEvent( ) is also called. Both
methods display a string and then hand control to the superclass.
/*
* <applet code=ListDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
public class ListDemo2 extends Applet {
MyList list;
public void init() {
list = new MyList();
list.add("Red");
list.add("Green");
list.add("Blue");
add(list);
}
class MyList extends List {
public MyList() {
enableEvents(AWTEvent.ITEM_EVENT_MASK |
AWTEvent.ACTION_EVENT_MASK);
}
protected void processActionEvent(ActionEvent ae) {
showStatus("Action event: " + ae.getActionCommand());
super.processActionEvent(ae);
}
protected void processItemEvent(ItemEvent ie) {
showStatus("Item event: " + getSelectedItem());
super.processItemEvent(ie);
}
}
}
Extending Scrollbar
The following program creates an applet that displays a scroll bar. When this control
is manipulated, a string is displayed on the status line of the applet viewer or browser.
That string includes the value represented by the scroll bar.
There is one top-level class named ScrollbarDemo2 that extends Applet. Its init( )
method creates a scroll bar element and adds it to the applet. MyScrollbar is an inner
class that extends Scrollbar. It calls enableEvents( ) so that adjustment events may be
received by this object. When the scroll bar is manipulated, processAdjustmentEvent( )
is called. When an entry is selected, processAdjustmentEvent( ) is called. It displays
a string and then hands control to the superclass.
/*
* <applet code=ScrollbarDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
public class ScrollbarDemo2 extends Applet {
MyScrollbar myScrollbar;
public void init() {
myScrollbar = new MyScrollbar(Scrollbar.HORIZONTAL,
0, 1, 0, 100);
add(myScrollbar);
}
class MyScrollbar extends Scrollbar {
public MyScrollbar(int style, int initial, int thumb,
int min, int max) {
super(style, initial, thumb, min, max);
enableEvents(AWTEvent.ADJUSTMENT_EVENT_MASK);
}
protected void processAdjustmentEvent(AdjustmentEvent ae) {
showStatus("Adjustment event: " + ae.getValue());
setValue(getValue());
super.processAdjustmentEvent(ae);
}
}
}
C h a p t e r 2 2 : U s i n g A W T C o n t r o l s , L a y o u t M a n a g e r s , a n d M e n u s 797
TH
E
JA
V
A
LIB
R
A
R
Y
Exploring the Controls, Menus, and Layout
Managers
This chapter has discussed the classes that comprise the AWT controls, menus, and
layout managers. However, the AWT provides a rich programming environment that
you will want to continue exploring on your own. Here are some suggestions:
■ Try nesting a canvas inside an applet panel.
■ Explore the FileDialog component.
■ Experiment with manual positioning of components by using setBounds( ).
■ Try nesting controls within panels to gain more control over layouts.
■ Create your own layout manager by implementing the LayoutManager
interface.
■ Explore PopupMenu.
The more you know about the AWT components, the more control you will have over
the look, feel, and performance of your applets and applications.
In the next chapter, we will examine one more of the AWT’s classes: Image. This
class is used to support imaging and animation.
798 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Chapter 23
Images
799
