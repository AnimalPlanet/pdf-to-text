Chapter 23
Images
799
800 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
This chapter examines the AWT’s Image class and the java.awt.image package.Together, they provide support for imaging (the display and manipulation ofgraphical images). An image is simply a rectangular graphical object. Images are
a key component of web design. In fact, the inclusion of the <img> tag in the Mosaic
browser at NCSA (National Center for Supercomputer Applications) is what caused
the Web to begin to grow explosively in 1993. This tag was used to include an image
inline with the flow of hypertext. Java expands upon this basic concept, allowing
images to be managed under program control. Because of its importance, Java provides
extensive support for imaging.
Images are objects of the Image class, which is part of the java.awt package. Images
are manipulated using the classes found in the java.awt.image package. There are a
large number of imaging classes and interfaces defined by java.awt.image and it is not
possible to examine them all. Instead, we will focus on those that form the foundation
of imaging. Here are the java.awt.image classes discussed in this chapter:
CropImageFilter MemoryImageSource
FilteredImageSource PixelGrabber
ImageFilter RGBImageFilter
These are the interfaces that we will use.
ImageConsumer ImageObserver ImageProducer
Also examined is the MediaTracker class, which is part of java.awt.
File Formats
Originally, web images could only be in GIF format. The GIF image format was created
by CompuServe in 1987 to make it possible for images to be viewed while online, so it
was well suited to the Internet. GIF images can have only up to 256 colors each. This
limitation caused the major browser vendors to add support for JPEG images in 1995.
The JPEG format was created by a group of photographic experts to store full-color-
spectrum, continuous-tone images. These images, when properly created, can be of
much higher fidelity as well as more highly compressed than a GIF encoding of the
same source image. In almost all cases, you will never care or notice which format is
being used in your programs. The Java image classes abstract the differences behind a
clean interface.
Image Fundamentals: Creating, Loading,
and Displaying
There are three common operations that occur when you work with images: creating
an image, loading an image, and displaying an image. In Java, the Image class is used
to refer to images in memory and to images that must be loaded from external sources.
Thus, Java provides ways for you to create a new image object and ways to load one. It
also provides a means by which an image can be displayed. Let’s look at each.
Creating an Image Object
You might expect that you create a memory image using something like the following:
Image test = new Image(200, 100); // Error -- won't work
Not so. Because images must eventually be painted on a window to be seen, the Image
class doesn’t have enough information about its environment to create the proper data
format for the screen. Therefore, the Component class in java.awt has a factory method
called createImage( ) that is used to create Image objects. (Remember that all of the
AWT components are subclasses of Component, so all support this method.)
The createImage( ) method has the following two forms:
Image createImage(ImageProducer imgProd)
Image createImage(int width, int height)
The first form returns an image produced by imgProd, which is an object of a class that
implements the ImageProducer interface. (We will look at image producers later.)
The second form returns a blank (that is, empty) image that has the specified width
and height. Here is an example:
Canvas c = new Canvas();
Image test = c.createImage(200, 100);
This creates an instance of Canvas and then calls the createImage( ) method to actually
make an Image object. At this point, the image is blank. Later you will see how to write
data to it.
Loading an Image
The other way to obtain an image is to load one. To do this, use the getImage( ) method
defined by the Applet class. It has the following forms:
Image getImage(URL url)
Image getImage(URL url, String imageName)
C h a p t e r 2 3 : I m a g e s 801
TH
E
JA
V
A
LIB
R
A
R
Y
802 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
The first version returns an Image object that encapsulates the image found at
the location specified by url. The second version returns an Image object that
encapsulates the image found at the location specified by url and having the name
specified by imageName.
Displaying an Image
Once you have an image, you can display it by using drawImage( ), which is a member
of the Graphics class. It has several forms. The one we will be using is shown here:
boolean drawImage(Image imgObj, int left, int top, ImageObserver imgOb)
This displays the image passed in imgObj with its upper-left corner specified by left and
top. imgOb is a reference to a class that implements the ImageObserver interface. This
interface is implemented by all AWT components. An image observer is an object that
can monitor an image while it loads. ImageObserver is described in the next section.
With getImage( ) and drawImage( ), it is actually quite easy to load and display
an image. Here is a sample applet that loads and displays a single image. The file
seattle.jpg is loaded, but you can substitute any GIF or JPG file you like (just make sure
it is available in the same directory with the HTML file that contains the applet).
/*
* <applet code="SimpleImageLoad" width=248 height=146>
*  <param name="img" value="seattle.jpg">
* </applet>
*/
import java.awt.*;
import java.applet.*;
public class SimpleImageLoad extends Applet
{
Image img;
public void init() {
img = getImage(getDocumentBase(), getParameter("img"));
}
public void paint(Graphics g) {
g.drawImage(img, 0, 0, this);
}
}
In the init( ) method, the img variable is assigned to the image returned by
getImage( ). The getImage( ) method uses the string returned by getParameter(“img”)
as the filename for the image. This image is loaded from a URL that is relative to the
result of getDocumentBase( ), which is the URL of the HTML page this applet tag was
in. The filename returned by getParameter(“img”) comes from the applet tag <param
name=“img” value=“seattle.jpg”>. This is the equivalent, if a little slower, of using the
HTML tag <img src=“seattle.jpg” width=248 height=146>. Figure 23-1 shows what it
looks like when you run the program.
When this applet runs, it starts loading img in the init( ) method. Onscreen you can
see the image as it loads from the network, because Applet’s implementation of the
ImageObserver interface calls paint( ) every time more image data arrives.
Seeing the image load is somewhat informative, but it might be better if you use the
time it takes to load the image to do other things in parallel. That way, the fully formed
image can simply appear on the screen in an instant, once it is fully loaded. You can
use ImageObserver, described next, to monitor loading an image while you paint the
screen with other information.
ImageObserver
ImageObserver is an interface used to receive notification as an image is being
generated. ImageObserver defines only one method: imageUpdate( ). Using an image
observer allows you to perform other actions, such as show a progress indicator or an
attract screen, as you are informed of the progress of the download. This kind of
C h a p t e r 2 3 : I m a g e s 803
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 23-1. Sample output from SimpleImageLoad
notification is very useful when an image is being loaded over the network, where the
content designer rarely appreciates that people are often trying to load applets over a
slow modem.
The imageUpdate( ) method has this general form:
boolean imageUpdate(Image imgObj, int flags, int left, int top, int width, int height)
Here, imgObj is the image being loaded, and flags is an integer that communicates the
status of the update report. The four integers left, top, width, and height represent
a rectangle that contains different values depending on the values passed in flags.
imageUpdate( ) should return false if it has completed loading, and true if there is
more image to process.
The flags parameter contains one or more bit flags defined as static variables inside
the ImageObserver interface. These flags and the information they provide are listed
in Table 23-1.
804 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Flag Meaning
WIDTH The width parameter is valid and contains the width of the image.
HEIGHT The height parameter is valid and contains the height of the image.
PROPERTIES The properties associated with the image can now be obtained
using imgObj.getProperty( ).
SOMEBITS More pixels needed to draw the image have been received. The
parameters left, top, width, and height define the rectangle
containing the new pixels.
FRAMEBITS A complete frame that is part of a multiframe image, which was
previously drawn, has been received. This frame can be
displayed. The left, top, width, and height parameters are not used.
ALLBITS The image is now complete. The left, top, width, and height
parameters are not used.
ERROR An error has occurred to an image that was being tracked
asynchronously. The image is incomplete and cannot be
displayed. No further image information will be received. The
ABORT flag will also be set to indicate that the image production
was aborted.
ABORT An image that was being tracked asynchronously was aborted before
it was complete. However, if an error has not occurred, accessing any
part of the image’s data will restart the production of the image.
Table 23-1. Bit Flags of the imageUpdate( ) flags Parameter
C h a p t e r 2 3 : I m a g e s 805
TH
E
JA
V
A
LIB
R
A
R
Y
The Applet class has an implementation of the imageUpdate( ) method for the
ImageObserver interface that is used to repaint images as they are loaded. You can
override this method in your class to change that behavior.
Here is a simple example of an imageUpdate( ) method:
public boolean imageUpdate(Image img, int flags,
int x, int y, int w, int h) {
if ((flags & ALLBITS) == 0) {
System.out.println("Still processing the image.");
return true;
} else {
System.out.println("Done processing the image.");
return false;
}
}
ImageObserver Example
Now let’s look at a practical example that overrides imageUpdate( ) to make a version of
the SimpleImageLoad applet that doesn’t flicker as much. The default implementation
of imageUpdate( ) in Applet has several problems. First, it repaints the entire image each
time any new data arrives. This causes flashing between the background color and the
image. Second, it uses a feature of Applet.repaint( ) to cause the system to only repaint
the image every tenth of a second or so. This causes a jerky, uneven feel as the image is
painting. Finally, the default implementation knows nothing about images that may fail
to load properly. Many beginning Java programmers are frustrated by the fact that
getImage( ) always succeeds even when the image specified does not exist. You don’t
find out about missing images until imageUpdate( ) occurs. If you use the default
implementation of imageUpdate( ), then you’ll never know what happened. Your
paint( ) method will simply do nothing when you call g.drawImage( ).
The example that follows fixes all three of these problems in ten lines of code. First,
it eliminates the flickering with two small changes. It overrides update( ) so that it calls
paint( ) without painting the background color first. The background is set via
setBackground( ) in init( ), so the initial color is painted just once. Also, it uses a
version of repaint( ) that specifies the rectangle in which to paint. The system will set
the clipping area such that nothing outside of this rectangle is painted. This reduces
repaint flicker and improves performance.
Second, it eliminates the jerky, uneven display of the incoming image by painting
every time it receives an update. These updates occur on a scan line-by-scan line basis,
so an image that is 100 pixels tall will be “repainted” 100 times as it loads. Note that
this is not the fastest way to display an image, just the smoothest.
Finally, it handles the error caused by the desired file not being found by
examining the flags parameter for the ABORT bit. If it is set, the instance variable error
is set to true and then repaint( ) is called. The paint( ) method is modified to print an
error message over a bright red background if error is true.
Here is the code.
/*
* <applet code="ObservedImageLoad" width=248 height=146>
*  <param name="img" value="seattle.jpg">
* </applet>
*/
import java.awt.*;
import java.applet.*;
public class ObservedImageLoad extends Applet {
Image img;
boolean error = false;
String imgname;
public void init() {
setBackground(Color.blue);
imgname = getParameter("img");
img = getImage(getDocumentBase(), imgname);
}
public void paint(Graphics g) {
if (error) {
Dimension d = getSize();
g.setColor(Color.red);
g.fillRect(0, 0, d.width, d.height);
g.setColor(Color.black);
g.drawString("Image not found: " + imgname, 10, d.height/2);
} else {
g.drawImage(img, 0, 0, this);
}
}
public void update(Graphics g) {
paint(g);
}
806 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 3 : I m a g e s 807
TH
E
JA
V
A
LIB
R
A
R
Y
public boolean imageUpdate(Image img, int flags,
int x, int y, int w, int h) {
if ((flags & SOMEBITS) != 0) {  // new partial data
repaint(x, y, w, h);          // paint new pixels
} else if ((flags & ABORT) != 0) {
error = true;                 // file not found
repaint();                    // paint whole applet
}
return (flags & (ALLBITS|ABORT)) == 0;
}
}
Figure 23-2 shows two separate screens of this applet running. The top screen shows
the image half loaded, and the bottom screen displays a filename that has been
mistyped in the applet tag.
Here is an interesting variation of imageUpdate( ) you might want to try. It
waits until the image is completely loaded before snapping it onto the screen in a
single repaint.
public boolean imageUpdate(Image img, int flags,
int x, int y, int w, int h) {
if ((flags & ALLBITS) != 0) {
repaint();
} else if ((flags & (ABORT|ERROR)) != 0) {
error = true; // file not found
repaint();
}
return (flags & (ALLBITS|ABORT|ERROR)) == 0;
}
Double Buffering
Not only are images useful for storing pictures, as we’ve just shown, but you can
also use them as offscreen drawing surfaces. This allows you to render any image,
including text and graphics, to an offscreen buffer that you can display at a later time.
The advantage to doing this is that the image is seen only when it is complete. Drawing
a complicated image could take several milliseconds or more, which can be seen by the
user as flashing or flickering. This flashing is distracting and causes the user to perceive
your rendering as slower than it actually is. Use of an offscreen image to reduce flicker
is called double buffering, because the screen is considered a buffer for pixels, and the
offscreen image is the second buffer, where you can prepare pixels for display.
Earlier in this chapter, you saw how to create a blank Image object. Now you will
see how to draw on that image rather than the screen. As you recall from earlier
chapters, you need a Graphics object in order to use any of Java’s rendering methods.
Conveniently, the Graphics object that you can use to draw on an Image is available
via the getGraphics( ) method. Here is a code fragment that creates a new image,
obtains its graphics context, and fills the entire image with red pixels:
808 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 23-2. Sample output from ObservedImageLoad
Canvas c = new Canvas();
Image test = c.createImage(200, 100);
Graphics gc = test.getGraphics();
gc.setColor(Color.red);
gc.fillRect(0, 0, 200, 100);
Once you have constructed and filled an offscreen image, it will still not be visible.
To actually display the image, call drawImage( ). Here is an example that draws a
time-consuming image, to demonstrate the difference that double buffering can make
in perceived drawing time:
/*
* <applet code=DoubleBuffer width=250 height=250>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
public class DoubleBuffer extends Applet {
int gap = 3;
int mx, my;
boolean flicker = true;
Image buffer = null;
int w, h;
public void init() {
Dimension d = getSize();
w = d.width;
h = d.height;
buffer = createImage(w, h);
addMouseMotionListener(new MouseMotionAdapter() {
public void mouseDragged(MouseEvent me) {
mx = me.getX();
my = me.getY();
flicker = false;
repaint();
}
public void mouseMoved(MouseEvent me) {
mx = me.getX();
my = me.getY();
flicker = true;
C h a p t e r 2 3 : I m a g e s 809
TH
E
JA
V
A
LIB
R
A
R
Y
810 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
repaint();
}
});
}
public void paint(Graphics g) {
Graphics screengc = null;
if (!flicker) {
screengc = g;
g = buffer.getGraphics();
}
g.setColor(Color.blue);
g.fillRect(0, 0, w, h);
g.setColor(Color.red);
for (int i=0; i<w; i+=gap)
g.drawLine(i, 0, w-i, h);
for (int i=0; i<h; i+=gap)
g.drawLine(0, i, w, h-i);
g.setColor(Color.black);
g.drawString("Press mouse button to double buffer", 10, h/2);
g.setColor(Color.yellow);
g.fillOval(mx - gap, my - gap, gap*2+1, gap*2+1);
if (!flicker) {
screengc.drawImage(buffer, 0, 0, null);
}
}
public void update(Graphics g) {
paint(g);
}
}
This simple applet has a complicated paint( ) method. It fills the background with
blue and then draws a red moiré pattern on top of that. It paints some black text
on top of that and then paints a yellow circle centered at the coordinates mx,my. The
mouseMoved( ) and mouseDragged( ) methods are overridden to track the mouse
position. These methods are identical, except for the setting of the flicker Boolean
variable. mouseMoved( ) sets flicker to true, and mouseDragged( ) sets it to false.
This has the effect of calling repaint( ) with flicker set to true when the mouse is
moved (but no button is pressed) and set to false when the mouse is dragged with any
button pressed.
When paint( ) gets called with flicker set to true, we see each drawing operation as
it is executed on the screen. In the case where a mouse button is pressed and paint( ) is
called with flicker set to false, we see quite a different picture. The paint( ) method
swaps the Graphics reference g with the graphics context that refers to the offscreen
canvas, buffer, which we created in init( ). Then all of the drawing operations are
invisible. At the end of paint( ), we simply call drawImage( ) to show the results of
these drawing methods all at once.
Notice that it is okay to pass in a null as the fourth parameter to drawImage( ). This
is the parameter used to pass an ImageObserver object that receives notification of
image events. Since this is an image that is not being produced from a network stream,
we have no need for notification. The left snapshot in Figure 23-3 is what the applet
looks like with the mouse buttons not pressed. As you can see, the image was in the
middle of repainting when this snapshot was taken. The right snapshot shows how,
when a mouse button is pressed, the image is always complete and clean due to
double buffering.
MediaTracker
Many early Java developers found the ImageObserver interface far too difficult to
understand and manage when there were multiple images to be loaded. The developer
community asked for a simpler solution that would allow programmers to load all of
their images synchronously, without having to worry about imageUpdate( ). In
response to this, Sun Microsystems added a class to java.awt called MediaTracker in a
subsequent release of the JDK. A MediaTracker is an object that will check the status of
an arbitrary number of images in parallel.
To use MediaTracker, you create a new instance and use its addImage( ) method to
track the loading status of an image. addImage( ) has the following general forms:
void addImage(Image imgObj, int imgID)
void addImage(Image imgObj, int imgID, int width, int height)
Here, imgObj is the image being tracked. Its identification number is passed in imgID.
ID numbers do not need to be unique. You can use the same number with several
images as a means of identifying them as part of a group. In the second form, width and
height specify the dimensions of the object when it is displayed.
C h a p t e r 2 3 : I m a g e s 811
TH
E
JA
V
A
LIB
R
A
R
Y
Once you’ve registered an image, you can check whether it’s loaded, or you can
wait for it to completely load. To check the status of an image, call checkID( ). The
version used in this chapter is shown here:
boolean checkID(int imgID)
Here, imgID specifies the ID of the image you want to check. The method returns true if
all images that have the specified ID have been loaded (or if an error or user- abort has
terminated loading). Otherwise, it returns false. You can use the checkAll( ) method to
see if all images being tracked have been loaded.
You should use MediaTracker when loading a group of images. If all of the images
that you’re interested in aren’t downloaded, you can display something else to
entertain the user until they all arrive.
If you use MediaTracker once you’ve called addImage( ) on an image, a reference in
MediaTracker will prevent the system from garbage collecting it. If you want the
system to be able to garbage collect images that were being tracked, make sure it can
collect the MediaTracker instance as well.
812 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 23-3. Output from Double Buffer without (left) and with (right) double
buffering
Here’s an example that loads a seven-image slide show and displays a nice bar
chart of the loading progress:
/*
* <applet code="TrackedImageLoad" width=300 height=400>
* <param name="img"
* value="vincent+leonardo+matisse+picasso+renoir+seurat+vermeer">
* </applet>
*/
import java.util.*;
import java.applet.*;
import java.awt.*;
public class TrackedImageLoad extends Applet implements Runnable {
MediaTracker tracker;
int tracked;
int frame_rate = 5;
int current_img = 0;
Thread motor;
static final int MAXIMAGES = 10;
Image img[] = new Image[MAXIMAGES];
String name[] = new String[MAXIMAGES];
boolean stopFlag;
public void init() {
tracker = new MediaTracker(this);
StringTokenizer st = new StringTokenizer(getParameter("img"),
"+");
while(st.hasMoreTokens() && tracked <= MAXIMAGES) {
name[tracked] = st.nextToken();
img[tracked] = getImage(getDocumentBase(),
name[tracked] + ".jpg");
tracker.addImage(img[tracked], tracked);
tracked++;
}
}
public void paint(Graphics g) {
String loaded = "";
int donecount = 0;
C h a p t e r 2 3 : I m a g e s 813
TH
E
JA
V
A
LIB
R
A
R
Y
for(int i=0; i<tracked; i++) {
if (tracker.checkID(i, true)) {
donecount++;
loaded += name[i] + " ";
}
}
Dimension d = getSize();
int w = d.width;
int h = d.height;
if (donecount == tracked) {
frame_rate = 1;
Image i = img[current_img++];
int iw = i.getWidth(null);
int ih = i.getHeight(null);
g.drawImage(i, (w - iw)/2, (h - ih)/2, null);
if (current_img >= tracked)
current_img = 0;
} else {
int x = w * donecount / tracked;
g.setColor(Color.black);
g.fillRect(0, h/3, x, 16);
g.setColor(Color.white);
g.fillRect(x, h/3, w-x, 16);
g.setColor(Color.black);
g.drawString(loaded, 10, h/2);
}
}
public void start() {
motor = new Thread(this);
stopFlag = false;
motor.start();
}
public void stop() {
stopFlag = true;
}
public void run() {
814 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
motor.setPriority(Thread.MIN_PRIORITY);
while (true) {
repaint();
try {
Thread.sleep(1000/frame_rate);
} catch (InterruptedException e) { };
if(stopFlag)
return;
}
}
}
This example creates a new MediaTracker in the init( ) method, and then adds each of
the named images as a tracked image with addImage( ). In the paint( ) method, it calls
checkID( ) on each of the images that we’re tracking. If all of the images are loaded,
they are displayed. If not, a simple bar chart of the number of images loaded is shown,
with the names of the fully loaded images displayed underneath the bar. Figure 23-4
shows two scenes from this applet running. One is the bar chart, displaying that three
of the images have been loaded. The other is the Van Gogh self-portrait during the
slide show.
ImageProducer
ImageProducer is an interface for objects that want to produce data for images. An
object that implements the ImageProducer interface will supply integer or byte arrays
that represent image data and produce Image objects. As you saw earlier, one form of
the createImage( ) method takes an ImageProducer object as its argument. There are
two image producers contained in java.awt.image: MemoryImageSource and
FilteredImageSource. Here, we will examine MemoryImageSource and create a new
Image object from data generated in an applet.
MemoryImageSource
MemoryImageSource is a class that creates a new Image from an array of data. It
defines several constructors. Here is the one we will be using:
MemoryImageSource(int width, int height, int pixel[ ], int offset, int scanLineWidth)
The MemoryImageSource object is constructed out of the array of integers specified by
pixel, in the default RGB color model to produce data for an Image object. In the default
color model, a pixel is an integer with Alpha, Red, Green, and Blue (0xAARRGGBB).
The Alpha value represents a degree of transparency for the pixel. Fully transparent is
C h a p t e r 2 3 : I m a g e s 815
TH
E
JA
V
A
LIB
R
A
R
Y
0 and fully opaque is 255. The width and height of the resulting image are passed in
width and height. The starting point in the pixel array to begin reading data is passed in
offset. The width of a scan line (which is often the same as the width of the image) is
passed in scanLineWidth.
The following short example generates a MemoryImageSource object using a
variation on a simple algorithm (a bitwise-exclusive-OR of the x and y address of each
pixel) from the book Beyond Photography, The Digital Darkroom by Gerard J. Holzmann
(Prentice Hall, 1988).
816 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 23-4. Sample output from TrackedImageLoad
C h a p t e r 2 3 : I m a g e s 817
TH
E
JA
V
A
LIB
R
A
R
Y
/*
* <applet code="MemoryImageGenerator" width=256 height=256>
* </applet>
*/
import java.applet.*;
import java.awt.*;
import java.awt.image.*;
public class MemoryImageGenerator extends Applet {
Image img;
public void init() {
Dimension d = getSize();
int w = d.width;
int h = d.height;
int pixels[] = new int[w * h];
int i = 0;
for(int y=0; y<h; y++) {
for(int x=0; x<w; x++) {
int r = (x^y)&0xff;
int g = (x*2^y*2)&0xff;
int b = (x*4^y*4)&0xff;
pixels[i++] = (255 << 24) | (r << 16) | (g << 8) | b;
}
}
img = createImage(new MemoryImageSource(w, h, pixels, 0, w));
}
public void paint(Graphics g) {
g.drawImage(img, 0, 0, this);
}
}
The data for the new MemoryImageSource is created in the init( ) method. An
array of integers is created to hold the pixel values; the data is generated in the nested
for loops where the r, g, and b values get shifted into a pixel in the pixels array.
Finally, createImage( ) is called with a new instance of a MemoryImageSource created
from the raw pixel data as its parameter. Figure 23-5 shows the image when we run the
applet. (It looks much nicer in color.)
ImageConsumer
ImageConsumer is an abstract interface for objects that want to take pixel data from
images and supply it as another kind of data. This, obviously, is the opposite of
ImageProducer, described earlier. An object that implements the ImageConsumer
interface is going to create int or byte arrays that represent pixels from an Image
object. We will examine the PixelGrabber class, which is a simple implementation of
the ImageConsumer interface.
PixelGrabber
The PixelGrabber class is defined within java.lang.image. It is the inverse of the
MemoryImageSource class. Rather than constructing an image from an array of
pixel values, it takes an existing image and grabs the pixel array from it. To use
PixelGrabber, you first create an array of ints big enough to hold the pixel data, and
then you create a PixelGrabber instance passing in the rectangle that you want to grab.
Finally, you call grabPixels( ) on that instance.
The PixelGrabber constructor that is used in this chapter is shown here:
PixelGrabber(Image imgObj, int left, int top, int width, int height, int pixel[ ],
int offset, int scanLineWidth)
Here, imgObj is the object whose pixels are being grabbed. The values of left and top
specify the upper-left corner of the rectangle, and width and height specify the
818 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 23-5. Sample output from MemoryImageGenerator
C h a p t e r 2 3 : I m a g e s 819
TH
E
JA
V
A
LIB
R
A
R
Y
dimensions of the rectangle from which the pixels will be obtained. The pixels will be
stored in pixel beginning at offset. The width of a scan line (which is often the same as
the width of the image) is passed in scanLineWidth.
grabPixels( ) is defined like this:
boolean grabPixels( )
throws InterruptedException
boolean grabPixels(long milliseconds)
throws InterruptedException
Both methods return true if successful and false otherwise. In the second form,
milliseconds specifies how long the method will wait for the pixels.
Here is an example that grabs the pixels from an image and then creates a
histogram of pixel brightness. The histogram is simply a count of pixels that are a
certain brightness for all brightness settings between 0 and 255. After the applet paints
the image, it draws the histogram over the top.
/*
* <applet code=HistoGrab.class width=341 height=400>
* <param name=img value=vermeer.jpg>
* </applet> */
import java.applet.*;
import java.awt.* ;
import java.awt.image.* ;
public class HistoGrab extends Applet {
Dimension d;
Image img;
int iw, ih;
int pixels[];
int w, h;
int hist[] = new int[256];
int max_hist = 0;
public void init() {
d = getSize();
w = d.width;
h = d.height;
try {
img = getImage(getDocumentBase(), getParameter("img"));
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
iw = img.getWidth(null);
ih = img.getHeight(null);
pixels = new int[iw * ih];
PixelGrabber pg = new PixelGrabber(img, 0, 0, iw, ih,
pixels, 0, iw);
pg.grabPixels();
} catch (InterruptedException e) { };
for (int i=0; i<iw*ih; i++) {
int p = pixels[i];
int r = 0xff & (p >> 16);
int g = 0xff & (p >> 8);
int b = 0xff & (p);
int y = (int) (.33 * r + .56 * g + .11 * b);
hist[y]++;
}
for (int i=0; i<256; i++) {
if (hist[i] > max_hist)
max_hist = hist[i];
}
}
public void update() {}
public void paint(Graphics g) {
g.drawImage(img, 0, 0, null);
int x = (w - 256) / 2;
int lasty = h - h * hist[0] / max_hist;
for (int i=0; i<256; i++, x++) {
int y = h - h * hist[i] / max_hist;
g.setColor(new Color(i, i, i));
g.fillRect(x, y, 1, h);
g.setColor(Color.red);
g.drawLine(x-1,lasty,x,y);
lasty = y;
}
}
}
Figure 23-6 shows the image and histogram for a famous Vermeer painting.
820 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
C h a p t e r 2 3 : I m a g e s 821
TH
E
JA
V
A
LIB
R
A
R
Y
ImageFilter
Given the ImageProducer and ImageConsumer interface pair—and their concrete
classes MemoryImageSource and PixelGrabber—you can create an arbitrary set of
translation filters that takes a source of pixels, modifies them, and passes them on to
an arbitrary consumer. This mechanism is analogous to the way concrete classes are
created from the abstract I/O classes InputStream, OutputStream, Reader, and
Writer (described in Chapter 17). This stream model for images is completed by
the introduction of the ImageFilter class. Some subclasses of ImageFilter in the
java.awt.image package are AreaAveragingScaleFilter, CropImageFilter,
ReplicateScaleFilter, and RGBImageFilter. There is also an implementation of
ImageProducer called FilteredImageSource, which takes an arbitrary ImageFilter
and wraps it around an ImageProducer to filter the pixels it produces. An instance
of FilteredImageSource can be used as an ImageProducer in calls to createImage, in
much the same way that BufferedInputStreams can be passed off as InputStreams.
In this chapter, we examine two filters: CropImageFilter and RGBImageFilter.
CropImageFilter
CropImageFilter filters an image source to extract a rectangular region. One situation
in which this filter is valuable is where you want to use several small images from a
Figure 23-6. Sample output from HistoGrab
single, larger source image. Loading twenty 2K images takes much longer than loading
a single 40K image that has many frames of an animation tiled into it. If every
subimage is the same size, then you can easily extract these images by using
CropImageFilter to disassemble the block once your applet starts. Here is an example
that creates 16 images taken from a single image. The tiles are then scrambled by
swapping a random pair from the 16 images 32 times.
/*
* <applet code=TileImage.class width=288 height=399>
* <param name=img value=picasso.jpg>
* </applet>
*/
import java.applet.*;
import java.awt.*;
import java.awt.image.*;
public class TileImage extends Applet {
Image img;
Image cell[] = new Image[4*4];
int iw, ih;
int tw, th;
public void init() {
try {
img = getImage(getDocumentBase(), getParameter("img"));
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
iw = img.getWidth(null);
ih = img.getHeight(null);
tw = iw / 4;
th = ih / 4;
CropImageFilter f;
FilteredImageSource fis;
t = new MediaTracker(this);
for (int y=0; y<4; y++) {
for (int x=0; x<4; x++) {
f = new CropImageFilter(tw*x, th*y, tw, th);
fis = new FilteredImageSource(img.getSource(), f);
int i = y*4+x;
cell[i] = createImage(fis);
t.addImage(cell[i], i);
822 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}}
t.waitForAll();
for (int i=0; i<32; i++) {
int si = (int)(Math.random() * 16);
int di = (int)(Math.random() * 16);
Image tmp = cell[si];
cell[si] = cell[di];
cell[di] = tmp;
}
} catch (InterruptedException e) { };
}
public void update(Graphics g) {
paint(g);
}
public void paint(Graphics g) {
for (int y=0; y<4; y++) {
for (int x=0; x<4; x++) {
g.drawImage(cell[y*4+x], x * tw, y * th, null);
}
}
}
}
Figure 23-7 shows a famous Picasso painting scrambled by the TileImage applet.
RGBImageFilter
The RGBImageFilter is used to convert one image to another, pixel by pixel,
transforming the colors along the way. This filter could be used to brighten an
image, to increase its contrast, or even to convert it to grayscale.
To demonstrate RGBImageFilter, we have developed a somewhat complicated
example, which employs a dynamic plug-in strategy for image-processing filters.
We’ve created an interface for generalized image filtering so that our applet can simply
load these filters based on <param> tags without having to know about all of the
ImageFilters in advance. This example consists of the main applet class called
ImageFilterDemo, the interface called PlugInFilter, and a utility class called
LoadedImage, which encapsulates some of the MediaTracker methods we’ve been
using in this chapter. Also included are three filters—Grayscale, Invert, and
Contrast—which simply manipulate the color space of the source image using
C h a p t e r 2 3 : I m a g e s 823
TH
E
JA
V
A
LIB
R
A
R
Y
RGBImageFilters, and two more classes—Blur and Sharpen—which do more
complicated “convolution” filters that change pixel data based on the pixels
surrounding each pixel of source data. Blur and Sharpen are subclasses of an
abstract helper class called Convolver. Let’s look at each part of our example.
ImageFilterDemo.java
The ImageFilterDemo class is the applet framework for our sample image filters. It
employs a simple BorderLayout, with a Panel at the South position to hold the buttons
that will represent each filter. A Label object occupies the North slot for informational
messages about filter progress. The Center is where the image (which is encapsulated in
the LoadedImage Canvas subclass, described later) is put. We parse the buttons/filters
out of the filters <param> tag, separating them with +’s using a StringTokenizer.
The actionPerformed( ) method is interesting because it uses the label from a
button as the name of a filter class that it tries to load with (PlugInFilter)
Class.forName(a).newInstance( ). This method is robust and takes appropriate action
if the button does not correspond to a proper class that implements PlugInFilter.
824 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Figure 23-7. Sample output from TileImage
TH
E
JA
V
A
LIB
R
A
R
Y
C h a p t e r 2 3 : I m a g e s 825
/*
* <applet code=ImageFilterDemo width=350 height=450>
* <param name=img value=vincent.jpg>
* <param name=filters value="Grayscale+Invert+Contrast+Blur+ Sharpen">
* </applet>
*/
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
public class ImageFilterDemo extends Applet implements ActionListener {
Image img;
PlugInFilter pif;
Image fimg;
Image curImg;
LoadedImage lim;
Label lab;
Button reset;
public void init() {
setLayout(new BorderLayout());
Panel p = new Panel();
add(p, BorderLayout.SOUTH);
reset = new Button("Reset");
reset.addActionListener(this);
p.add(reset);
StringTokenizer st = new StringTokenizer(getParameter("filters"), "+");
while(st.hasMoreTokens()) {
Button b = new Button(st.nextToken());
b.addActionListener(this);
p.add(b);
}
lab = new Label("");
add(lab, BorderLayout.NORTH);
img = getImage(getDocumentBase(), getParameter("img"));
lim = new LoadedImage(img);
826 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
add(lim, BorderLayout.CENTER);
}
public void actionPerformed(ActionEvent ae) {
String a = "";
try {
a = (String)ae.getActionCommand();
if (a.equals("Reset")) {
lim.set(img);
lab.setText("Normal");
}
else {
pif = (PlugInFilter) Class.forName(a).newInstance();
fimg = pif.filter(this, img);
lim.set(fimg);
lab.setText("Filtered: " + a);
}
repaint();
} catch (ClassNotFoundException e) {
lab.setText(a + " not found");
lim.set(img);
repaint();
} catch (InstantiationException e) {
lab.setText("could't new " + a);
} catch (IllegalAccessException e) {
lab.setText("no access: " + a);
}
}
}
Figure 23-8 shows what the applet looks like when it is first loaded using the applet tag
shown at the top of this source file.
PlugInFilter.java
PlugInFilter is a simple interface used to abstract image filtering. It has only one
method, filter( ), which takes the applet and the source image and returns a new image
that has been filtered in some way.
interface PlugInFilter {
java.awt.Image filter(java.applet.Applet a, java.awt.Image in);
}
LoadedImage.java
LoadedImage is a convenient subclass of Canvas, which takes an image at construction
time and synchronously loads it using MediaTracker. LoadedImage then behaves
properly inside of LayoutManager control, because it overrides the getPreferredSize( )
and getMinimumSize( ) methods. Also, it has a method called set( ) that can be used to
set a new Image to be displayed in this Canvas. That is how the filtered image is
displayed after the plug-in is finished.
import java.awt.*;
public class LoadedImage extends Canvas {
Image img;
public LoadedImage(Image i) {
set(i);
}
void set(Image i) {
C h a p t e r 2 3 : I m a g e s 827
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 23-8. Sample normal output from ImageFilterDemo
MediaTracker mt = new MediaTracker(this);
mt.addImage(i, 0);
try {
mt.waitForAll();
} catch (InterruptedException e) { };
img = i;
repaint();
}
public void paint(Graphics g) {
if (img == null) {
g.drawString("no image", 10, 30);
} else {
g.drawImage(img, 0, 0, this);
}
}
public Dimension getPreferredSize()  {
return new Dimension(img.getWidth(this), img.getHeight(this));
}
public Dimension getMinimumSize()  {
return getPreferredSize();
}
}
Grayscale.java
The Grayscale filter is a subclass of RGBImageFilter, which means that Grayscale can
use itself as the ImageFilter parameter to FilteredImageSource’s constructor. Then all
it needs to do is override filterRGB( ) to change the incoming color values. It takes the
red, green, and blue values and computes the brightness of the pixel, using the NTSC
(National Television Standards Committee) color-to-brightness conversion factor. It
then simply returns a gray pixel that is the same brightness as the color source.
import java.applet.*;
import java.awt.*;
import java.awt.image.*;
class Grayscale extends RGBImageFilter implements PlugInFilter {
public Image filter(Applet a, Image in) {
828 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
return a.createImage(new FilteredImageSource(in.getSource(), this));
}
public int filterRGB(int x, int y, int rgb) {
int r = (rgb >> 16) & 0xff;
int g = (rgb >> 8) & 0xff;
int b = rgb & 0xff;
int k = (int) (.56 * g + .33 * r + .11 * b);
return (0xff000000 | k << 16 | k << 8 | k);
}
}
Invert.java
The Invert filter is also quite simple. It takes apart the red, green, and blue channels
and then inverts them by subtracting them from 255. These inverted values are packed
back into a pixel value and returned.
import java.applet.*;
import java.awt.*;
import java.awt.image.*;
class Invert extends RGBImageFilter implements PlugInFilter {
public Image filter(Applet a, Image in) {
return a.createImage(new FilteredImageSource(in.getSource(), this));
}
public int filterRGB(int x, int y, int rgb) {
int r = 0xff - (rgb >> 16) & 0xff;
int g = 0xff - (rgb >> 8) & 0xff;
int b = 0xff - rgb & 0xff;
return (0xff000000 | r << 16 | g << 8 | b);
}
}
Figure 23-9 shows the image after it has been run through the Invert filter.
Contrast.java
The Contrast filter is very similar to Grayscale, except its override of filterRGB( ) is
slightly more complicated. The algorithm it uses for contrast enhancement takes the
red, green, and blue values separately and boosts them by 1.2 times if they are already
brighter than 128. If they are below 128, then they are divided by 1.2. The boosted
values are properly clamped at 255 by the multclamp( ) method.
C h a p t e r 2 3 : I m a g e s 829
TH
E
JA
V
A
LIB
R
A
R
Y
830 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
import java.applet.*;
import java.awt.*;
import java.awt.image.*;
public class Contrast extends RGBImageFilter implements PlugInFilter {
public Image filter(Applet a, Image in) {
return a.createImage(new FilteredImageSource(in.getSource(), this));
}
private int multclamp(int in, double factor) {
in = (int) (in * factor);
return in > 255 ? 255 : in;
}
double gain = 1.2;
Figure 23-9. Using the Invert filter with ImageFilterDemo
private int cont(int in) {
return (in < 128) ? (int)(in/gain) : multclamp(in, gain);
}
public int filterRGB(int x, int y, int rgb) {
int r = cont((rgb >> 16) & 0xff);
int g = cont((rgb >> 8) & 0xff);
int b = cont(rgb & 0xff);
return (0xff000000 | r << 16 | g << 8 | b);
}
}
Figure 23-10 shows the image after Contrast is pressed.
Convolver.java
The abstract class Convolver handles the basics of a convolution filter by implementing
the ImageConsumer interface to move the source pixels into an array called imgpixels.
It also creates a second array called newimgpixels for the filtered data. Convolution
filters sample a small rectangle of pixels around each pixel in an image, called the
C h a p t e r 2 3 : I m a g e s 831
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 23-10. Using the Contrast filter with ImageFilterDemo
convolution kernel. This area, 3×3 pixels in this demo, is used to decide how to change
the center pixel in the area. The two concrete subclasses, shown in the next section,
simply implement the convolve( ) method, using imgpixels for source data and
newimgpixels to store the result.
The reason that the filter can’t modify the imgpixels array in place is that the next pixel
on a scan line would try to use the original value for the previous pixel, which would
have just been filtered away.
import java.applet.*;
import java.awt.*;
import java.awt.image.*;
abstract class Convolver implements ImageConsumer, PlugInFilter {
int width, height;
int imgpixels[], newimgpixels[];
abstract void convolve();  // filter goes here...
public Image filter(Applet a, Image in) {
in.getSource().startProduction(this);
waitForImage();
newimgpixels = new int[width*height];
try {
convolve();
} catch (Exception e) {
System.out.println("Convolver failed: " + e);
e.printStackTrace();
}
return a.createImage(
new MemoryImageSource(width, height, newimgpixels, 0, width));
}
synchronized void waitForImage() {
try { wait(); } catch (Exception e) { };
}
public void setProperties(java.util.Hashtable dummy) { }
public void setColorModel(ColorModel dummy) { }
832 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
public void setHints(int dummy) { }
public synchronized void imageComplete(int dummy) {
notifyAll();
}
public void setDimensions(int x, int y) {
width = x;
height = y;
imgpixels = new int[x*y];
}
public void setPixels(int x1, int y1, int w, int h,
ColorModel model, byte pixels[], int off, int scansize) {
int pix, x, y, x2, y2, sx, sy;
x2 = x1+w;
y2 = y1+h;
sy = off;
for(y=y1; y<y2; y++) {
sx = sy;
for(x=x1; x<x2; x++) {
pix = model.getRGB(pixels[sx++]);
if((pix & 0xff000000) == 0)
pix = 0x00ffffff;
imgpixels[y*width+x] = pix;
}
sy += scansize;
}
}
public void setPixels(int x1, int y1, int w, int h,
ColorModel model, int pixels[], int off, int scansize) {
int pix, x, y, x2, y2, sx, sy;
x2 = x1+w;
y2 = y1+h;
sy = off;
for(y=y1; y<y2; y++) {
sx = sy;
for(x=x1; x<x2; x++) {
C h a p t e r 2 3 : I m a g e s 833
TH
E
JA
V
A
LIB
R
A
R
Y
pix = model.getRGB(pixels[sx++]);
if((pix & 0xff000000) == 0)
pix = 0x00ffffff;
imgpixels[y*width+x] = pix;
}
sy += scansize;
}
}
}
Blur.java
The Blur filter is a subclass of Convolver and simply runs through every pixel in the
source image array, imgpixels, and computes the average of the 3×3 box surrounding
it. The corresponding output pixel in newimgpixels is that average value.
public class Blur extends Convolver {
public void convolve() {
for(int y=1; y<height-1; y++) {
for(int x=1; x<width-1; x++) {
int rs = 0;
int gs = 0;
int bs = 0;
for(int k=-1; k<=1; k++) {
for(int j=-1; j<=1; j++) {
int rgb = imgpixels[(y+k)*width+x+j];
int r = (rgb >> 16) & 0xff;
int g = (rgb >> 8) & 0xff;
int b = rgb & 0xff;
rs += r;
gs += g;
bs += b;
}
}
rs /= 9;
gs /= 9;
bs /= 9;
newimgpixels[y*width+x] = (0xff000000 |
834 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
rs << 16 | gs << 8 | bs);
}
}
}
}
Figure 23-11 shows the applet after Blur.
Sharpen.java
The Sharpen filter is also a subclass of Convolver and is (more or less) the inverse of
Blur. It runs through every pixel in the source image array, imgpixels, and computes
the average of the 3×3 box surrounding it, not counting the center. The corresponding
output pixel in newimgpixels has the difference between the center pixel and the
surrounding average added to it. This basically says that if a pixel is 30 brighter
than its surroundings, make it another 30 brighter. If, however, it is 10 darker, then
make it another 10 darker. This tends to accentuate edges while leaving smooth
areas unchanged.
C h a p t e r 2 3 : I m a g e s 835
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 23-11. Using the Blur filter with ImageFilterDemo
public class Sharpen extends Convolver {
private final int clamp(int c) {
return (c > 255 ? 255 : (c < 0 ? 0 : c));
}
public void convolve() {
int r0=0, g0=0, b0=0;
for(int y=1; y<height-1; y++) {
for(int x=1; x<width-1; x++) {
int rs = 0;
int gs = 0;
int bs = 0;
for(int k=-1; k<=1; k++) {
for(int j=-1; j<=1; j++) {
int rgb = imgpixels[(y+k)*width+x+j];
int r = (rgb >> 16) & 0xff;
int g = (rgb >> 8) & 0xff;
int b = rgb & 0xff;
if (j == 0 && k == 0) {
r0 = r;
g0 = g;
b0 = b;
} else {
rs += r;
gs += g;
bs += b;
}
}
}
rs >>= 3;
gs >>= 3;
bs >>= 3;
newimgpixels[y*width+x] = (0xff000000 |
clamp(r0+r0-rs) << 16 |
clamp(g0+g0-gs) << 8 |
clamp(b0+b0-bs));
}
}
}
}
Figure 23-12 shows the applet after Sharpen.
836 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
Cell Animation
Now that we have presented an overview of the image APIs, we can put together
an interesting applet that will display a sequence of animation cells. The animation
cells are taken from a single image that can arrange the cells in a grid specified via
the rows and cols <param> tags. Each cell in the image is snipped out in a way similar
to that used in the TileImage example earlier. We obtain the sequence in which to
display the cells from the sequence <param> tag. This is a comma-separated list of
cell numbers that is zero-based and proceeds across the grid from left to right, top
to bottom.
Once the applet has parsed the <param> tags and loaded the source image, it cuts
the image into a number of small subimages. Then, a thread is started that causes the
images to be displayed according to the order described in sequence. The thread sleeps
for enough time to maintain the framerate. Here is the source code:
// Animation example.
import java.applet.*;
import java.awt.*;
C h a p t e r 2 3 : I m a g e s 837
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 23-12. Using the Sharpen filter with ImageFilterDemo
import java.awt.image.*;
import java.util.*;
public class Animation extends Applet implements Runnable {
Image cell[];
final int MAXSEQ = 64;
int sequence[];
int nseq;
int idx;
int framerate;
boolean stopFlag;
private int intDef(String s, int def) {
int n = def;
if (s != null)
try {
n = Integer.parseInt(s);
} catch (NumberFormatException e) { };
return n;
}
public void init() {
framerate = intDef(getParameter("framerate"), 5);
int tilex = intDef(getParameter("cols"), 1);
int tiley = intDef(getParameter("rows"), 1);
cell = new Image[tilex*tiley];
StringTokenizer st = new
StringTokenizer(getParameter("sequence"), ",");
sequence = new int[MAXSEQ];
nseq = 0;
while(st.hasMoreTokens() && nseq < MAXSEQ) {
sequence[nseq] = intDef(st.nextToken(), 0);
nseq++;
}
try {
Image img = getImage(getDocumentBase(), getParameter("img"));
838 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
MediaTracker t = new MediaTracker(this);
t.addImage(img, 0);
t.waitForID(0);
int iw = img.getWidth(null);
int ih = img.getHeight(null);
int tw = iw / tilex;
int th = ih / tiley;
CropImageFilter f;
FilteredImageSource fis;
for (int y=0; y<tiley; y++) {
for (int x=0; x<tilex; x++) {
f = new CropImageFilter(tw*x, th*y, tw, th);
fis = new FilteredImageSource(img.getSource(), f);
int i = y*tilex+x;
cell[i] = createImage(fis);
t.addImage(cell[i], i);
}
}
t.waitForAll();
} catch (InterruptedException e) { };
}
public void update(Graphics g) { }
public void paint(Graphics g) {
g.drawImage(cell[sequence[idx]], 0, 0, null);
}
Thread t;
public void start() {
t = new Thread(this);
stopFlag = false;
t.start();
}
public void stop() {
stopFlag = true;
C h a p t e r 2 3 : I m a g e s 839
TH
E
JA
V
A
LIB
R
A
R
Y
840 J a v a ™ 2 : T h e C o m p l e t e R e f e r e n c e
}
public void run() {
idx = 0;
while (true) {
paint(getGraphics());
idx = (idx + 1) % nseq;
try { Thread.sleep(1000/framerate); } catch (Exception e) { };
if(stopFlag)
return;
}
}
}
The following applet tag shows the famous locomotion study by Eadweard
Muybridge, which proved that horses do, indeed, get all four hooves off the ground at
once. (Of course, you can substitute another image file in your own applet.)
<applet code=Animation width=67 height=48>
<param name=img value=horse.gif>
<param name=rows value=3>
<param name=cols value=4>
<param name=sequence value=0,1,2,3,4,5,6,7,8,9,10>
<param name=framerate value=15>
</applet>
Figure 23-13 shows the applet running. Notice the source image that has been loaded
below the applet using a normal <img> tag.
Additional Imaging Classes
In addition to the imaging classes described in this chapter, java.awt.image supplies several
others that offer enhanced control over the imaging process and that support advanced
imaging techniques. Java 2, version 1.4 also adds a new imaging package called
javax.imageio. This package supports plug-ins that handle various image formats.
If sophisticated graphical output is of special interest to you, then you will want to
explore the additional classes found in java.awt.image and javax.imageio.
C h a p t e r 2 3 : I m a g e s 841
TH
E
JA
V
A
LIB
R
A
R
Y
Figure 23-13. Sample output of Animation
This page intentionally left blank.
Chapter 24
New I/O, Regular
Expressions, and
Other Packages
843
